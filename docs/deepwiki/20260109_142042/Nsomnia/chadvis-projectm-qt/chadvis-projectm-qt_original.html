<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/4cf2300e9c8272f7-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/de70bee13400563f.css?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/3e435f9a1dbb5b5b.css?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-5400bf868d87f903.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS"/><script src="/_next/static/chunks/87c73c54-dd8d81ac9604067c.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/18-34cff86257462f1e.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/main-app-57aa1716f0d0f500.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/b1298b8d-5cac6cd7c8e952ff.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/378e5a93-860e027c5a5e0c0d.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/f7f68e2d-d8bf979db5ff4e9d.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/7963-b29c27a8b53c3f2a.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/1265-fa8a95d3842768f5.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/9885-b57089f03806c3b8.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/659-ee9e1e775e30dcef.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/app/layout-0537c2076823e553.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/7bf36345-1ac10ec2f0e0c88f.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/c16f53c3-b390b6f98a69dcec.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/6212-505c2fc95d1a35ae.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/4336-624d5ae6f4cc1cc7.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/8461-369a9f0c48ea2626.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/7198-985a49f2b6072d25.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/5462-08221e91030fd747.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/4429-943205658cbafffe.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/9976-9250854d58eefaa3.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/1481-25d5bbc4f2d9524a.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/app/%5Borg%5D/%5Brepo%5D/%5B%5B...wikiRoutes%5D%5D/page-6651f8cd8321a0db.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/25-9f305b682cea7558.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/7391-3ba9e11c5966ae03.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/6373-d56a493968555802.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/6375-7e0e75eb09fc9abe.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/9437-be873d1907eef4d4.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><script src="/_next/static/chunks/app/%5Borg%5D/%5Brepo%5D/layout-77683f6369c5b39e.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" async=""></script><meta name="next-size-adjust" content=""/><title>Nsomnia/chadvis-projectm-qt | DeepWiki</title><meta name="description" content="This page provides a comprehensive introduction to chadvis-projectm-qt, covering its purpose, architecture, technology stack, and core systems. For detailed information on specific subsystems, refer t"/><meta name="keywords" content="Nsomnia/chadvis-projectm-qt,Nsomnia,chadvis-projectm-qt,documentation,wiki,codebase,AI documentation,Devin,Overview"/><link rel="canonical" href="https://deepwiki.com/Nsomnia/chadvis-projectm-qt"/><meta property="og:title" content="Nsomnia/chadvis-projectm-qt | DeepWiki"/><meta property="og:description" content="This page provides a comprehensive introduction to chadvis-projectm-qt, covering its purpose, architecture, technology stack, and core systems. For detailed information on specific subsystems, refer t"/><meta property="og:url" content="https://deepwiki.com/Nsomnia/chadvis-projectm-qt"/><meta property="og:site_name" content="DeepWiki"/><meta property="og:image" content="https://deepwiki.com/Nsomnia/chadvis-projectm-qt/og-image.png?page=1"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@cognition"/><meta name="twitter:creator" content="@cognition"/><meta name="twitter:title" content="Nsomnia/chadvis-projectm-qt | DeepWiki"/><meta name="twitter:description" content="This page provides a comprehensive introduction to chadvis-projectm-qt, covering its purpose, architecture, technology stack, and core systems. For detailed information on specific subsystems, refer t"/><meta name="twitter:image" content="https://deepwiki.com/Nsomnia/chadvis-projectm-qt/og-image.png?page=1"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="48x48"/><link rel="icon" href="/icon.png?1ee4c6a68a73a205" type="image/png" sizes="48x48"/><link rel="apple-touch-icon" href="/apple-icon.png?a4f658907db0ab87" type="image/png" sizes="180x180"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" noModule=""></script></head><body class="__variable_188709 font-geist-sans relative min-h-screen __variable_9a8899 bg-background antialiased"><div hidden=""><!--$--><!--/$--></div><section aria-label="Notifications alt+T" tabindex="-1" aria-live="polite" aria-relevant="additions text" aria-atomic="false"></section><script>((a,b,c,d,e,f,g,h)=>{let i=document.documentElement,j=["light","dark"];function k(b){var c;(Array.isArray(a)?a:[a]).forEach(a=>{let c="class"===a,d=c&&f?e.map(a=>f[a]||a):e;c?(i.classList.remove(...d),i.classList.add(f&&f[b]?f[b]:b)):i.setAttribute(a,b)}),c=b,h&&j.includes(c)&&(i.style.colorScheme=c)}if(d)k(d);else try{let a=localStorage.getItem(b)||c,d=g&&"system"===a?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":a;k(d)}catch(a){}})("class","theme","light",null,["light","dark"],null,true,true)</script><!--$?--><template id="B:0"></template><div class="flex min-h-screen w-full flex-col text-white"><div class="container-wrapper flex flex-1 items-center justify-center px-4"><div class="inline-block bg-clip-text text-[#b5b5b5a4] animate-shine text-center text-lg" style="background-image:linear-gradient(120deg, rgba(255, 255, 255, 0) 40%, rgba(255, 255, 255, 0.8) 50%, rgba(255, 255, 255, 0) 60%);background-size:200% 100%;-webkit-background-clip:text;animation-duration:1s">Loading...</div></div></div><!--/$--><script>requestAnimationFrame(function(){$RT=performance.now()});</script><script src="/_next/static/chunks/webpack-5400bf868d87f903.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS" id="_R_" async=""></script><div hidden id="S:0"><div class="flex min-h-screen w-full flex-col text-white" id="codebase-wiki-repo-page"><div class="bg-background border-b-border sticky top-0 z-30 border-b border-dashed"><div class="font-geist-mono relative flex h-8 items-center justify-center text-xs font-medium sm:hidden"><div class="powered-by-devin-gradient absolute inset-0 z-[-1] h-8 w-full"></div><button class="flex items-center gap-2"><svg class="size-3 [&amp;_path]:stroke-0 [&amp;_path]:animate-[custom-pulse_1.8s_infinite_var(--delay,0s)]" xmlns="http://www.w3.org/2000/svg" viewBox="110 110 460 500"><path style="fill:#21c19a" class="[--delay:0.6s]" d="M418.73,332.37c9.84-5.68,22.07-5.68,31.91,0l25.49,14.71c.82.48,1.69.8,2.58,1.06.19.06.37.11.55.16.87.21,1.76.34,2.65.35.04,0,.08.02.13.02.1,0,.19-.03.29-.04.83-.02,1.64-.13,2.45-.32.14-.03.28-.05.42-.09.87-.24,1.7-.59,2.5-1.03.08-.04.17-.06.25-.1l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-.08.04-.13.11-.2.16-.78.48-1.51,1.02-2.15,1.66-.1.1-.18.21-.28.31-.57.6-1.08,1.26-1.51,1.97-.07.12-.15.22-.22.34-.44.77-.77,1.6-1.03,2.47-.05.19-.1.37-.14.56-.22.89-.37,1.81-.37,2.76v29.43c0,11.36-6.11,21.95-15.95,27.63-9.84,5.68-22.06,5.68-31.91,0l-25.49-14.71c-.82-.48-1.69-.8-2.57-1.06-.19-.06-.37-.11-.56-.16-.88-.21-1.76-.34-2.65-.34-.13,0-.26.02-.4.02-.84.02-1.66.13-2.47.32-.13.03-.27.05-.4.09-.87.24-1.71.6-2.51,1.04-.08.04-.16.06-.24.1l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22l50.97,29.43c.08.04.17.06.24.1.8.44,1.64.79,2.5,1.03.14.04.28.06.42.09.81.19,1.62.3,2.45.32.1,0,.19.04.29.04.04,0,.08-.02.13-.02.89,0,1.77-.13,2.65-.35.19-.04.37-.1.56-.16.88-.26,1.75-.59,2.58-1.06l25.49-14.71c9.84-5.68,22.06-5.68,31.91,0,9.84,5.68,15.95,16.27,15.95,27.63v29.43c0,.95.15,1.87.37,2.76.05.19.09.37.14.56.25.86.59,1.69,1.03,2.47.07.12.15.22.22.34.43.71.94,1.37,1.51,1.97.1.1.18.21.28.31.65.63,1.37,1.18,2.15,1.66.07.04.13.11.2.16l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-.08-.04-.16-.06-.24-.1-.8-.44-1.64-.8-2.51-1.04-.13-.04-.26-.05-.39-.09-.82-.2-1.65-.31-2.49-.33-.13,0-.25-.02-.38-.02-.89,0-1.78.13-2.66.35-.18.04-.36.1-.54.15-.88.26-1.75.59-2.58,1.07l-25.49,14.72c-9.84,5.68-22.07,5.68-31.9,0-9.84-5.68-15.95-16.27-15.95-27.63s6.11-21.95,15.95-27.63Z"></path><path style="fill:#3969ca" d="M141.09,317.65l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c.08-.04.13-.11.2-.16.78-.48,1.51-1.02,2.15-1.66.1-.1.18-.21.28-.31.57-.6,1.08-1.26,1.51-1.97.07-.12.15-.22.22-.34.44-.77.77-1.6,1.03-2.47.05-.19.1-.37.14-.56.22-.89.37-1.81.37-2.76v-29.43c0-11.36,6.11-21.95,15.96-27.63s22.06-5.68,31.91,0l25.49,14.71c.82.48,1.69.8,2.57,1.06.19.06.37.11.56.16.87.21,1.76.34,2.64.35.04,0,.09.02.13.02.1,0,.19-.04.29-.04.83-.02,1.65-.13,2.45-.32.14-.03.28-.05.41-.09.87-.24,1.71-.6,2.51-1.04.08-.04.16-.06.24-.1l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-.08.04-.13.11-.2.16-.78.48-1.51,1.02-2.15,1.66-.1.1-.18.21-.28.31-.57.6-1.08,1.26-1.51,1.97-.07.12-.15.22-.22.34-.44.77-.77,1.6-1.03,2.47-.05.19-.1.37-.14.56-.22.89-.37,1.81-.37,2.76v29.43c0,11.36-6.11,21.95-15.95,27.63-9.84,5.68-22.07,5.68-31.91,0l-25.49-14.71c-.82-.48-1.69-.8-2.58-1.06-.19-.06-.37-.11-.55-.16-.88-.21-1.76-.34-2.65-.35-.13,0-.26.02-.4.02-.83.02-1.66.13-2.47.32-.13.03-.27.05-.4.09-.87.24-1.71.6-2.51,1.04-.08.04-.16.06-.24.1l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22Z"></path><path style="fill:#0294de" class="[--delay:1.2s]" d="M396.88,484.35l-50.97-29.43c-.08-.04-.17-.06-.24-.1-.8-.44-1.64-.79-2.51-1.03-.14-.04-.27-.06-.41-.09-.81-.19-1.64-.3-2.47-.32-.13,0-.26-.02-.39-.02-.89,0-1.78.13-2.66.35-.18.04-.36.1-.54.15-.88.26-1.76.59-2.58,1.07l-25.49,14.72c-9.84,5.68-22.06,5.68-31.9,0-9.84-5.68-15.96-16.27-15.96-27.63v-29.43c0-.95-.15-1.87-.37-2.76-.05-.19-.09-.37-.14-.56-.25-.86-.59-1.69-1.03-2.47-.07-.12-.15-.22-.22-.34-.43-.71-.94-1.37-1.51-1.97-.1-.1-.18-.21-.28-.31-.65-.63-1.37-1.18-2.15-1.66-.07-.04-.13-.11-.2-.16l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22l50.97,29.43c.08.04.17.06.25.1.8.44,1.63.79,2.5,1.03.14.04.29.06.43.09.8.19,1.61.3,2.43.32.1,0,.2.04.3.04.04,0,.09-.02.13-.02.88,0,1.77-.13,2.64-.34.19-.04.37-.1.56-.16.88-.26,1.75-.59,2.57-1.06l25.49-14.71c9.84-5.68,22.06-5.68,31.91,0,9.84,5.68,15.95,16.27,15.95,27.63v29.43c0,.95.15,1.87.37,2.76.05.19.09.37.14.56.25.86.59,1.69,1.03,2.47.07.12.15.22.22.34.43.71.94,1.37,1.51,1.97.1.1.18.21.28.31.65.63,1.37,1.18,2.15,1.66.07.04.13.11.2.16l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22Z"></path></svg>Index your code with Devin</button></div><div class="container-wrapper"><div class="container mx-auto flex w-full flex-row items-center gap-2 py-4 md:py-6"><a class="flex items-center gap-3" href="/"><span class="text-base font-medium leading-none md:text-lg hidden sm:block">DeepWiki</span></a><div class="flex-1"><div class="flex flex-row items-center gap-2"><a class="block text-xs font-medium leading-none text-white sm:hidden md:text-lg" href="/">DeepWiki</a><p class="text-sm font-normal leading-none md:text-lg"><a href="https://github.com/Nsomnia/chadvis-projectm-qt" target="_blank" rel="noopener noreferrer" title="Open repository" class="text-muted-foreground hover:text-muted-foreground/80 group inline-flex items-center gap-1 transition-colors">Nsomnia/chadvis-projectm-qt<!-- --> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 256 256" class="opacity-0 transition-opacity group-hover:opacity-100"><path d="M224,104a8,8,0,0,1-16,0V59.32l-66.33,66.34a8,8,0,0,1-11.32-11.32L196.68,48H152a8,8,0,0,1,0-16h64a8,8,0,0,1,8,8Zm-40,24a8,8,0,0,0-8,8v72H48V80h72a8,8,0,0,0,0-16H48A16,16,0,0,0,32,80V208a16,16,0,0,0,16,16H176a16,16,0,0,0,16-16V136A8,8,0,0,0,184,128Z"></path></svg></a></p></div></div><div class="flex items-center gap-4"><button class="group hidden items-center gap-1.5 md:flex"><div class="relative"><span class="text-foreground/70 group-hover:text-foreground text-xs font-light transition-colors">Index your code with</span><div class="bg-foreground/30 absolute bottom-0 left-0 h-[1px] w-0 transition-all duration-300 group-hover:w-full"></div></div><div class="flex items-center gap-1 transition-transform duration-300 group-hover:translate-x-0.5"><svg class="size-4 transform transition-transform duration-700 group-hover:rotate-180 [&amp;_path]:stroke-0" xmlns="http://www.w3.org/2000/svg" viewBox="110 110 460 500"><path style="fill:#21c19a" class="" d="M418.73,332.37c9.84-5.68,22.07-5.68,31.91,0l25.49,14.71c.82.48,1.69.8,2.58,1.06.19.06.37.11.55.16.87.21,1.76.34,2.65.35.04,0,.08.02.13.02.1,0,.19-.03.29-.04.83-.02,1.64-.13,2.45-.32.14-.03.28-.05.42-.09.87-.24,1.7-.59,2.5-1.03.08-.04.17-.06.25-.1l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-.08.04-.13.11-.2.16-.78.48-1.51,1.02-2.15,1.66-.1.1-.18.21-.28.31-.57.6-1.08,1.26-1.51,1.97-.07.12-.15.22-.22.34-.44.77-.77,1.6-1.03,2.47-.05.19-.1.37-.14.56-.22.89-.37,1.81-.37,2.76v29.43c0,11.36-6.11,21.95-15.95,27.63-9.84,5.68-22.06,5.68-31.91,0l-25.49-14.71c-.82-.48-1.69-.8-2.57-1.06-.19-.06-.37-.11-.56-.16-.88-.21-1.76-.34-2.65-.34-.13,0-.26.02-.4.02-.84.02-1.66.13-2.47.32-.13.03-.27.05-.4.09-.87.24-1.71.6-2.51,1.04-.08.04-.16.06-.24.1l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22l50.97,29.43c.08.04.17.06.24.1.8.44,1.64.79,2.5,1.03.14.04.28.06.42.09.81.19,1.62.3,2.45.32.1,0,.19.04.29.04.04,0,.08-.02.13-.02.89,0,1.77-.13,2.65-.35.19-.04.37-.1.56-.16.88-.26,1.75-.59,2.58-1.06l25.49-14.71c9.84-5.68,22.06-5.68,31.91,0,9.84,5.68,15.95,16.27,15.95,27.63v29.43c0,.95.15,1.87.37,2.76.05.19.09.37.14.56.25.86.59,1.69,1.03,2.47.07.12.15.22.22.34.43.71.94,1.37,1.51,1.97.1.1.18.21.28.31.65.63,1.37,1.18,2.15,1.66.07.04.13.11.2.16l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-.08-.04-.16-.06-.24-.1-.8-.44-1.64-.8-2.51-1.04-.13-.04-.26-.05-.39-.09-.82-.2-1.65-.31-2.49-.33-.13,0-.25-.02-.38-.02-.89,0-1.78.13-2.66.35-.18.04-.36.1-.54.15-.88.26-1.75.59-2.58,1.07l-25.49,14.72c-9.84,5.68-22.07,5.68-31.9,0-9.84-5.68-15.95-16.27-15.95-27.63s6.11-21.95,15.95-27.63Z"></path><path style="fill:#3969ca" d="M141.09,317.65l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c.08-.04.13-.11.2-.16.78-.48,1.51-1.02,2.15-1.66.1-.1.18-.21.28-.31.57-.6,1.08-1.26,1.51-1.97.07-.12.15-.22.22-.34.44-.77.77-1.6,1.03-2.47.05-.19.1-.37.14-.56.22-.89.37-1.81.37-2.76v-29.43c0-11.36,6.11-21.95,15.96-27.63s22.06-5.68,31.91,0l25.49,14.71c.82.48,1.69.8,2.57,1.06.19.06.37.11.56.16.87.21,1.76.34,2.64.35.04,0,.09.02.13.02.1,0,.19-.04.29-.04.83-.02,1.65-.13,2.45-.32.14-.03.28-.05.41-.09.87-.24,1.71-.6,2.51-1.04.08-.04.16-.06.24-.1l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-.08.04-.13.11-.2.16-.78.48-1.51,1.02-2.15,1.66-.1.1-.18.21-.28.31-.57.6-1.08,1.26-1.51,1.97-.07.12-.15.22-.22.34-.44.77-.77,1.6-1.03,2.47-.05.19-.1.37-.14.56-.22.89-.37,1.81-.37,2.76v29.43c0,11.36-6.11,21.95-15.95,27.63-9.84,5.68-22.07,5.68-31.91,0l-25.49-14.71c-.82-.48-1.69-.8-2.58-1.06-.19-.06-.37-.11-.55-.16-.88-.21-1.76-.34-2.65-.35-.13,0-.26.02-.4.02-.83.02-1.66.13-2.47.32-.13.03-.27.05-.4.09-.87.24-1.71.6-2.51,1.04-.08.04-.16.06-.24.1l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22Z"></path><path style="fill:#0294de" class="" d="M396.88,484.35l-50.97-29.43c-.08-.04-.17-.06-.24-.1-.8-.44-1.64-.79-2.51-1.03-.14-.04-.27-.06-.41-.09-.81-.19-1.64-.3-2.47-.32-.13,0-.26-.02-.39-.02-.89,0-1.78.13-2.66.35-.18.04-.36.1-.54.15-.88.26-1.76.59-2.58,1.07l-25.49,14.72c-9.84,5.68-22.06,5.68-31.9,0-9.84-5.68-15.96-16.27-15.96-27.63v-29.43c0-.95-.15-1.87-.37-2.76-.05-.19-.09-.37-.14-.56-.25-.86-.59-1.69-1.03-2.47-.07-.12-.15-.22-.22-.34-.43-.71-.94-1.37-1.51-1.97-.1-.1-.18-.21-.28-.31-.65-.63-1.37-1.18-2.15-1.66-.07-.04-.13-.11-.2-.16l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22l50.97,29.43c.08.04.17.06.25.1.8.44,1.63.79,2.5,1.03.14.04.29.06.43.09.8.19,1.61.3,2.43.32.1,0,.2.04.3.04.04,0,.09-.02.13-.02.88,0,1.77-.13,2.64-.34.19-.04.37-.1.56-.16.88-.26,1.75-.59,2.57-1.06l25.49-14.71c9.84-5.68,22.06-5.68,31.91,0,9.84,5.68,15.95,16.27,15.95,27.63v29.43c0,.95.15,1.87.37,2.76.05.19.09.37.14.56.25.86.59,1.69,1.03,2.47.07.12.15.22.22.34.43.71.94,1.37,1.51,1.97.1.1.18.21.28.31.65.63,1.37,1.18,2.15,1.66.07.04.13.11.2.16l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22Z"></path></svg><span class="text-sm font-medium">Devin</span></div></button><button aria-label="Edit Wiki" class="flex items-center rounded-md cursor-pointer transition-all border border-border bg-surface hover:border-border-hover hover:bg-component disabled:cursor-default disabled:opacity-50 disabled:hover:border-border disabled:hover:bg-surface gap-2 px-3 py-1.5 text-sm"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 256 256"><path d="M227.32,73.37,182.63,28.69a16,16,0,0,0-22.63,0L36.69,152A15.86,15.86,0,0,0,32,163.31V208a16,16,0,0,0,16,16H216a8,8,0,0,0,0-16H115.32l112-112A16,16,0,0,0,227.32,73.37ZM92.69,208H48V163.31l88-88L180.69,120ZM192,108.69,147.32,64l24-24L216,84.69Z"></path></svg>Edit Wiki</button><button class="flex items-center rounded-md !text-white cursor-pointer transition-all border bg-blue-500 hover:bg-blue-600 border-blue-500 hover:border-blue-600 dark:bg-blue-900 dark:hover:bg-blue-800 dark:border-blue-900 dark:hover:border-blue-800 disabled:cursor-default disabled:opacity-50 disabled:hover:bg-blue-500 disabled:hover:border-blue-500 dark:disabled:hover:bg-blue-900 dark:disabled:hover:border-blue-900 gap-1.5 px-3 py-1.5 text-sm" aria-label="Share" data-state="closed" data-slot="tooltip-trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg><span>Share</span></button><div class="h-8 w-8"></div></div></div></div></div><!--$?--><template id="B:1"></template><div class="container-wrapper flex flex-1 items-center justify-center px-4"><div class="inline-block bg-clip-text text-[#b5b5b5a4] animate-shine text-center text-lg" style="background-image:linear-gradient(120deg, rgba(255, 255, 255, 0) 40%, rgba(255, 255, 255, 0.8) 50%, rgba(255, 255, 255, 0) 60%);background-size:200% 100%;-webkit-background-clip:text;animation-duration:1s">Loading...</div></div><!--/$--></div></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script type="application/ld+json">{"@context":"https://schema.org","@type":"TechArticle","headline":"Overview","description":"This page provides a comprehensive introduction to chadvis-projectm-qt, covering its purpose, architecture, technology stack, and core systems. For detailed information on specific subsystems, refer t","image":"https://deepwiki.com/Nsomnia/chadvis-projectm-qt/og-image.png","datePublished":"2026-01-07T23:29:36.048832","dateModified":"2026-01-07T23:29:36.048832","author":{"@type":"Organization","name":"DeepWiki","url":"https://deepwiki.com"},"publisher":{"@type":"Organization","name":"DeepWiki","logo":{"@type":"ImageObject","url":"https://deepwiki.com/icon.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://deepwiki.com/Nsomnia/chadvis-projectm-qt"}}</script><div class="w-full flex-1"><div class="container-wrapper relative mx-auto h-full px-0"><div class="container relative mx-auto flex h-full w-full flex-col gap-0 max-md:!px-0 md:flex-row md:gap-6 lg:gap-10"><div class="border-r-border hidden max-h-screen border-r border-dashed py-6 pr-4 transition-[border-radius] md:sticky md:left-0 md:top-20 md:block md:h-[calc(100vh-82px)] md:w-64 md:flex-shrink-0 md:overflow-y-auto lg:py-9 xl:w-72"><div class="flex h-full w-full max-w-full flex-shrink-0 flex-col overflow-hidden" style="scrollbar-color:var(--color-border) transparent"><div class="flex-shrink-0 px-2"><div class="text-secondary pb-1 text-xs">Last indexed: <!-- -->7 January 2026<!-- --> (<a href="https://github.com/Nsomnia/chadvis-projectm-qt/commits/8320db27" target="_blank" rel="noopener noreferrer" class="underline-offset-2 hover:underline">8320db</a>)</div></div><ul class="flex-1 flex-shrink-0 space-y-1 overflow-y-auto py-1" style="scrollbar-width:none"><li style="padding-left:0"><a data-selected="true" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/1-overview">Overview</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/1.1-architecture-and-design-patterns">Architecture &amp; Design Patterns</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/1.2-building-and-running">Building &amp; Running</a></li><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/2-core-systems">Core Systems</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/2.1-application-and-config">Application &amp; Config</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/2.2-build-system-and-dependencies">Build System &amp; Dependencies</a></li><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/3-audio-system">Audio System</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/3.1-audioengine">AudioEngine</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/3.2-playlist-management">Playlist Management</a></li><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/4-visualization-system">Visualization System</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/4.1-visualizerwindow">VisualizerWindow</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/4.2-projectm-integration">ProjectM Integration</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/4.3-preset-management">Preset Management</a></li><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/5-recording-system">Recording System</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/5.1-videorecorder">VideoRecorder</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/5.2-frame-capture-and-pbos">Frame Capture &amp; PBOs</a></li><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/6-overlay-system">Overlay System</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/6.1-overlayengine-and-elements">OverlayEngine &amp; Elements</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/6.2-overlayrenderer">OverlayRenderer</a></li><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/7-user-interface">User Interface</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/7.1-mainwindow-and-layout">MainWindow &amp; Layout</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/7.2-controller-layer">Controller Layer</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/7.3-settings-dialog">Settings Dialog</a></li><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/8-suno-ai-integration">Suno AI Integration</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/8.1-sunoclient-and-api">SunoClient &amp; API</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="/Nsomnia/chadvis-projectm-qt/8.2-sunocontroller-and-ui">SunoController &amp; UI</a></li></ul></div></div><div class="flex h-full flex-1 flex-col overflow-hidden"><div class="bg-background border-b-border sticky top-0 z-10 border-b border-dashed md:hidden"><div class="flex cursor-pointer items-center gap-2 p-3"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 256 256" class="transition-transform"><path d="M184.49,136.49l-80,80a12,12,0,0,1-17-17L159,128,87.51,56.49a12,12,0,1,1,17-17l80,80A12,12,0,0,1,184.49,136.49Z"></path></svg><span class="truncate text-base font-normal">Menu</span></div></div><div class="relative flex-1 overflow-y-auto px-3 pt-3 md:rounded-md md:px-0 md:pt-0 [&amp;_::selection]:bg-purple-500/40" style="scrollbar-color:var(--color-night) transparent"><div class="pb-30 mx-auto max-w-2xl md:pb-40 md:pt-6 lg:pt-8"><div class="prose prose-invert dark:prose-invert prose-headings:text-inherit prose-p:text-inherit max-w-none"><div><div class="prose-custom prose-custom-md prose-custom-gray !max-w-none text-neutral-300 [overflow-wrap:anywhere]"><h1 id="overview" class="group" data-header="true">Overview<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h1>
<details>
<summary>Relevant source files</summary>
<ul>
<li><a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/AGENTS.md" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4] rounded-r"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AGENTS.md</span></a></li>
<li><a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/CMakeLists.txt" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4] rounded-r"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>CMakeLists.txt</span></a></li>
<li><a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/src/core/Config.hpp" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4] rounded-r"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>src/core/Config.hpp</span></a></li>
</ul>
</details>
<p>This page provides a comprehensive introduction to <strong>chadvis-projectm-qt</strong>, covering its purpose, architecture, technology stack, and core systems. For detailed information on specific subsystems, refer to the linked pages throughout this document.</p>
<hr/>
<h2 id="project-description" class="group" data-header="true">Project Description<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p><strong>chadvis-projectm-qt</strong> is a modern C++20/Qt6 audio visualizer application that integrates the projectM v4 library for real-time music visualization. The application combines audio playback, spectrum analysis, dynamic preset-based visualizations, text overlays, and high-quality video recording into a unified desktop experience.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>Audio Playback:</strong> Multi-format support (MP3, FLAC, WAV, etc.) via Qt Multimedia and FFmpeg decoding</li>
<li><strong>Real-Time Visualization:</strong> projectM v4-powered preset rendering with FFT-driven audio reactivity</li>
<li><strong>Video Recording:</strong> FFmpeg-based encoder capturing audio and video streams to MP4/MKV</li>
<li><strong>Text Overlays:</strong> Dynamic text elements with animations and beat-reactive effects</li>
<li><strong>AI Music Integration:</strong> Suno AI API client for generating, browsing, and playing AI-composed music</li>
<li><strong>Preset Management:</strong> Browsing, favorites, blacklisting, and history navigation for .milk presets</li>
<li><strong>Playlist System:</strong> M3U playlist support with shuffle, repeat, and session persistence</li>
</ul>
<p>For build instructions and dependency setup, see <a href="/Nsomnia/chadvis-projectm-qt/1.2-building-and-running" class="text-neutral-300 hover:text-neutral-200 hover:underline">Building &amp; Running</a>. For architecture patterns and design principles, see <a href="/Nsomnia/chadvis-projectm-qt/1.1-architecture-and-design-patterns" class="text-neutral-300 hover:text-neutral-200 hover:underline">Architecture &amp; Design Patterns</a>.</p>
<p><strong>Sources:</strong> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/CMakeLists.txt#L27-L28" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>CMakeLists.txt</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">27-28</span></a> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/AGENTS.md#L1-L4" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AGENTS.md</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">1-4</span></a> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/AGENTS.md#L79-L86" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AGENTS.md</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">79-86</span></a></p>
<hr/>
<h2 id="technology-stack" class="group" data-header="true">Technology Stack<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The application is built on modern C++ and Qt6, leveraging several mature libraries for multimedia processing:</p>




























































<table><thead><tr><th>Component</th><th>Technology</th><th>Purpose</th></tr></thead><tbody><tr><td><strong>Language</strong></td><td>C++20</td><td>Modern features (concepts, designated initializers, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">std::span</code>)</td></tr><tr><td><strong>UI Framework</strong></td><td>Qt6</td><td>Core, Gui, Widgets, Multimedia, OpenGLWidgets, Network, Sql</td></tr><tr><td><strong>Visualization</strong></td><td>projectM v4</td><td>Milkdrop preset rendering engine</td></tr><tr><td><strong>Audio Decoding</strong></td><td>Qt Multimedia + FFmpeg</td><td>Multi-format audio support and PCM extraction</td></tr><tr><td><strong>Video Encoding</strong></td><td>FFmpeg (libavcodec)</td><td>MP4/MKV encoding with configurable codecs</td></tr><tr><td><strong>Configuration</strong></td><td>toml++</td><td>TOML parsing for persistent settings</td></tr><tr><td><strong>Logging</strong></td><td>spdlog + fmt</td><td>Structured diagnostic output</td></tr><tr><td><strong>Metadata</strong></td><td>TagLib</td><td>Audio file tag extraction</td></tr><tr><td><strong>OpenGL</strong></td><td>GLEW + GLM</td><td>Graphics pipeline and math utilities</td></tr><tr><td><strong>Database</strong></td><td>Qt SQL (SQLite)</td><td>Suno library caching</td></tr></tbody></table>
<p><strong>Build System:</strong> CMake 3.20+ with Ninja generator. The project uses pkg-config for dependency discovery with fallback manual search paths for locally-built libraries (e.g., projectM v4).</p>
<p><strong>Sources:</strong> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/CMakeLists.txt#L59-L69" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>CMakeLists.txt</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">59-69</span></a> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/CMakeLists.txt#L73-L102" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>CMakeLists.txt</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">73-102</span></a> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/AGENTS.md#L34-L35" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AGENTS.md</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">34-35</span></a></p>
<hr/>
<h2 id="system-architecture" class="group" data-header="true">System Architecture<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The application follows a <strong>Singleton-Engine-Controller</strong> pattern where the <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Application</code> singleton owns all engines (audio, recording, overlay), and UI controllers mediate between widgets and engines using non-owning pointers.</p>
<h3 id="high-level-component-architecture" class="group" data-header="true">High-Level Component Architecture<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h3>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></pre>
<p><strong>Key Architectural Principles:</strong></p>
<ol>
<li><strong>Ownership:</strong> <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Application</code> owns all engines as <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">std::unique_ptr</code> members. UI controllers hold raw non-owning pointers.</li>
<li><strong>Configuration:</strong> The <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">CONFIG</code> macro provides global access to the <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Config</code> singleton, which loads/saves TOML configuration.</li>
<li><strong>Threading:</strong> Audio decoding and video encoding run in dedicated threads. Visualization rendering uses Qt&#x27;s event loop.</li>
<li><strong>Signal Routing:</strong> Controllers implement <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">connectSignals()</code> methods to wire UI widget signals to engine slots, avoiding direct coupling.</li>
</ol>
<p><strong>Sources:</strong> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/CMakeLists.txt#L119-L227" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>CMakeLists.txt</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">119-227</span></a> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/src/core/Config.hpp#L109-L231" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>src/core/Config.hpp</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">109-231</span></a> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/AGENTS.md#L79-L86" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AGENTS.md</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">79-86</span></a></p>
<hr/>
<h2 id="core-data-flow-pipeline" class="group" data-header="true">Core Data Flow Pipeline<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The following diagram illustrates the complete data flow from audio input through visualization to final output (display and optional recording):</p>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></pre>
<p><strong>Pipeline Stages:</strong></p>
<ol>
<li><strong>Audio Input:</strong> Files decoded by <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">FFmpegAudioSource</code> or <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">QMediaPlayer</code>  PCM float samples</li>
<li><strong>Analysis:</strong> <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">AudioAnalyzer::analyze()</code> computes FFT  <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">AudioSpectrum</code> (frequency bins)</li>
<li><strong>Visualization:</strong> <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">ProjectMBridge::renderFrame()</code> feeds spectrum to projectM  renders to FBO</li>
<li><strong>Capture:</strong> <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">RenderTarget</code> uses double-buffered PBOs for zero-copy async frame readback</li>
<li><strong>Overlay:</strong> <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">OverlayEngine</code> manages text elements, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">OverlayRenderer</code> draws them with OpenGL</li>
<li><strong>Output:</strong> Final frame goes to display; if recording, frames queue to <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">VideoRecorder</code> encoder thread</li>
<li><strong>Encoding:</strong> <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">VideoRecorder</code> muxes video frames + audio PCM  MP4/MKV via FFmpeg</li>
</ol>
<p><strong>Sources:</strong> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/CMakeLists.txt#L128-L139" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>CMakeLists.txt</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">128-139</span></a> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/CMakeLists.txt#L141-L152" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>CMakeLists.txt</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">141-152</span></a> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/CMakeLists.txt#L175-L182" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>CMakeLists.txt</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">175-182</span></a></p>
<hr/>
<h2 id="module-organization" class="group" data-header="true">Module Organization<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The codebase is organized into logical subsystems, each with dedicated source files. The <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">CMakeLists.txt</code> defines module groupings for clarity:</p>


















































<table><thead><tr><th>Module</th><th>Files</th><th>Responsibilities</th></tr></thead><tbody><tr><td><strong>Util</strong></td><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Types.hpp</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Result.hpp</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Signal.hpp</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">FileUtils.*</code></td><td>Type aliases, error handling, lightweight signals, file operations</td></tr><tr><td><strong>Core</strong></td><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Logger.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Config.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Application.*</code></td><td>Logging, TOML configuration, singleton entry point</td></tr><tr><td><strong>Audio</strong></td><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">AudioEngine.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">AudioAnalyzer.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Playlist.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">MediaMetadata.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">FFmpegAudioSource.*</code></td><td>Playback, spectrum analysis, playlist management, metadata extraction, FFmpeg decoding</td></tr><tr><td><strong>Visualizer</strong></td><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">ProjectMBridge.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">PresetManager.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">RatingManager.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">RenderTarget.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">VisualizerWindow.*</code></td><td>projectM wrapper, preset scanning/navigation, favorites/blacklist, FBO management, OpenGL window</td></tr><tr><td><strong>Suno</strong></td><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">SunoModels.hpp</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">SunoClient.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">SunoDatabase.*</code></td><td>API models, HTTP client, SQLite persistence</td></tr><tr><td><strong>Overlay</strong></td><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">TextElement.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">TextAnimator.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">OverlayConfig.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">OverlayEngine.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">OverlayRenderer.*</code></td><td>Text element definitions, animation logic, configuration, engine orchestration, OpenGL rendering</td></tr><tr><td><strong>Recorder</strong></td><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">EncoderSettings.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">FrameGrabber.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">VideoRecorder.*</code></td><td>Codec configuration, async frame queue, FFmpeg encoding thread</td></tr><tr><td><strong>UI</strong></td><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">controllers/*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">MarqueeLabel.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">PlayerControls.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">PlaylistView.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">VisualizerPanel.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">OverlayEditor.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">SunoBrowser.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">SunoCookieDialog.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">PresetBrowser.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">RecordingControls.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">SettingsDialog.*</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">MainWindow.*</code></td><td>Signal routing controllers, custom widgets, main window</td></tr></tbody></table>
<p><strong>Headers Included in CMake:</strong> The build system explicitly lists all headers to ensure <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">AUTOMOC</code> processes Qt <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Q_OBJECT</code> declarations correctly.</p>
<p><strong>Sources:</strong> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/CMakeLists.txt#L110-L227" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>CMakeLists.txt</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">110-227</span></a></p>
<hr/>
<h2 id="application-entry-point" class="group" data-header="true">Application Entry Point<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The application lifecycle begins in <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">src/main.cpp</code>, which instantiates the <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Application</code> singleton and initializes all subsystems:</p>
<h3 id="initialization-sequence" class="group" data-header="true">Initialization Sequence<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h3>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></pre>
<p><strong>Startup Flow:</strong></p>
<ol>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">main()</code> creates <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">QApplication</code> and calls <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Application::init()</code></li>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Application::init()</code> loads configuration from <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">~/.config/chadvis-projectm-qt/config.toml</code> via <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">CONFIG.load()</code></li>
<li>Logger initializes with settings from <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">CONFIG.debug()</code></li>
<li>Engines are created: <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">audioEngine_</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">videoRecorder_</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">overlayEngine_</code></li>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">MainWindow</code> is constructed, which creates controllers and UI widgets</li>
<li>Controllers call <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">setupUI()</code> to configure widgets and <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">connectSignals()</code> to wire events</li>
<li>Event loop starts with <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">app.exec()</code></li>
</ol>
<p>The <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Application</code> singleton provides global access to engines via <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Application::instance()</code> methods. Controllers obtain non-owning pointers during construction.</p>
<p><strong>Sources:</strong> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/CMakeLists.txt#L218-L218" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>CMakeLists.txt</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">218</span></a> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/AGENTS.md#L79-L86" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AGENTS.md</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">79-86</span></a></p>
<hr/>
<h2 id="configuration-system" class="group" data-header="true">Configuration System<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>Configuration uses a <strong>singleton pattern with TOML persistence</strong>. The <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Config</code> class provides thread-safe access via the <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">CONFIG</code> macro and implements dirty tracking for optimized saves.</p>
<h3 id="configuration-structure" class="group" data-header="true">Configuration Structure<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h3>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></pre>
<p><strong>Usage Pattern:</strong></p>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><div class="rounded-sm border border-[#8F8F8F]/30 p-2 text-xs font-normal leading-[15px]" style="background-color:transparent;min-height:2em"></div></pre>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>Global Access:</strong> The <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">CONFIG</code> macro expands to <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">vc::Config::instance()</code></li>
<li><strong>Dirty Tracking:</strong> Mutable accessors call <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">markDirty()</code> to trigger auto-save checks</li>
<li><strong>Thread Safety:</strong> Internal <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">std::mutex</code> protects concurrent access</li>
<li><strong>Nested Structures:</strong> <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">RecordingConfig</code> contains <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">VideoEncoderConfig</code> and <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">AudioEncoderConfig</code>, mirroring UI organization</li>
<li><strong>Typed Accessors:</strong> Const and non-const overloads for section structs</li>
</ul>
<p><strong>Sources:</strong> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/src/core/Config.hpp#L1-L236" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>src/core/Config.hpp</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">1-236</span></a> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/AGENTS.md#L79-L86" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AGENTS.md</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">79-86</span></a></p>
<hr/>
<h2 id="threading-architecture" class="group" data-header="true">Threading Architecture<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The application uses a <strong>hybrid threading model</strong> to balance responsiveness and performance:</p>



































<table><thead><tr><th>Thread</th><th>Purpose</th><th>Components</th></tr></thead><tbody><tr><td><strong>Main (Qt Event Loop)</strong></td><td>UI updates, user input, OpenGL rendering</td><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">MainWindow</code>, <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">VisualizerWindow</code>, controllers, widgets</td></tr><tr><td><strong>Audio Decode Thread</strong></td><td>FFmpeg decoding (if used)</td><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">FFmpegAudioSource</code> worker</td></tr><tr><td><strong>Qt Multimedia Thread</strong></td><td>Native audio decoding</td><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">QMediaPlayer</code> / <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">QAudioBufferOutput</code></td></tr><tr><td><strong>Video Encode Thread</strong></td><td>FFmpeg muxing and encoding</td><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">VideoRecorder::encodeLoop()</code></td></tr><tr><td><strong>Frame Capture (async)</strong></td><td>PBO readback via <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">glFenceSync</code></td><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">FrameGrabber::captureFrame()</code></td></tr></tbody></table>
<p><strong>Synchronization Mechanisms:</strong></p>
<ul>
<li><strong>Spectrum Data:</strong> <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">AudioAnalyzer</code> computes FFT on audio thread, emits <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">spectrumUpdated()</code> signal to update <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">ProjectMBridge</code> on main thread</li>
<li><strong>Frame Queue:</strong> <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">FrameGrabber</code> enqueues frames; <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">VideoRecorder</code> dequeues on encode thread with <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">std::condition_variable</code></li>
<li><strong>Config Access:</strong> <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">std::mutex</code> guards <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Config</code> singleton reads/writes</li>
<li><strong>Signal/Slot:</strong> Qt&#x27;s queued connections handle cross-thread communication</li>
</ul>
<p><strong>Performance Considerations:</strong></p>
<ul>
<li><strong>Zero-Copy Capture:</strong> PBOs enable GPU-side frame readback without blocking the render loop</li>
<li><strong>Pre-allocated Buffers:</strong> <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">AudioAnalyzer</code> maintains a <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">scratchBuffer_</code> to avoid allocations in hot paths</li>
<li><strong>Lock-Free Where Possible:</strong> <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Signal&lt;T&gt;</code> template uses <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">std::function</code> vector with minimal locking</li>
</ul>
<p><strong>Sources:</strong> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/AGENTS.md#L90-L95" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AGENTS.md</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">90-95</span></a> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/CMakeLists.txt#L175-L182" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>CMakeLists.txt</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">175-182</span></a></p>
<hr/>
<h2 id="error-handling-strategy" class="group" data-header="true">Error Handling Strategy<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The project uses <strong>no exceptions</strong>; all fallible operations return <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">vc::Result&lt;T&gt;</code>, a lightweight error monad:</p>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><div class="rounded-sm border border-[#8F8F8F]/30 p-2 text-xs font-normal leading-[15px]" style="background-color:transparent;min-height:2em"></div></pre>
<p><strong>Macros for Propagation:</strong></p>
<ul>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">TRY(result)</code>: Early return if <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">result.isErr()</code></li>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">TRY_VOID(result)</code>: Early return for <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Result&lt;void&gt;</code></li>
</ul>
<p><strong>Example Usage:</strong></p>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><div class="rounded-sm border border-[#8F8F8F]/30 p-2 text-xs font-normal leading-[15px]" style="background-color:transparent;min-height:2em"></div></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Forces explicit error handling at call sites</li>
<li>No hidden control flow (unlike exceptions)</li>
<li>Compile-time enforcement via <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">[[nodiscard]]</code></li>
</ul>
<p><strong>Sources:</strong> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/AGENTS.md#L54-L65" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AGENTS.md</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">54-65</span></a> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/AGENTS.md#L100-L103" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AGENTS.md</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">100-103</span></a></p>
<hr/>
<h2 id="summary" class="group" data-header="true">Summary<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p><strong>chadvis-projectm-qt</strong> is a comprehensive audio visualization platform built on modern C++ and Qt6 principles. Its architecture separates concerns into well-defined modules (audio, visualization, recording, overlay, UI, Suno integration), connected by a singleton-engine-controller pattern. Data flows from audio input through spectrum analysis and projectM rendering to display and optional recording, with all configuration managed via a centralized TOML-based system.</p>
<p>For deeper exploration:</p>
<ul>
<li><strong>Architecture details:</strong> See <a href="/Nsomnia/chadvis-projectm-qt/1.1-architecture-and-design-patterns" class="text-neutral-300 hover:text-neutral-200 hover:underline">Architecture &amp; Design Patterns</a></li>
<li><strong>Build instructions:</strong> See <a href="/Nsomnia/chadvis-projectm-qt/1.2-building-and-running" class="text-neutral-300 hover:text-neutral-200 hover:underline">Building &amp; Running</a></li>
<li><strong>Audio system:</strong> See <a href="/Nsomnia/chadvis-projectm-qt/3-audio-system" class="text-neutral-300 hover:text-neutral-200 hover:underline">Audio System</a></li>
<li><strong>Visualization:</strong> See <a href="/Nsomnia/chadvis-projectm-qt/4-visualization-system" class="text-neutral-300 hover:text-neutral-200 hover:underline">Visualization System</a></li>
<li><strong>Recording:</strong> See <a href="/Nsomnia/chadvis-projectm-qt/5-recording-system" class="text-neutral-300 hover:text-neutral-200 hover:underline">Recording System</a></li>
<li><strong>UI implementation:</strong> See <a href="/Nsomnia/chadvis-projectm-qt/7-user-interface" class="text-neutral-300 hover:text-neutral-200 hover:underline">User Interface</a></li>
<li><strong>Suno integration:</strong> See <a href="/Nsomnia/chadvis-projectm-qt/8-suno-ai-integration" class="text-neutral-300 hover:text-neutral-200 hover:underline">Suno AI Integration</a></li>
</ul>
<p><strong>Sources:</strong> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/CMakeLists.txt#L1-L282" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>CMakeLists.txt</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">1-282</span></a> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/src/core/Config.hpp#L1-L236" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>src/core/Config.hpp</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">1-236</span></a> <a href="https://github.com/Nsomnia/chadvis-projectm-qt/blob/8320db27/AGENTS.md#L1-L113" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AGENTS.md</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">1-113</span></a></p></div></div></div></div></div></div><div class="hidden overflow-hidden transition-[border-radius] xl:sticky xl:right-0 xl:top-20 xl:block xl:h-[calc(100vh-82px)] xl:w-64 xl:flex-shrink-0 2xl:w-72" style="scrollbar-width:none"><div class="flex max-h-full w-full flex-shrink-0 flex-col py-6 pt-0 text-sm lg:pb-4 lg:pt-8 xl:w-64 2xl:w-72" style="scrollbar-color:var(--color-night) transparent"><div><div class="relative mx-4 my-4 rounded-md border border-neutral-200 bg-neutral-100 p-3 text-sm text-neutral-600 dark:border-neutral-800 dark:bg-neutral-900 dark:text-neutral-400"><button class="absolute right-2 top-2 rounded-sm p-1 opacity-70 transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-neutral-400 focus:ring-offset-2"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M205.66,194.34a8,8,0,0,1-11.32,11.32L128,139.31,61.66,205.66a8,8,0,0,1-11.32-11.32L116.69,128,50.34,61.66A8,8,0,0,1,61.66,50.34L128,116.69l66.34-66.35a8,8,0,0,1,11.32,11.32L139.31,128Z"></path></svg><span class="sr-only">Dismiss</span></button><p class="text-sm font-medium">Refresh this wiki</p><p class="mt-2 text-sm font-light text-neutral-500 dark:text-neutral-400">This wiki was recently refreshed. Please wait<!-- --> <!-- -->6<!-- --> day<!-- -->s<!-- --> to refresh again.</p></div></div><h3 class="px-4 pb-5 text-lg font-medium leading-none">On this page</h3><ul style="scrollbar-width:none" class="min-h-0 flex-1 space-y-3 overflow-y-auto p-4 pt-0"><li class=""><a href="#overview" class="hover:text-primary pr-1 transition-all text-primary font-medium">Overview</a></li><li class="ml-3"><a href="#project-description" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Project Description</a></li><li class="ml-3"><a href="#technology-stack" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Technology Stack</a></li><li class="ml-3"><a href="#system-architecture" class="hover:text-primary pr-1 font-normal transition-all text-secondary">System Architecture</a></li><li class="ml-6"><a href="#high-level-component-architecture" class="hover:text-primary pr-1 font-normal transition-all text-secondary">High-Level Component Architecture</a></li><li class="ml-3"><a href="#core-data-flow-pipeline" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Core Data Flow Pipeline</a></li><li class="ml-3"><a href="#module-organization" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Module Organization</a></li><li class="ml-3"><a href="#application-entry-point" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Application Entry Point</a></li><li class="ml-6"><a href="#initialization-sequence" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Initialization Sequence</a></li><li class="ml-3"><a href="#configuration-system" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Configuration System</a></li><li class="ml-6"><a href="#configuration-structure" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Configuration Structure</a></li><li class="ml-3"><a href="#threading-architecture" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Threading Architecture</a></li><li class="ml-3"><a href="#error-handling-strategy" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Error Handling Strategy</a></li><li class="ml-3"><a href="#summary" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Summary</a></li></ul></div></div><div class="pointer-events-none fixed bottom-2 left-2 right-2 mt-2 md:bottom-4 md:left-0 md:right-0"><div class="z-10 mx-auto max-w-3xl"><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></div></div></div></div></div><!--$--><!--/$--></div><script>$RC("B:1","S:1")</script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n"])</script><script>self.__next_f.push([1,"2:I[49138,[\"9453\",\"static/chunks/b1298b8d-5cac6cd7c8e952ff.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"8970\",\"static/chunks/378e5a93-860e027c5a5e0c0d.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"1585\",\"static/chunks/f7f68e2d-d8bf979db5ff4e9d.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"7963\",\"static/chunks/7963-b29c27a8b53c3f2a.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"1265\",\"static/chunks/1265-fa8a95d3842768f5.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"9885\",\"static/chunks/9885-b57089f03806c3b8.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"659\",\"static/chunks/659-ee9e1e775e30dcef.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"7177\",\"static/chunks/app/layout-0537c2076823e553.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\"],\"RootProvider\"]\n"])</script><script>self.__next_f.push([1,"3:I[85341,[],\"\"]\n4:I[90025,[],\"\"]\n7:I[41012,[],\"ClientPageRoot\"]\n"])</script><script>self.__next_f.push([1,"8:I[57456,[\"9453\",\"static/chunks/b1298b8d-5cac6cd7c8e952ff.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"8970\",\"static/chunks/378e5a93-860e027c5a5e0c0d.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"1585\",\"static/chunks/f7f68e2d-d8bf979db5ff4e9d.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"4129\",\"static/chunks/7bf36345-1ac10ec2f0e0c88f.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"2545\",\"static/chunks/c16f53c3-b390b6f98a69dcec.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"7963\",\"static/chunks/7963-b29c27a8b53c3f2a.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"1265\",\"static/chunks/1265-fa8a95d3842768f5.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"6212\",\"static/chunks/6212-505c2fc95d1a35ae.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"9885\",\"static/chunks/9885-b57089f03806c3b8.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"4336\",\"static/chunks/4336-624d5ae6f4cc1cc7.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"659\",\"static/chunks/659-ee9e1e775e30dcef.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"8461\",\"static/chunks/8461-369a9f0c48ea2626.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"7198\",\"static/chunks/7198-985a49f2b6072d25.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"5462\",\"static/chunks/5462-08221e91030fd747.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"4429\",\"static/chunks/4429-943205658cbafffe.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"9976\",\"static/chunks/9976-9250854d58eefaa3.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"1481\",\"static/chunks/1481-25d5bbc4f2d9524a.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"3285\",\"static/chunks/app/%5Borg%5D/%5Brepo%5D/%5B%5B...wikiRoutes%5D%5D/page-6651f8cd8321a0db.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\"],\"default\"]\n"])</script><script>self.__next_f.push([1,"b:I[15104,[],\"OutletBoundary\"]\nd:I[94777,[],\"AsyncMetadataOutlet\"]\nf:I[15104,[],\"ViewportBoundary\"]\n11:I[15104,[],\"MetadataBoundary\"]\n12:\"$Sreact.suspense\"\n14:I[34431,[],\"\"]\n:HL[\"/_next/static/media/4cf2300e9c8272f7-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/de70bee13400563f.css?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"style\"]\n:HL[\"/_next/static/css/3e435f9a1dbb5b5b.css?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"rqSTl2a1shw6mc4_h6GoU\",\"p\":\"\",\"c\":[\"\",\"Nsomnia\",\"chadvis-projectm-qt\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[[\"org\",\"Nsomnia\",\"d\"],{\"children\":[[\"repo\",\"chadvis-projectm-qt\",\"d\"],{\"children\":[[\"wikiRoutes\",\"\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/de70bee13400563f.css?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/3e435f9a1dbb5b5b.css?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"suppressHydrationWarning\":true,\"children\":[[\"$\",\"head\",null,{}],[\"$\",\"body\",null,{\"className\":\"__variable_188709 font-geist-sans relative min-h-screen __variable_9a8899 bg-background antialiased\",\"children\":[\"$\",\"$L2\",null,{\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}]]}],{\"children\":[[\"org\",\"Nsomnia\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"repo\",\"chadvis-projectm-qt\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,\"$L5\"]}],{\"children\":[[\"wikiRoutes\",\"\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,\"$L6\"]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[[\"$\",\"$L7\",null,{\"Component\":\"$8\",\"searchParams\":{},\"params\":{\"org\":\"Nsomnia\",\"repo\":\"chadvis-projectm-qt\"},\"promises\":[\"$@9\",\"$@a\"]}],null,[\"$\",\"$Lb\",null,{\"children\":[\"$Lc\",[\"$\",\"$Ld\",null,{\"promise\":\"$@e\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[[\"$\",\"$Lf\",null,{\"children\":\"$L10\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]],[\"$\",\"$L11\",null,{\"children\":[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$12\",null,{\"fallback\":null,\"children\":\"$L13\"}]}]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$14\",[]],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"9:{}\na:\"$0:f:0:1:2:children:2:children:2:children:2:children:1:props:children:0:props:params\"\n"])</script><script>self.__next_f.push([1,"10:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nc:null\n"])</script><script>self.__next_f.push([1,"15:I[13550,[\"9453\",\"static/chunks/b1298b8d-5cac6cd7c8e952ff.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"8970\",\"static/chunks/378e5a93-860e027c5a5e0c0d.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"1585\",\"static/chunks/f7f68e2d-d8bf979db5ff4e9d.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"7963\",\"static/chunks/7963-b29c27a8b53c3f2a.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"1265\",\"static/chunks/1265-fa8a95d3842768f5.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"6212\",\"static/chunks/6212-505c2fc95d1a35ae.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"4336\",\"static/chunks/4336-624d5ae6f4cc1cc7.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"25\",\"static/chunks/25-9f305b682cea7558.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"7391\",\"static/chunks/7391-3ba9e11c5966ae03.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"6373\",\"static/chunks/6373-d56a493968555802.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"6375\",\"static/chunks/6375-7e0e75eb09fc9abe.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"9437\",\"static/chunks/9437-be873d1907eef4d4.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"2933\",\"static/chunks/app/%5Borg%5D/%5Brepo%5D/layout-77683f6369c5b39e.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\"],\"HeaderWrapperWithSuspense\"]\n"])</script><script>self.__next_f.push([1,"16:I[82188,[\"9453\",\"static/chunks/b1298b8d-5cac6cd7c8e952ff.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"8970\",\"static/chunks/378e5a93-860e027c5a5e0c0d.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"1585\",\"static/chunks/f7f68e2d-d8bf979db5ff4e9d.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"7963\",\"static/chunks/7963-b29c27a8b53c3f2a.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"1265\",\"static/chunks/1265-fa8a95d3842768f5.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"6212\",\"static/chunks/6212-505c2fc95d1a35ae.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"4336\",\"static/chunks/4336-624d5ae6f4cc1cc7.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"25\",\"static/chunks/25-9f305b682cea7558.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"7391\",\"static/chunks/7391-3ba9e11c5966ae03.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"6373\",\"static/chunks/6373-d56a493968555802.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"6375\",\"static/chunks/6375-7e0e75eb09fc9abe.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"9437\",\"static/chunks/9437-be873d1907eef4d4.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\",\"2933\",\"static/chunks/app/%5Borg%5D/%5Brepo%5D/layout-77683f6369c5b39e.js?dpl=dpl_nRufFRnhcpRXDKZpt4xTDzWSabGS\"],\"WikiContextProvider\"]\n"])</script><script>self.__next_f.push([1,"17:T468e,"])</script><script>self.__next_f.push([1,"# Overview\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AGENTS.md](AGENTS.md)\n- [CMakeLists.txt](CMakeLists.txt)\n- [src/core/Config.hpp](src/core/Config.hpp)\n\n\u003c/details\u003e\n\n\n\nThis page provides a comprehensive introduction to **chadvis-projectm-qt**, covering its purpose, architecture, technology stack, and core systems. For detailed information on specific subsystems, refer to the linked pages throughout this document.\n\n---\n\n## Project Description\n\n**chadvis-projectm-qt** is a modern C++20/Qt6 audio visualizer application that integrates the projectM v4 library for real-time music visualization. The application combines audio playback, spectrum analysis, dynamic preset-based visualizations, text overlays, and high-quality video recording into a unified desktop experience.\n\n**Key Features:**\n- **Audio Playback:** Multi-format support (MP3, FLAC, WAV, etc.) via Qt Multimedia and FFmpeg decoding\n- **Real-Time Visualization:** projectM v4-powered preset rendering with FFT-driven audio reactivity\n- **Video Recording:** FFmpeg-based encoder capturing audio and video streams to MP4/MKV\n- **Text Overlays:** Dynamic text elements with animations and beat-reactive effects\n- **AI Music Integration:** Suno AI API client for generating, browsing, and playing AI-composed music\n- **Preset Management:** Browsing, favorites, blacklisting, and history navigation for .milk presets\n- **Playlist System:** M3U playlist support with shuffle, repeat, and session persistence\n\nFor build instructions and dependency setup, see [Building \u0026 Running](#1.2). For architecture patterns and design principles, see [Architecture \u0026 Design Patterns](#1.1).\n\n**Sources:** [CMakeLists.txt:27-28](), [AGENTS.md:1-4](), [AGENTS.md:79-86]()\n\n---\n\n## Technology Stack\n\nThe application is built on modern C++ and Qt6, leveraging several mature libraries for multimedia processing:\n\n| Component | Technology | Purpose |\n|-----------|-----------|---------|\n| **Language** | C++20 | Modern features (concepts, designated initializers, `std::span`) |\n| **UI Framework** | Qt6 | Core, Gui, Widgets, Multimedia, OpenGLWidgets, Network, Sql |\n| **Visualization** | projectM v4 | Milkdrop preset rendering engine |\n| **Audio Decoding** | Qt Multimedia + FFmpeg | Multi-format audio support and PCM extraction |\n| **Video Encoding** | FFmpeg (libavcodec) | MP4/MKV encoding with configurable codecs |\n| **Configuration** | toml++  | TOML parsing for persistent settings |\n| **Logging** | spdlog + fmt | Structured diagnostic output |\n| **Metadata** | TagLib | Audio file tag extraction |\n| **OpenGL** | GLEW + GLM | Graphics pipeline and math utilities |\n| **Database** | Qt SQL (SQLite) | Suno library caching |\n\n**Build System:** CMake 3.20+ with Ninja generator. The project uses pkg-config for dependency discovery with fallback manual search paths for locally-built libraries (e.g., projectM v4).\n\n**Sources:** [CMakeLists.txt:59-69](), [CMakeLists.txt:73-102](), [AGENTS.md:34-35]()\n\n---\n\n## System Architecture\n\nThe application follows a **Singleton-Engine-Controller** pattern where the `Application` singleton owns all engines (audio, recording, overlay), and UI controllers mediate between widgets and engines using non-owning pointers.\n\n### High-Level Component Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Core Layer\"\n        App[\"Application\u003cbr/\u003e(Singleton)\"]\n        Cfg[\"Config\u003cbr/\u003e(Singleton, CONFIG macro)\"]\n        Log[\"Logger\u003cbr/\u003e(spdlog wrapper)\"]\n    end\n    \n    subgraph \"Engine Layer - Owned by Application\"\n        AE[\"AudioEngine\"]\n        VR[\"VideoRecorder\"]\n        OE[\"OverlayEngine\"]\n    end\n    \n    subgraph \"Visualization Layer\"\n        VW[\"VisualizerWindow\u003cbr/\u003e(QWindow + OpenGL)\"]\n        PMB[\"ProjectMBridge\u003cbr/\u003e(projectM v4 wrapper)\"]\n        PM[\"PresetManager\"]\n    end\n    \n    subgraph \"UI Layer - Qt MainWindow\"\n        MW[\"MainWindow\u003cbr/\u003e(QMainWindow)\"]\n        AC[\"AudioController\"]\n        RC[\"RecordingController\"]\n        VC[\"VisualizerController\"]\n        SC[\"SunoController\"]\n        Widgets[\"PlayerControls\u003cbr/\u003ePlaylistView\u003cbr/\u003ePresetBrowser\u003cbr/\u003eRecordingControls\u003cbr/\u003eSunoBrowser\"]\n    end\n    \n    subgraph \"Audio Processing\"\n        AA[\"AudioAnalyzer\u003cbr/\u003e(FFT spectrum)\"]\n        PL[\"Playlist\u003cbr/\u003e(M3U support)\"]\n        FFmpegSrc[\"FFmpegAudioSource\"]\n    end\n    \n    subgraph \"Suno Integration\"\n        SClient[\"SunoClient\u003cbr/\u003e(API wrapper)\"]\n        SDB[\"SunoDatabase\u003cbr/\u003e(SQLite)\"]\n    end\n    \n    subgraph \"Recording Pipeline\"\n        FG[\"FrameGrabber\u003cbr/\u003e(async PBO queue)\"]\n        RT[\"RenderTarget\u003cbr/\u003e(FBO management)\"]\n    end\n    \n    App --\u003e|owns| AE\n    App --\u003e|owns| VR\n    App --\u003e|owns| OE\n    App --\u003e|reads| Cfg\n    App --\u003e|writes to| Log\n    \n    AE --\u003e|contains| AA\n    AE --\u003e|contains| PL\n    AE --\u003e|may use| FFmpegSrc\n    \n    VW --\u003e|owns| PMB\n    PMB --\u003e|uses| PM\n    VW --\u003e|renders to| RT\n    \n    VR --\u003e|uses| FG\n    \n    MW --\u003e|owns| AC\n    MW --\u003e|owns| RC\n    MW --\u003e|owns| VC\n    MW --\u003e|owns| SC\n    \n    AC -.-\u003e|non-owning ptr| AE\n    RC -.-\u003e|non-owning ptr| VR\n    VC -.-\u003e|non-owning ptr| PMB\n    SC -.-\u003e|non-owning ptr| AE\n    SC -.-\u003e|non-owning ptr| OE\n    \n    AC --\u003e|configures| Widgets\n    RC --\u003e|configures| Widgets\n    VC --\u003e|configures| Widgets\n    SC --\u003e|configures| Widgets\n    \n    SC --\u003e|owns| SClient\n    SC --\u003e|owns| SDB\n    \n    AA -.-\u003e|\"spectrum data\"| PMB\n    FG -.-\u003e|\"frame queue\"| VR\n    AE -.-\u003e|\"PCM data\"| VR\n```\n\n**Key Architectural Principles:**\n\n1. **Ownership:** `Application` owns all engines as `std::unique_ptr` members. UI controllers hold raw non-owning pointers.\n2. **Configuration:** The `CONFIG` macro provides global access to the `Config` singleton, which loads/saves TOML configuration.\n3. **Threading:** Audio decoding and video encoding run in dedicated threads. Visualization rendering uses Qt's event loop.\n4. **Signal Routing:** Controllers implement `connectSignals()` methods to wire UI widget signals to engine slots, avoiding direct coupling.\n\n**Sources:** [CMakeLists.txt:119-227](), [src/core/Config.hpp:109-231](), [AGENTS.md:79-86]()\n\n---\n\n## Core Data Flow Pipeline\n\nThe following diagram illustrates the complete data flow from audio input through visualization to final output (display and optional recording):\n\n```mermaid\nflowchart LR\n    subgraph Input[\"Input Sources\"]\n        Files[\"Audio Files\u003cbr/\u003e(MP3/FLAC/WAV)\"]\n        Suno[\"Suno API\u003cbr/\u003e(Generated Music)\"]\n    end\n    \n    subgraph AudioProcessing[\"Audio Processing\"]\n        AE[\"AudioEngine\"]\n        FFSrc[\"FFmpegAudioSource\u003cbr/\u003e(decode to PCM)\"]\n        QBuf[\"QAudioBufferOutput\u003cbr/\u003e(Qt Multimedia)\"]\n        AA[\"AudioAnalyzer\u003cbr/\u003e(FFT  spectrum)\"]\n    end\n    \n    subgraph Visualization[\"Visualization Pipeline\"]\n        PMB[\"ProjectMBridge\u003cbr/\u003e(projectM_renderFrame)\"]\n        VW[\"VisualizerWindow\u003cbr/\u003e(OpenGL context)\"]\n        FBO[\"RenderTarget\u003cbr/\u003e(Framebuffer Object)\"]\n        PBO[\"PBO double-buffer\u003cbr/\u003e(async readback)\"]\n    end\n    \n    subgraph OverlayComp[\"Overlay Composition\"]\n        OE[\"OverlayEngine\u003cbr/\u003e(element management)\"]\n        OR[\"OverlayRenderer\u003cbr/\u003e(OpenGL text quads)\"]\n    end\n    \n    subgraph Output[\"Output Destinations\"]\n        Screen[\"Display Output\"]\n        VR[\"VideoRecorder\u003cbr/\u003e(FFmpeg encoder thread)\"]\n        File[\"MP4/MKV File\"]\n    end\n    \n    Files --\u003e AE\n    Suno --\u003e AE\n    \n    AE --\u003e|\"decode via\"| FFSrc\n    AE --\u003e|\"or use\"| QBuf\n    \n    FFSrc --\u003e|\"PCM f32[]\"| AA\n    QBuf --\u003e|\"PCM f32[]\"| AA\n    \n    AA --\u003e|\"AudioSpectrum\u003cbr/\u003e(frequency bins)\"| PMB\n    \n    PMB --\u003e|\"projectM_renderFrame\"| FBO\n    FBO --\u003e|\"glReadPixels async\"| PBO\n    \n    FBO --\u003e VW\n    VW --\u003e|\"composite\"| OE\n    OE --\u003e|\"render text\"| OR\n    OR --\u003e Screen\n    \n    PBO -.-\u003e|\"if recording\"| VR\n    FFSrc -.-\u003e|\"PCM f32[]\u003cbr/\u003eif recording\"| VR\n    VR --\u003e File\n```\n\n**Pipeline Stages:**\n\n1. **Audio Input:** Files decoded by `FFmpegAudioSource` or `QMediaPlayer`  PCM float samples\n2. **Analysis:** `AudioAnalyzer::analyze()` computes FFT  `AudioSpectrum` (frequency bins)\n3. **Visualization:** `ProjectMBridge::renderFrame()` feeds spectrum to projectM  renders to FBO\n4. **Capture:** `RenderTarget` uses double-buffered PBOs for zero-copy async frame readback\n5. **Overlay:** `OverlayEngine` manages text elements, `OverlayRenderer` draws them with OpenGL\n6. **Output:** Final frame goes to display; if recording, frames queue to `VideoRecorder` encoder thread\n7. **Encoding:** `VideoRecorder` muxes video frames + audio PCM  MP4/MKV via FFmpeg\n\n**Sources:** [CMakeLists.txt:128-139](), [CMakeLists.txt:141-152](), [CMakeLists.txt:175-182]()\n\n---\n\n## Module Organization\n\nThe codebase is organized into logical subsystems, each with dedicated source files. The `CMakeLists.txt` defines module groupings for clarity:\n\n| Module | Files | Responsibilities |\n|--------|-------|------------------|\n| **Util** | `Types.hpp`, `Result.hpp`, `Signal.hpp`, `FileUtils.*` | Type aliases, error handling, lightweight signals, file operations |\n| **Core** | `Logger.*`, `Config.*`, `Application.*` | Logging, TOML configuration, singleton entry point |\n| **Audio** | `AudioEngine.*`, `AudioAnalyzer.*`, `Playlist.*`, `MediaMetadata.*`, `FFmpegAudioSource.*` | Playback, spectrum analysis, playlist management, metadata extraction, FFmpeg decoding |\n| **Visualizer** | `ProjectMBridge.*`, `PresetManager.*`, `RatingManager.*`, `RenderTarget.*`, `VisualizerWindow.*` | projectM wrapper, preset scanning/navigation, favorites/blacklist, FBO management, OpenGL window |\n| **Suno** | `SunoModels.hpp`, `SunoClient.*`, `SunoDatabase.*` | API models, HTTP client, SQLite persistence |\n| **Overlay** | `TextElement.*`, `TextAnimator.*`, `OverlayConfig.*`, `OverlayEngine.*`, `OverlayRenderer.*` | Text element definitions, animation logic, configuration, engine orchestration, OpenGL rendering |\n| **Recorder** | `EncoderSettings.*`, `FrameGrabber.*`, `VideoRecorder.*` | Codec configuration, async frame queue, FFmpeg encoding thread |\n| **UI** | `controllers/*`, `MarqueeLabel.*`, `PlayerControls.*`, `PlaylistView.*`, `VisualizerPanel.*`, `OverlayEditor.*`, `SunoBrowser.*`, `SunoCookieDialog.*`, `PresetBrowser.*`, `RecordingControls.*`, `SettingsDialog.*`, `MainWindow.*` | Signal routing controllers, custom widgets, main window |\n\n**Headers Included in CMake:** The build system explicitly lists all headers to ensure `AUTOMOC` processes Qt `Q_OBJECT` declarations correctly.\n\n**Sources:** [CMakeLists.txt:110-227]()\n\n---\n\n## Application Entry Point\n\nThe application lifecycle begins in `src/main.cpp`, which instantiates the `Application` singleton and initializes all subsystems:\n\n### Initialization Sequence\n\n```mermaid\ngraph TD\n    main[\"main()\"]\n    QApp[\"QApplication instance\"]\n    AppInit[\"Application::init()\"]\n    CfgLoad[\"CONFIG.load()\"]\n    LogInit[\"Logger::init()\"]\n    EngInit[\"Engine initialization\"]\n    UICreate[\"MainWindow creation\"]\n    EventLoop[\"app.exec()\"]\n    \n    main --\u003e QApp\n    QApp --\u003e AppInit\n    AppInit --\u003e CfgLoad\n    AppInit --\u003e LogInit\n    AppInit --\u003e EngInit\n    EngInit --\u003e AudioEngineInit[\"AudioEngine::init()\"]\n    EngInit --\u003e VideoRecInit[\"VideoRecorder::init()\"]\n    EngInit --\u003e OverlayEngInit[\"OverlayEngine::init()\"]\n    AppInit --\u003e UICreate\n    UICreate --\u003e EventLoop\n```\n\n**Startup Flow:**\n\n1. `main()` creates `QApplication` and calls `Application::init()`\n2. `Application::init()` loads configuration from `~/.config/chadvis-projectm-qt/config.toml` via `CONFIG.load()`\n3. Logger initializes with settings from `CONFIG.debug()`\n4. Engines are created: `audioEngine_`, `videoRecorder_`, `overlayEngine_`\n5. `MainWindow` is constructed, which creates controllers and UI widgets\n6. Controllers call `setupUI()` to configure widgets and `connectSignals()` to wire events\n7. Event loop starts with `app.exec()`\n\nThe `Application` singleton provides global access to engines via `Application::instance()` methods. Controllers obtain non-owning pointers during construction.\n\n**Sources:** [CMakeLists.txt:218](), [AGENTS.md:79-86]()\n\n---\n\n## Configuration System\n\nConfiguration uses a **singleton pattern with TOML persistence**. The `Config` class provides thread-safe access via the `CONFIG` macro and implements dirty tracking for optimized saves.\n\n### Configuration Structure\n\n```mermaid\ngraph TB\n    subgraph \"Config Singleton\"\n        Cfg[\"Config\u003cbr/\u003e(singleton)\"]\n        \n        subgraph \"Configuration Sections\"\n            Audio[\"AudioConfig\u003cbr/\u003e(device, bufferSize, sampleRate)\"]\n            Viz[\"VisualizerConfig\u003cbr/\u003e(presetPath, fps, beatSensitivity)\"]\n            Rec[\"RecordingConfig\u003cbr/\u003e(outputDirectory, container)\"]\n            UI[\"UIConfig\u003cbr/\u003e(theme, colors)\"]\n            KB[\"KeyboardConfig\u003cbr/\u003e(shortcuts)\"]\n            Suno[\"SunoConfig\u003cbr/\u003e(token, cookie, downloadPath)\"]\n            Overlay[\"vector\u0026lt;OverlayElementConfig\u0026gt;\"]\n        end\n        \n        VidEnc[\"VideoEncoderConfig\u003cbr/\u003e(codec, crf, preset)\"]\n        AudEnc[\"AudioEncoderConfig\u003cbr/\u003e(codec, bitrate)\"]\n    end\n    \n    subgraph \"Persistence\"\n        TOML[\"config.toml\u003cbr/\u003e(~/.config/chadvis-projectm-qt/)\"]\n        M3U[\"last_session.m3u\u003cbr/\u003e(playlist state)\"]\n        PresetTxt[\"preset_state.txt\u003cbr/\u003e(favorites/blacklist)\"]\n        SunoDB[\"suno_library.db\u003cbr/\u003e(SQLite)\"]\n    end\n    \n    subgraph \"Application Components\"\n        Modules[\"AudioEngine\u003cbr/\u003eVisualizerWindow\u003cbr/\u003eVideoRecorder\u003cbr/\u003eUI Components\"]\n    end\n    \n    Cfg --\u003e Audio\n    Cfg --\u003e Viz\n    Cfg --\u003e Rec\n    Cfg --\u003e UI\n    Cfg --\u003e KB\n    Cfg --\u003e Suno\n    Cfg --\u003e Overlay\n    \n    Rec --\u003e VidEnc\n    Rec --\u003e AudEnc\n    \n    Cfg \u003c--\u003e|\"load() / save()\"| TOML\n    \n    Modules --\u003e|\"CONFIG macro\"| Cfg\n    \n    Audio -.-\u003e|\"managed by\"| M3U\n    Viz -.-\u003e|\"managed by\"| PresetTxt\n    Suno -.-\u003e|\"managed by\"| SunoDB\n```\n\n**Usage Pattern:**\n\n```cpp\n// Access configuration anywhere in the codebase\nauto fps = CONFIG.visualizer().fps;\nCONFIG.recording().outputDirectory = \"/path/to/videos\";\nCONFIG.save(CONFIG.configPath()); // Persist changes\n```\n\n**Key Features:**\n\n- **Global Access:** The `CONFIG` macro expands to `vc::Config::instance()`\n- **Dirty Tracking:** Mutable accessors call `markDirty()` to trigger auto-save checks\n- **Thread Safety:** Internal `std::mutex` protects concurrent access\n- **Nested Structures:** `RecordingConfig` contains `VideoEncoderConfig` and `AudioEncoderConfig`, mirroring UI organization\n- **Typed Accessors:** Const and non-const overloads for section structs\n\n**Sources:** [src/core/Config.hpp:1-236](), [AGENTS.md:79-86]()\n\n---\n\n## Threading Architecture\n\nThe application uses a **hybrid threading model** to balance responsiveness and performance:\n\n| Thread | Purpose | Components |\n|--------|---------|------------|\n| **Main (Qt Event Loop)** | UI updates, user input, OpenGL rendering | `MainWindow`, `VisualizerWindow`, controllers, widgets |\n| **Audio Decode Thread** | FFmpeg decoding (if used) | `FFmpegAudioSource` worker |\n| **Qt Multimedia Thread** | Native audio decoding | `QMediaPlayer` / `QAudioBufferOutput` |\n| **Video Encode Thread** | FFmpeg muxing and encoding | `VideoRecorder::encodeLoop()` |\n| **Frame Capture (async)** | PBO readback via `glFenceSync` | `FrameGrabber::captureFrame()` |\n\n**Synchronization Mechanisms:**\n\n- **Spectrum Data:** `AudioAnalyzer` computes FFT on audio thread, emits `spectrumUpdated()` signal to update `ProjectMBridge` on main thread\n- **Frame Queue:** `FrameGrabber` enqueues frames; `VideoRecorder` dequeues on encode thread with `std::condition_variable`\n- **Config Access:** `std::mutex` guards `Config` singleton reads/writes\n- **Signal/Slot:** Qt's queued connections handle cross-thread communication\n\n**Performance Considerations:**\n\n- **Zero-Copy Capture:** PBOs enable GPU-side frame readback without blocking the render loop\n- **Pre-allocated Buffers:** `AudioAnalyzer` maintains a `scratchBuffer_` to avoid allocations in hot paths\n- **Lock-Free Where Possible:** `Signal\u003cT\u003e` template uses `std::function` vector with minimal locking\n\n**Sources:** [AGENTS.md:90-95](), [CMakeLists.txt:175-182]()\n\n---\n\n## Error Handling Strategy\n\nThe project uses **no exceptions**; all fallible operations return `vc::Result\u003cT\u003e`, a lightweight error monad:\n\n```cpp\ntemplate \u003ctypename T\u003e\nclass Result {\npublic:\n    static Result ok(T value);\n    static Result err(std::string message);\n    \n    bool isOk() const;\n    bool isErr() const;\n    const T\u0026 value() const;\n    const std::string\u0026 error() const;\n};\n```\n\n**Macros for Propagation:**\n\n- `TRY(result)`: Early return if `result.isErr()`\n- `TRY_VOID(result)`: Early return for `Result\u003cvoid\u003e`\n\n**Example Usage:**\n\n```cpp\nResult\u003cvoid\u003e VideoRecorder::init(const EncoderSettings\u0026 settings) {\n    auto codecResult = findCodec(settings.videoCodec);\n    TRY(codecResult); // Propagates error up\n    \n    codec_ = codecResult.value();\n    return Result\u003cvoid\u003e::ok();\n}\n```\n\n**Benefits:**\n\n- Forces explicit error handling at call sites\n- No hidden control flow (unlike exceptions)\n- Compile-time enforcement via `[[nodiscard]]`\n\n**Sources:** [AGENTS.md:54-65](), [AGENTS.md:100-103]()\n\n---\n\n## Summary\n\n**chadvis-projectm-qt** is a comprehensive audio visualization platform built on modern C++ and Qt6 principles. Its architecture separates concerns into well-defined modules (audio, visualization, recording, overlay, UI, Suno integration), connected by a singleton-engine-controller pattern. Data flows from audio input through spectrum analysis and projectM rendering to display and optional recording, with all configuration managed via a centralized TOML-based system.\n\nFor deeper exploration:\n- **Architecture details:** See [Architecture \u0026 Design Patterns](#1.1)\n- **Build instructions:** See [Building \u0026 Running](#1.2)\n- **Audio system:** See [Audio System](#3)\n- **Visualization:** See [Visualization System](#4)\n- **Recording:** See [Recording System](#5)\n- **UI implementation:** See [User Interface](#7)\n- **Suno integration:** See [Suno AI Integration](#8)\n\n**Sources:** [CMakeLists.txt:1-282](), [src/core/Config.hpp:1-236](), [AGENTS.md:1-113]()"])</script><script>self.__next_f.push([1,"18:T49e5,"])</script><script>self.__next_f.push([1,"# Architecture \u0026 Design Patterns\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AGENTS.md](AGENTS.md)\n- [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md)\n- [src/ui/controllers/AudioController.cpp](src/ui/controllers/AudioController.cpp)\n- [src/ui/controllers/RecordingController.cpp](src/ui/controllers/RecordingController.cpp)\n- [src/ui/controllers/VisualizerController.cpp](src/ui/controllers/VisualizerController.cpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document describes the fundamental architectural patterns and design principles used throughout the chadvis-projectm-qt codebase. It covers the **Singleton-Engine-Controller** pattern, ownership semantics, threading model, error handling approach using `Result\u003cT\u003e`, and communication patterns via signals. \n\nFor information about specific subsystems (audio, visualization, recording, UI, etc.), see their respective sections: [Audio System](#3), [Visualization System](#4), [Recording System](#5), [User Interface](#7). For details on the build system and project structure, see [Build System \u0026 Dependencies](#2.2).\n\n---\n\n## Core Design Pattern: Singleton-Engine-Controller\n\nThe application follows a three-layer architecture that separates concerns between application lifecycle, business logic, and user interface.\n\n```mermaid\ngraph TB\n    subgraph \"Layer 1: Singleton Core\"\n        APP[\"Application\u003cbr/\u003e(singleton)\"]\n        CONFIG[\"Config\u003cbr/\u003e(singleton)\"]\n        LOGGER[\"Logger\"]\n    end\n    \n    subgraph \"Layer 2: Engines (Owned by Application)\"\n        AUDIO_ENG[\"AudioEngine\"]\n        VIDEO_REC[\"VideoRecorder\"]\n        OVERLAY_ENG[\"OverlayEngine\"]\n    end\n    \n    subgraph \"Layer 3: Controllers (Non-owning)\"\n        AUDIO_CTRL[\"AudioController\"]\n        REC_CTRL[\"RecordingController\"]\n        VIZ_CTRL[\"VisualizerController\"]\n        SUNO_CTRL[\"SunoController\"]\n    end\n    \n    subgraph \"Layer 4: UI Widgets\"\n        PLAYER[\"PlayerControls\"]\n        PLAYLIST[\"PlaylistView\"]\n        REC_UI[\"RecordingControls\"]\n        PRESET_BR[\"PresetBrowser\"]\n    end\n    \n    APP --\u003e|\"owns (unique_ptr)\"| AUDIO_ENG\n    APP --\u003e|\"owns (unique_ptr)\"| VIDEO_REC\n    APP --\u003e|\"owns (unique_ptr)\"| OVERLAY_ENG\n    \n    AUDIO_CTRL -.-\u003e|\"non-owning ptr\"| AUDIO_ENG\n    REC_CTRL -.-\u003e|\"non-owning ptr\"| VIDEO_REC\n    SUNO_CTRL -.-\u003e|\"non-owning ptr\"| AUDIO_ENG\n    \n    AUDIO_CTRL --\u003e|\"setupUI()\"| PLAYER\n    AUDIO_CTRL --\u003e|\"setupUI()\"| PLAYLIST\n    REC_CTRL --\u003e|\"setupUI()\"| REC_UI\n    VIZ_CTRL --\u003e|\"setupUI()\"| PRESET_BR\n    \n    AUDIO_CTRL --\u003e|\"connectSignals()\"| AUDIO_ENG\n    REC_CTRL --\u003e|\"connectSignals()\"| VIDEO_REC\n```\n\n**Sources:** [src/core/Application.hpp](), [src/ui/controllers/AudioController.cpp:12-22](), [src/ui/controllers/RecordingController.cpp:15-23](), [docs/ARCHITECTURE.md:9-31]()\n\n### Layer 1: Singleton Core\n\nThe `Application` class serves as the single entry point and supreme owner of all core engines. It is accessible globally via the `APP` macro.\n\n| Singleton | Purpose | Access Pattern |\n|-----------|---------|----------------|\n| `Application` | Owns engines, manages lifecycle | `APP` macro |\n| `Config` | TOML-based settings, thread-safe | `CONFIG` macro |\n| `Logger` | Diagnostic output via spdlog | `LOG_*` macros |\n\nThe singleton pattern is used here to ensure:\n- **Single ownership** of expensive resources (audio devices, OpenGL contexts, FFmpeg encoders)\n- **Global access** without explicit dependency injection\n- **Guaranteed initialization order** during startup\n\n**Sources:** [src/core/Application.hpp](), [docs/ARCHITECTURE.md:9-13](), [AGENTS.md:80]()\n\n### Layer 2: Engines (Business Logic)\n\nEngines handle heavy lifting and are owned exclusively by `Application` via `std::unique_ptr`. They expose their functionality through public methods and emit signals for state changes.\n\n```mermaid\ngraph LR\n    subgraph \"Application Ownership\"\n        APP[\"Application\"]\n        \n        AUDIO[\"AudioEngine\u003cbr/\u003estd::unique_ptr\"]\n        VIDEO[\"VideoRecorder\u003cbr/\u003estd::unique_ptr\"]\n        OVERLAY[\"OverlayEngine\u003cbr/\u003estd::unique_ptr\"]\n    end\n    \n    APP --\u003e|\"owns\"| AUDIO\n    APP --\u003e|\"owns\"| VIDEO\n    APP --\u003e|\"owns\"| OVERLAY\n    \n    AUDIO --\u003e|\"contains\"| ANALYZER[\"AudioAnalyzer\"]\n    AUDIO --\u003e|\"contains\"| PLAYLIST_OBJ[\"Playlist\"]\n    \n    VIDEO --\u003e|\"uses\"| FRAME_GRAB[\"FrameGrabber\"]\n```\n\n**Key engines:**\n- **`AudioEngine`**: Manages `QMediaPlayer`, FFmpeg decoding, `AudioAnalyzer` for spectrum data, and `Playlist` for track management\n- **`VideoRecorder`**: Asynchronous FFmpeg encoder running in dedicated thread\n- **`OverlayEngine`**: Text rendering engine that composites metadata/lyrics over visualizations\n\n**Sources:** [docs/ARCHITECTURE.md:15-19](), [AGENTS.md:81-82]()\n\n### Layer 3: Controllers (Signal Routing)\n\nControllers mediate between UI widgets and engines. They hold **non-owning raw pointers** to engines (which are owned by `Application`) and configure UI widgets via two key methods:\n\n```cpp\n// Pattern implemented by all controllers\nclass SomeController : public QObject {\npublic:\n    void setupUI(Widget* widget);      // Configure widget references\n    void connectSignals();              // Establish signal/slot bindings\nprivate:\n    Engine* engine_;                    // Non-owning pointer\n    Widget* widget_;                    // Non-owning pointer\n};\n```\n\n**Example from AudioController:**\n\n[src/ui/controllers/AudioController.cpp:16-22]() - The `setupUI()` method configures widget references:\n```cpp\nvoid AudioController::setupUI(PlayerControls* controls, PlaylistView* view) {\n    controls_ = controls;\n    view_ = view;\n    controls_-\u003esetAudioEngine(engine_);\n    view_-\u003esetPlaylist(\u0026engine_-\u003eplaylist());\n}\n```\n\n[src/ui/controllers/AudioController.cpp:24-53]() - The `connectSignals()` method establishes all signal/slot bindings between widgets and the engine.\n\n**Sources:** [src/ui/controllers/AudioController.cpp](), [src/ui/controllers/RecordingController.cpp](), [docs/ARCHITECTURE.md:26-31]()\n\n---\n\n## Ownership Model\n\nThe codebase enforces strict ownership semantics to prevent memory leaks and use-after-free bugs.\n\n### Ownership Rules\n\n| Pattern | Usage | Example |\n|---------|-------|---------|\n| `std::unique_ptr\u003cT\u003e` | Exclusive ownership of non-Qt objects | Engines owned by `Application` |\n| Qt parent-child | QObjects owned by parent | Widgets owned by `MainWindow` |\n| Raw pointers | Non-owning references | Controllers referencing engines |\n| `std::shared_ptr\u003cT\u003e` | **Avoided** unless truly shared | Not used in core architecture |\n\n```mermaid\ngraph TB\n    subgraph \"Ownership Hierarchy\"\n        APP[\"Application\u003cbr/\u003e(std::unique_ptr owners)\"]\n        \n        AUDIO_ENG[\"AudioEngine\"]\n        VID_REC[\"VideoRecorder\"]\n        OVERLAY[\"OverlayEngine\"]\n        \n        MAIN_WIN[\"MainWindow\u003cbr/\u003e(Qt parent)\"]\n        \n        AUDIO_CTRL[\"AudioController\"]\n        REC_CTRL[\"RecordingController\"]\n        \n        PLAYER[\"PlayerControls\u003cbr/\u003e(child)\"]\n        REC_UI[\"RecordingControls\u003cbr/\u003e(child)\"]\n    end\n    \n    APP --\u003e|\"unique_ptr owns\"| AUDIO_ENG\n    APP --\u003e|\"unique_ptr owns\"| VID_REC\n    APP --\u003e|\"unique_ptr owns\"| OVERLAY\n    \n    MAIN_WIN --\u003e|\"Qt parent owns\"| PLAYER\n    MAIN_WIN --\u003e|\"Qt parent owns\"| REC_UI\n    MAIN_WIN --\u003e|\"Qt parent owns\"| AUDIO_CTRL\n    MAIN_WIN --\u003e|\"Qt parent owns\"| REC_CTRL\n    \n    AUDIO_CTRL -.-\u003e|\"raw ptr references\"| AUDIO_ENG\n    REC_CTRL -.-\u003e|\"raw ptr references\"| VID_REC\n    AUDIO_CTRL -.-\u003e|\"raw ptr references\"| PLAYER\n    REC_CTRL -.-\u003e|\"raw ptr references\"| REC_UI\n```\n\n### Lifetime Guarantees\n\nThe architecture provides clear lifetime guarantees:\n\n1. **Engines outlive controllers**: `Application` owns engines and destroys them only during shutdown, after all UI components\n2. **Widgets outlive signal connections**: Qt parent-child ownership ensures widgets exist as long as their parent window\n3. **No circular ownership**: Controllers never own engines, preventing reference cycles\n\n**Example from RecordingController:**\n\n[src/ui/controllers/RecordingController.cpp:15-18]() shows the constructor accepting raw pointers:\n```cpp\nRecordingController::RecordingController(VideoRecorder* recorder,\n                                         MainWindow* window)\n    : QObject(nullptr), recorder_(recorder), window_(window) {\n}\n```\n\nThe raw pointers are safe because:\n- `recorder_` is owned by `Application` (outlives the controller)\n- `window_` is the parent of the controller (outlives the controller)\n\n**Sources:** [docs/ARCHITECTURE.md:60](), [AGENTS.md:36](), [src/ui/controllers/RecordingController.cpp:15-18]()\n\n---\n\n## Threading Architecture\n\nThe application uses multiple threads to prevent blocking the UI during expensive operations.\n\n```mermaid\ngraph TB\n    subgraph \"Main Thread (Qt Event Loop)\"\n        UI[\"UI Rendering\u003cbr/\u003eQWindow::paintGL()\"]\n        EVENTS[\"Event Handling\u003cbr/\u003eMouse/Keyboard\"]\n        PROJECTM[\"ProjectM Rendering\u003cbr/\u003eprojectM::render()\"]\n    end\n    \n    subgraph \"Audio Thread (Qt Multimedia)\"\n        DECODE[\"Audio Decoding\u003cbr/\u003eQMediaPlayer/FFmpeg\"]\n        ANALYSIS[\"Spectrum Analysis\u003cbr/\u003eAudioAnalyzer::analyze()\"]\n    end\n    \n    subgraph \"Recorder Thread (Dedicated)\"\n        ENCODE[\"Video Encoding\u003cbr/\u003eavcodec_send_frame()\"]\n        MUX[\"Packet Muxing\u003cbr/\u003eav_interleaved_write_frame()\"]\n    end\n    \n    subgraph \"Network Thread (QNetworkAccessManager)\"\n        HTTP[\"HTTP Requests\u003cbr/\u003eSunoClient API calls\"]\n    end\n    \n    DECODE --\u003e|\"pcmReceived signal\"| UI\n    DECODE --\u003e|\"pcmReceived signal\"| ANALYSIS\n    ANALYSIS --\u003e|\"spectrum data\"| PROJECTM\n    \n    UI --\u003e|\"frameCaptured signal\"| ENCODE\n    DECODE -.-\u003e|\"if recording\"| ENCODE\n    \n    HTTP --\u003e|\"libraryFetched signal\"| UI\n```\n\n### Thread Communication\n\n| From Thread | To Thread | Mechanism | Example |\n|-------------|-----------|-----------|---------|\n| Audio  Main | Main | Qt signals (queued) | `AudioEngine::trackChanged` |\n| Audio  Main | Main | Custom signals | `AudioEngine::pcmReceived` |\n| Main  Recorder | Recorder | Direct submission | `VideoRecorder::submitVideoFrame()` |\n| Network  Main | Main | Qt signals (queued) | `SunoClient::libraryFetched` |\n\n**Thread-safety considerations:**\n\n[src/ui/controllers/RecordingController.cpp:35-45]() shows `Qt::DirectConnection` used for frame capture to avoid copying frame data:\n```cpp\nconnect(visualizer, \u0026VisualizerWindow::frameCaptured, this,\n    [this](std::vector\u003cu8\u003e data, u32 w, u32 h, i64 ts) {\n        if (recorder_-\u003eisRecording()) {\n            recorder_-\u003esubmitVideoFrame(std::move(data), w, h, ts);\n        }\n    },\n    Qt::DirectConnection);  // Direct call, no queuing\n```\n\n[src/ui/controllers/RecordingController.cpp:48-57]() uses custom signal with lambda callback:\n```cpp\nwindow_-\u003eaudioEngine()-\u003epcmReceived.connect(\n    [this](const std::vector\u003cf32\u003e\u0026 pcm, u32 frames, u32 channels, u32 sampleRate) {\n        if (recorder_-\u003eisRecording()) {\n            recorder_-\u003esubmitAudioSamples(pcm.data(), frames, channels, sampleRate);\n        }\n    });\n```\n\n**Sources:** [docs/ARCHITECTURE.md:33-39](), [src/ui/controllers/RecordingController.cpp:35-57](), [AGENTS.md:86]()\n\n---\n\n## Error Handling: Result\u003cT\u003e Pattern\n\nThe codebase uses **no exceptions**. All fallible operations return `vc::Result\u003cT\u003e`, a Rust-inspired sum type.\n\n### Result\u003cT\u003e API\n\n```cpp\n// Definition (conceptual)\ntemplate\u003ctypename T\u003e\nclass Result {\npublic:\n    static Result\u003cT\u003e ok(T value);\n    static Result\u003cT\u003e err(std::string message);\n    \n    bool isOk() const;\n    bool isErr() const;\n    T value() const;                    // Returns value or throws in debug\n    const std::string\u0026 error() const;   // Returns error message\n};\n```\n\n### Usage Patterns\n\n**Pattern 1: Check and early return**\n```cpp\nResult\u003cvoid\u003e init() {\n    if (failed) {\n        return Result\u003cvoid\u003e::err(\"Detailed error message\");\n    }\n    return Result\u003cvoid\u003e::ok();\n}\n```\n\n**Pattern 2: TRY macro for chaining**\n```cpp\nauto result = doSomething();\nTRY(result);  // Returns error if result.isErr()\n// Continue if ok...\n```\n\n**Pattern 3: Value extraction**\n```cpp\nauto result = getConfig();\nif (result.isOk()) {\n    Config cfg = result.value();\n    // Use cfg...\n}\n```\n\n### Error Propagation\n\n```mermaid\ngraph LR\n    A[\"Fallible Operation\u003cbr/\u003eResult\u0026lt;T\u0026gt; init()\"]\n    B[\"Check Error\u003cbr/\u003eif isErr()\"]\n    C[\"Early Return\u003cbr/\u003ereturn result\"]\n    D[\"TRY Macro\u003cbr/\u003eTRY(result)\"]\n    E[\"Continue Execution\u003cbr/\u003euse result.value()\"]\n    \n    A --\u003e B\n    B --\u003e|\"error\"| C\n    B --\u003e|\"ok\"| E\n    \n    A --\u003e D\n    D --\u003e|\"error\"| C\n    D --\u003e|\"ok\"| E\n```\n\n### Best Practices\n\nFrom [AGENTS.md:100-103]():\n- Use `[[nodiscard]]` for functions returning `Result`\n- Provide descriptive error messages in `Result::err()`\n- Use the `TRY()` macro for chaining fallible operations\n\n**Sources:** [AGENTS.md:54-65](), [AGENTS.md:100-103](), [src/util/Result.hpp]()\n\n---\n\n## Communication Patterns\n\nThe application uses two complementary signaling mechanisms depending on whether the sender is a `QObject`.\n\n### Pattern Comparison\n\n| Pattern | Used For | Advantages | Example |\n|---------|----------|------------|---------|\n| Qt signals/slots | QObject communication | Thread-safe queuing, inspector support | `PlayerControls::playClicked` |\n| `vc::Signal\u003cT\u003e` | Non-QObject classes | Lightweight, template-based | `AudioEngine::pcmReceived` |\n\n```mermaid\ngraph TB\n    subgraph \"Qt Signals/Slots (QObject Classes)\"\n        WIDGET[\"UI Widget\u003cbr/\u003e(QObject)\"]\n        CTRL[\"Controller\u003cbr/\u003e(QObject)\"]\n        \n        WIDGET --\u003e|\"emit playClicked()\"| CTRL\n    end\n    \n    subgraph \"Custom Signals (Non-QObject Classes)\"\n        ENGINE[\"AudioEngine\u003cbr/\u003e(non-QObject)\"]\n        SIGNAL[\"vc::Signal\u0026lt;PCMData\u0026gt;\u003cbr/\u003epcmReceived\"]\n        LISTENER[\"Lambda Callback\"]\n        \n        ENGINE --\u003e|\"pcmReceived.emit(...)\"| SIGNAL\n        SIGNAL --\u003e|\"calls\"| LISTENER\n    end\n    \n    CTRL -.-\u003e|\"engine-\u003eplay()\"| ENGINE\n```\n\n### Qt Signals Example\n\n[src/ui/controllers/AudioController.cpp:26-34]() shows Qt signal/slot connections:\n```cpp\nconnect(controls_, \u0026PlayerControls::playClicked, [this] {\n    engine_-\u003eplay();\n});\nconnect(controls_, \u0026PlayerControls::pauseClicked, [this] {\n    engine_-\u003epause();\n});\n```\n\n### Custom Signal Example\n\n[src/ui/controllers/AudioController.cpp:82-90]() shows `vc::Signal` usage:\n```cpp\nengine_-\u003epcmReceived.connect([this](const std::vector\u003cf32\u003e\u0026 pcm,\n                                    u32 frames,\n                                    u32 channels,\n                                    u32 sampleRate) {\n    if (!pcm.empty() \u0026\u0026 frames \u003e 0) {\n        window_-\u003evisualizerPanel()-\u003evisualizer()-\u003efeedAudio(\n            pcm.data(), frames, channels, sampleRate);\n    }\n});\n```\n\n### Automatic Track Change Handling\n\n[src/ui/controllers/RecordingController.cpp:60-74]() demonstrates reactive signal handling:\n```cpp\n// Auto-stop recording on track change\nwindow_-\u003eaudioEngine()-\u003etrackChanged.connect([this] {\n    if (recorder_-\u003eisRecording()) {\n        LOG_INFO(\"Track changed, stopping recording.\");\n        window_-\u003eonStopRecording();\n    }\n    \n    if (CONFIG.recording().autoRecord) {\n        LOG_INFO(\"Auto-record enabled, starting recording for new track.\");\n        QTimer::singleShot(500, this, [this] {\n            if (window_-\u003eaudioEngine()-\u003eisPlaying()) {\n                window_-\u003eonStartRecording(\"\");\n            }\n        });\n    }\n});\n```\n\n**Sources:** [AGENTS.md:86](), [src/ui/controllers/AudioController.cpp:26-90](), [src/ui/controllers/RecordingController.cpp:60-74]()\n\n---\n\n## Configuration Architecture\n\nThe `Config` singleton provides centralized, thread-safe access to application settings with TOML persistence.\n\n```mermaid\ngraph TB\n    subgraph \"Config Singleton\"\n        CONFIG_INST[\"Config Instance\"]\n        \n        subgraph \"Config Sections\"\n            AUDIO_CFG[\"AudioConfig\"]\n            VIZ_CFG[\"VisualizerConfig\"]\n            REC_CFG[\"RecordingConfig\"]\n            UI_CFG[\"UIConfig\"]\n            KB_CFG[\"KeyboardConfig\"]\n            SUNO_CFG[\"SunoConfig\"]\n            OVERLAY_CFG[\"vector\u0026lt;OverlayElementConfig\u0026gt;\"]\n        end\n    end\n    \n    subgraph \"Access Pattern\"\n        CODE[\"Application Code\"]\n        MACRO[\"CONFIG Macro\"]\n        \n        CODE --\u003e|\"CONFIG.audio()\"| MACRO\n        MACRO -.-\u003e|\"thread-safe access\"| CONFIG_INST\n    end\n    \n    subgraph \"Persistence\"\n        TOML[\"config.toml\"]\n        LOAD[\"load()\"]\n        SAVE[\"save()\"]\n        \n        CONFIG_INST --\u003e|\"at startup\"| LOAD\n        LOAD --\u003e TOML\n        SAVE --\u003e TOML\n    end\n    \n    CONFIG_INST --\u003e AUDIO_CFG\n    CONFIG_INST --\u003e VIZ_CFG\n    CONFIG_INST --\u003e REC_CFG\n    CONFIG_INST --\u003e UI_CFG\n    CONFIG_INST --\u003e KB_CFG\n    CONFIG_INST --\u003e SUNO_CFG\n    CONFIG_INST --\u003e OVERLAY_CFG\n```\n\n### Access Patterns\n\n**Global macro access:**\n```cpp\n// Anywhere in the codebase\nif (CONFIG.recording().autoRecord) {\n    startRecording();\n}\n```\n\n**Section accessors:**\n- `CONFIG.audio()`  `AudioConfig`\n- `CONFIG.visualizer()`  `VisualizerConfig`\n- `CONFIG.recording()`  `RecordingConfig`\n- `CONFIG.ui()`  `UIConfig`\n- `CONFIG.keyboard()`  `KeyboardConfig`\n- `CONFIG.suno()`  `SunoConfig`\n- `CONFIG.overlays()`  `vector\u003cOverlayElementConfig\u003e`\n\n### Thread Safety\n\nThe `Config` singleton implements internal locking to allow safe concurrent access from multiple threads (main, audio, recorder, network). Read operations acquire shared locks, write operations acquire exclusive locks.\n\n### Dirty Tracking\n\nThe config system tracks whether settings have been modified and only writes to disk when necessary, optimizing I/O operations.\n\n**Example usage from RecordingController:**\n\n[src/ui/controllers/RecordingController.cpp:66]() accesses recording configuration:\n```cpp\nif (CONFIG.recording().autoRecord) {\n    // ...\n}\n```\n\n**Sources:** [AGENTS.md:80](), [docs/ARCHITECTURE.md:9-13](), [src/ui/controllers/RecordingController.cpp:66]()\n\n---\n\n## Summary\n\nThe architectural patterns in chadvis-projectm-qt prioritize:\n\n| Principle | Implementation |\n|-----------|----------------|\n| **Clear ownership** | Singleton owns engines via `unique_ptr`, controllers use non-owning pointers |\n| **Separation of concerns** | Three-layer architecture (core  engines  controllers  UI) |\n| **Thread safety** | Dedicated threads for audio, recording, network; signals for communication |\n| **Reliability** | No exceptions, `Result\u003cT\u003e` for error handling |\n| **Testability** | Controllers mediate between UI and engines, enabling unit testing |\n| **Performance** | Direct connections for hot paths (frame capture), zero-copy operations |\n\nThis architecture enables the application to handle real-time audio processing, OpenGL rendering, and FFmpeg encoding without blocking the UI or causing resource contention.\n\n**Sources:** [docs/ARCHITECTURE.md](), [AGENTS.md:78-113](), [src/ui/controllers/AudioController.cpp](), [src/ui/controllers/RecordingController.cpp](), [src/ui/controllers/VisualizerController.cpp]()"])</script><script>self.__next_f.push([1,"19:T312c,"])</script><script>self.__next_f.push([1,"# Building \u0026 Running\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [.gitignore](.gitignore)\n- [CMakeLists.txt](CMakeLists.txt)\n- [build.zsh](build.zsh)\n- [src/core/Config.hpp](src/core/Config.hpp)\n- [src/overlay/OverlayRenderer.cpp](src/overlay/OverlayRenderer.cpp)\n\n\u003c/details\u003e\n\n\n\nThis page documents the build process, system requirements, and initial execution of the chadvis-projectm-qt application. This covers dependency installation, compilation using the build scripts, and basic invocation. For detailed configuration options, see [Application \u0026 Config](#2.1). For information about the CMake structure and module organization, see [Build System \u0026 Dependencies](#2.2).\n\n---\n\n## System Requirements\n\n### Build Dependencies\n\nThe project requires the following tools and libraries to compile:\n\n| Category | Package | Purpose |\n|----------|---------|---------|\n| Build Tools | CMake 3.20+ | Build system generator |\n| | Ninja | Fast parallel build executor |\n| | GCC/G++ | C++20 compiler |\n| Qt6 | qt6-base | Core, Gui, Widgets |\n| | qt6-multimedia | Audio playback |\n| | qt6-svg | SVG icon support |\n| Audio/Video | FFmpeg | libavcodec, libavformat, libavutil, libswscale, libswresample |\n| | taglib | Audio metadata reading |\n| Visualization | projectM v4 | Core visualization library |\n| | GLEW | OpenGL extension loading |\n| | glm | OpenGL mathematics |\n| Utilities | spdlog | Structured logging |\n| | fmt | String formatting |\n| | tomlplusplus | TOML config parsing |\n\n**Sources:** [CMakeLists.txt:59-69](), [build.zsh:158-179]()\n\n### Runtime Requirements\n\nAt runtime, the application requires:\n- OpenGL 3.3+ capable GPU and drivers\n- Audio output device (ALSA/PulseAudio on Linux)\n- Preset files (`.milk` format) in the configured preset directory\n- Writable configuration directory at `~/.config/chadvis-projectm-qt/`\n\n**Sources:** [CMakeLists.txt:60-69]()\n\n---\n\n## Dependency Installation\n\n### Dependency Check\n\nThe build script includes a dependency verification command:\n\n```bash\n./build.zsh check-deps\n```\n\nThis checks for all required packages using `pkg-config` and `command -v`, reporting missing dependencies with suggested installation commands.\n\n**Sources:** [build.zsh:158-179]()\n\n### ProjectM v4 Setup\n\nThe application specifically requires **projectM v4**, not v3. The CMake configuration searches in the following order:\n\n```mermaid\nflowchart TD\n    START[\"CMake Dependency Resolution\"]\n    \n    CHECK_LOCAL{\"Check\u003cbr/\u003eexternal/projectm-install/\"}\n    LOCAL_FOUND[\"Use Local Installation\u003cbr/\u003elibprojectM-4.so\"]\n    \n    PKG_V4[\"pkg-config projectM-4\"]\n    PKG_V4_OK[\"Found via pkg-config\"]\n    \n    PKG_LIB[\"pkg-config libprojectM\"]\n    PKG_LIB_OK[\"Found libprojectM\"]\n    \n    MANUAL[\"Manual Search\u003cbr/\u003e/usr/local, /usr\"]\n    MANUAL_OK[\"Found Manually\"]\n    \n    FATAL[\"FATAL_ERROR:\u003cbr/\u003eProjectM not found\"]\n    \n    START --\u003e CHECK_LOCAL\n    CHECK_LOCAL --\u003e|exists| LOCAL_FOUND\n    CHECK_LOCAL --\u003e|not found| PKG_V4\n    \n    PKG_V4 --\u003e|success| PKG_V4_OK\n    PKG_V4 --\u003e|fail| PKG_LIB\n    \n    PKG_LIB --\u003e|success| PKG_LIB_OK\n    PKG_LIB --\u003e|fail| MANUAL\n    \n    MANUAL --\u003e|found| MANUAL_OK\n    MANUAL --\u003e|not found| FATAL\n    \n    LOCAL_FOUND --\u003e END[\"Set PROJECTM_LIBRARIES\u003cbr/\u003eand INCLUDE_DIRS\"]\n    PKG_V4_OK --\u003e END\n    PKG_LIB_OK --\u003e END\n    MANUAL_OK --\u003e END\n```\n\n**Diagram: ProjectM v4 Discovery Process**\n\nThe local installation path `external/projectm-install` allows using a custom-built version without system installation. This is useful if the system package manager doesn't provide projectM v4.\n\n**Sources:** [CMakeLists.txt:71-108]()\n\n---\n\n## Build Process\n\n### Build Script Overview\n\nThe `build.zsh` script provides a unified interface for all build operations:\n\n```mermaid\ngraph TB\n    ENTRY[\"./build.zsh \u003ccommand\u003e\"]\n    \n    subgraph Commands\n        BUILD[\"build\u003cbr/\u003e(Incremental Debug)\"]\n        REBUILD[\"rebuild\u003cbr/\u003e(Clean Debug)\"]\n        CLEAN[\"clean\u003cbr/\u003e(Remove Artifacts)\"]\n        RUN[\"run\u003cbr/\u003e(Build + Execute)\"]\n        TEST[\"test\u003cbr/\u003e(Run Tests)\"]\n        DEPS[\"check-deps\u003cbr/\u003e(Verify Packages)\"]\n    end\n    \n    subgraph \"Build Pipeline\"\n        SANITIZE[\"sanitize_environment()\u003cbr/\u003eRemove Problematic Flags\"]\n        ENSURE[\"ensure_build_dir()\u003cbr/\u003eCreate build/\"]\n        CMAKE[\"invoke_cmake()\u003cbr/\u003eConfigure Ninja\"]\n        NINJA[\"invoke_ninja()\u003cbr/\u003eCompile Sources\"]\n    end\n    \n    subgraph \"Flags \u0026 Optimization\"\n        CPU_FLAGS[\"CPU_OPT_FLAGS\u003cbr/\u003e-march=tremont\"]\n        COMMON[\"COMMON_OPT_FLAGS\u003cbr/\u003e-pipe -fomit-frame-pointer\"]\n        DEBUG_F[\"DEBUG_FLAGS\u003cbr/\u003e-O2 -g1\"]\n        RELEASE_F[\"RELEASE_FLAGS\u003cbr/\u003e-O3 -flto\"]\n    end\n    \n    ENTRY --\u003e BUILD\n    ENTRY --\u003e REBUILD\n    ENTRY --\u003e CLEAN\n    ENTRY --\u003e RUN\n    ENTRY --\u003e TEST\n    ENTRY --\u003e DEPS\n    \n    BUILD --\u003e SANITIZE\n    SANITIZE --\u003e ENSURE\n    ENSURE --\u003e CMAKE\n    CMAKE --\u003e NINJA\n    \n    CMAKE --\u003e CPU_FLAGS\n    CMAKE --\u003e COMMON\n    CMAKE --\u003e DEBUG_F\n    CMAKE --\u003e RELEASE_F\n```\n\n**Diagram: Build Script Command Flow**\n\n**Sources:** [build.zsh:1-213]()\n\n### Standard Build Commands\n\n#### Debug Build (Default)\n\n```bash\n./build.zsh build\n```\n\nPerforms an incremental debug build:\n- Build type: `Debug`\n- Optimization: `-O2 -g1`\n- Output: `build/chadvis-projectm-qt`\n\n**Sources:** [build.zsh:129]()\n\n#### Clean Rebuild\n\n```bash\n./build.zsh rebuild\n```\n\nRemoves all artifacts from `build/` and performs a fresh debug build.\n\n**Sources:** [build.zsh:131]()\n\n#### Clean Build Directory\n\n```bash\n./build.zsh clean\n```\n\nRemoves all generated files from `build/` and `build-release/` directories.\n\n**Sources:** [build.zsh:134-140]()\n\n### Build Flags and Optimization\n\nThe build script applies CPU-specific optimizations by default:\n\n| Flag Category | Values | Purpose |\n|---------------|--------|---------|\n| CPU Architecture | `-march=tremont -mtune=tremont` | Intel N4500 optimization |\n| SIMD | `-msse4.2 -mpopcnt -maes -mno-avx -mno-avx2` | Enable supported instructions |\n| Common | `-pipe -fomit-frame-pointer -ffunction-sections -fdata-sections` | General optimization |\n| Linker | `-Wl,--gc-sections -Wl,--as-needed` | Dead code elimination |\n\n**Note:** The script includes `sanitize_environment()` which removes problematic flags like `-mno-direct-extern-access` that can cause linker errors.\n\n**Sources:** [build.zsh:13-21](), [build.zsh:62-74]()\n\n### CMake Configuration\n\nThe CMake configuration can be invoked directly:\n\n```bash\ncd build\ncmake -G Ninja \\\n  -DCMAKE_BUILD_TYPE=Debug \\\n  -DCMAKE_CXX_STANDARD=20 \\\n  -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \\\n  ..\n```\n\nKey CMake settings:\n\n| Setting | Value | Description |\n|---------|-------|-------------|\n| `CMAKE_CXX_STANDARD` | 20 | C++20 required |\n| `CMAKE_AUTOMOC` | ON | Qt MOC preprocessing |\n| `CMAKE_AUTORCC` | ON | Qt resource compilation |\n| `CMAKE_AUTOUIC` | ON | Qt UI file compilation |\n| `CMAKE_EXPORT_COMPILE_COMMANDS` | ON | Generate `compile_commands.json` |\n\n**Sources:** [CMakeLists.txt:27-40]()\n\n---\n\n## Running the Application\n\n### Basic Execution\n\nAfter building, run the application:\n\n```bash\n./build.zsh run\n```\n\nThis automatically builds if the binary doesn't exist, then executes `build/chadvis-projectm-qt`.\n\n**Sources:** [build.zsh:142-146]()\n\n### Direct Invocation\n\nYou can also run the binary directly:\n\n```bash\n./build/chadvis-projectm-qt\n```\n\n### Command-Line Arguments\n\nThe application accepts optional command-line arguments (passed through the run command):\n\n```bash\n./build.zsh run [args...]\n```\n\n**Sources:** [build.zsh:145]()\n\n---\n\n## First Run Setup\n\n### Configuration Directory\n\nOn first launch, the application creates its configuration directory:\n\n```\n~/.config/chadvis-projectm-qt/\n config.toml          # Main configuration file\n last_session.m3u     # Playlist persistence\n preset_state.txt     # Favorites/blacklist\n suno_library.db      # Suno integration data\n```\n\nThe `Config` singleton loads `config.toml` via the `loadDefault()` method, which searches for the configuration in standard XDG locations.\n\n**Sources:** [src/core/Config.hpp:108-117]()\n\n### Configuration Initialization Flow\n\n```mermaid\nsequenceDiagram\n    participant Main as \"main()\"\n    participant App as \"Application\"\n    participant Config as \"Config::instance()\"\n    participant FS as \"Filesystem\"\n    \n    Main-\u003e\u003eApp: Application::instance()\n    App-\u003e\u003eConfig: loadDefault()\n    \n    Config-\u003e\u003eFS: Check ~/.config/chadvis-projectm-qt/config.toml\n    \n    alt Config exists\n        FS--\u003e\u003eConfig: Load existing config\n        Config-\u003e\u003eConfig: Parse TOML sections\n    else Config missing\n        FS--\u003e\u003eConfig: Not found\n        Config-\u003e\u003eConfig: Use compiled defaults\n        Config-\u003e\u003eFS: Save default config.toml\n    end\n    \n    Config--\u003e\u003eApp: Configuration ready\n    App-\u003e\u003eApp: Initialize engines\u003cbr/\u003e(AudioEngine, VideoRecorder)\n    App--\u003e\u003eMain: Application ready\n```\n\n**Diagram: First Launch Configuration Flow**\n\n**Sources:** [src/core/Config.hpp:115-117](), [CMakeLists.txt:273]()\n\n### Required Resources\n\nBefore running, ensure:\n\n1. **Preset Directory**: Configure `visualizer.preset_path` in `config.toml` to point to a directory containing `.milk` preset files\n2. **Download Directory**: If using Suno integration, set `suno.download_path` for audio storage\n3. **Recording Directory**: Set `recording.output_directory` for video output\n\nDefault paths are created automatically, but presets must be obtained separately (e.g., from the projectM preset packs).\n\n**Sources:** [src/core/Config.hpp:14-106]()\n\n---\n\n## Build Artifacts\n\n### Output Structure\n\n```\nbuild/\n chadvis-projectm-qt       # Main executable\n compile_commands.json     # Clangd/LSP database\n CMakeCache.txt            # CMake configuration cache\n CMakeFiles/               # CMake metadata\n *.o                       # Compiled object files\n moc_*.cpp                 # Qt MOC generated files\n ui_*.h                    # Qt UI generated headers\n```\n\n**Sources:** [.gitignore:56-76](), [CMakeLists.txt:31]()\n\n### Binary Information\n\nAfter a successful build, the script displays binary information:\n\n```\n Debug Build \n   Architecture: tremont\n   Parallelism: 4 jobs\n Configuring CMake (Debug)...\n Building with Ninja (4 jobs)...\n Build complete\n   Binary: /path/to/build/chadvis-projectm-qt\n   Size: 8.2M\n```\n\n**Sources:** [build.zsh:108-123]()\n\n---\n\n## Troubleshooting\n\n### Common Build Errors\n\n| Error | Cause | Solution |\n|-------|-------|----------|\n| `ProjectM not found` | projectM v4 not installed | Install from AUR or build from source into `external/projectm-install` |\n| `-mno-direct-extern-access` error | Incompatible compiler flags from system | Build script automatically removes; check `$CXXFLAGS` environment |\n| `cannot find -lprojectM-4` | Linker flag formatting issue | CMake fixes `-l:projectM-4` to `-lprojectM-4` automatically |\n| MOC errors | Headers with `Q_OBJECT` not in source list | Verify all Qt headers are listed in CMakeLists.txt source variables |\n\n**Sources:** [CMakeLists.txt:1-9](), [CMakeLists.txt:104-108](), [build.zsh:62-74]()\n\n### Missing Dependencies\n\nRun the dependency checker to identify missing packages:\n\n```bash\n./build.zsh check-deps\n```\n\nOutput format:\n```\n cmake\n qt6-base\n Missing: projectm ffmpeg\n    sudo pacman -S projectm ffmpeg\n```\n\n**Sources:** [build.zsh:158-179]()\n\n### Runtime Issues\n\nIf the application fails to start:\n\n1. **OpenGL errors**: Verify GPU driver supports OpenGL 3.3+\n2. **Config errors**: Check `~/.config/chadvis-projectm-qt/config.toml` is valid TOML\n3. **Preset loading**: Ensure `visualizer.preset_path` points to valid `.milk` files\n4. **Library loading**: If using local projectM, verify `LD_LIBRARY_PATH` includes `external/projectm-install/lib`\n\n**Sources:** [CMakeLists.txt:79-81]()\n\n---\n\n## Installation\n\n### System-Wide Installation\n\nTo install the binary and resources system-wide:\n\n```bash\ncd build\nsudo cmake --install .\n```\n\nThis installs:\n- Binary: `/usr/local/bin/chadvis-projectm-qt`\n- Config templates: `/usr/local/share/chadvis-projectm-qt/config/`\n- Desktop entry: `/usr/local/share/applications/chadvis-projectm-qt.desktop`\n- Icon: `/usr/local/share/icons/hicolor/scalable/apps/chadvis-projectm-qt.svg`\n\n**Sources:** [CMakeLists.txt:272-276]()\n\n### Packaging\n\nThe project includes CPack configuration for creating distribution packages:\n\n```bash\ncd build\ncpack\n```\n\nGenerates a package named `chadvis-projectm-qt-1.0.0` with appropriate metadata.\n\n**Sources:** [CMakeLists.txt:278-281]()"])</script><script>self.__next_f.push([1,"1a:T2fc8,"])</script><script>self.__next_f.push([1,"# Core Systems\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AGENTS.md](AGENTS.md)\n- [src/core/Config.cpp](src/core/Config.cpp)\n- [src/recorder/VideoRecorder.cpp](src/recorder/VideoRecorder.cpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document provides an overview of the foundational infrastructure layer that underpins the entire chadvis-projectm-qt application. These core systemsthe **Application singleton**, **Config system**, and **Logger**are designed to be universally accessible and provide cross-cutting concerns such as application lifecycle management, persistent configuration, and diagnostic output.\n\nFor detailed implementation information about the Application singleton and Config system internals, see [Application \u0026 Config](#2.1). For information about build system configuration and dependency management, see [Build System \u0026 Dependencies](#2.2).\n\n---\n\n## System Overview\n\nThe core systems form a foundational layer that all other modules depend on. They are implemented as singletons to provide global access without explicit dependency injection, following a pragmatic approach to managing cross-cutting concerns in a desktop application.\n\n### Core Components\n\n| Component | Primary Class | Access Pattern | Purpose |\n|-----------|---------------|----------------|---------|\n| **Application** | `Application` | `Application::instance()` | Singleton entry point; owns and orchestrates all engines (audio, video, overlay) |\n| **Config** | `Config` | `CONFIG` macro | Thread-safe TOML-based configuration with dirty tracking and atomic saves |\n| **Logger** | N/A (macro-based) | `LOG_INFO()`, `LOG_DEBUG()`, etc. | Structured diagnostic output with multiple severity levels |\n\n---\n\n## Architecture Diagram\n\n```mermaid\ngraph TB\n    subgraph \"Core Systems Layer\"\n        APP[\"Application\u003cbr/\u003e(src/core/Application.hpp)\u003cbr/\u003einstance()\"]\n        CONFIG[\"Config\u003cbr/\u003e(src/core/Config.hpp)\u003cbr/\u003einstance()\"]\n        LOGGER[\"Logger\u003cbr/\u003e(src/core/Logger.hpp)\u003cbr/\u003eLOG_* macros\"]\n    end\n    \n    subgraph \"Persistent Storage\"\n        TOML[\"config.toml\u003cbr/\u003e~/.config/chadvis-projectm-qt/\"]\n        DEFAULT[\"default.toml\u003cbr/\u003econfig/default.toml\"]\n    end\n    \n    subgraph \"Application Modules\"\n        AUDIO[\"AudioEngine\"]\n        VIDEO[\"VideoRecorder\"]\n        VIZ[\"VisualizerWindow\"]\n        OVERLAY[\"OverlayEngine\"]\n        UI[\"MainWindow + Controllers\"]\n    end\n    \n    APP --\u003e|\"owns\"| AUDIO\n    APP --\u003e|\"owns\"| VIDEO\n    APP --\u003e|\"owns\"| OVERLAY\n    \n    CONFIG \u003c--\u003e|\"load()/save()\"| TOML\n    CONFIG \u003c-.-\u003e|\"loadDefault()\"| DEFAULT\n    \n    AUDIO --\u003e|\"CONFIG.audio()\"| CONFIG\n    VIDEO --\u003e|\"CONFIG.recording()\"| CONFIG\n    VIZ --\u003e|\"CONFIG.visualizer()\"| CONFIG\n    UI --\u003e|\"CONFIG.ui()\"| CONFIG\n    \n    AUDIO -.-\u003e|\"LOG_INFO()\"| LOGGER\n    VIDEO -.-\u003e|\"LOG_DEBUG()\"| LOGGER\n    CONFIG -.-\u003e|\"LOG_WARN()\"| LOGGER\n    APP -.-\u003e|\"LOG_ERROR()\"| LOGGER\n```\n\n**Sources:** [src/core/Config.cpp:1-460](), [AGENTS.md:80-86]()\n\n---\n\n## Application Singleton\n\nThe `Application` class serves as the single entry point and orchestrator for the entire application. It follows the singleton pattern and is responsible for:\n\n- **Lifecycle management**: Initialization, event loop execution, and shutdown\n- **Engine ownership**: Owns instances of `AudioEngine`, `VideoRecorder`, and `OverlayEngine`\n- **Cross-engine coordination**: Routes signals between engines and UI components\n- **Resource cleanup**: Ensures proper shutdown order and resource deallocation\n\nAccess pattern:\n```cpp\nApplication\u0026 app = Application::instance();\n```\n\nThe Application is constructed once in `main()` and destroyed upon application exit. Other components obtain references to engines through the Application singleton when needed.\n\n**Sources:** [AGENTS.md:80-86]()\n\n---\n\n## Config System Architecture\n\nThe Config system provides centralized, persistent application settings with the following characteristics:\n\n### Design Features\n\n- **Singleton pattern**: Single global instance accessed via `CONFIG` macro\n- **Thread-safe**: All operations protected by `std::mutex`\n- **Dirty tracking**: Optimizes file writes by tracking modifications\n- **Atomic saves**: Uses temporary file + rename for safe persistence\n- **TOML format**: Human-readable configuration files\n- **Type-safe sections**: Separate structs for each configuration domain\n\n### Configuration Sections\n\n```mermaid\ngraph TB\n    CONFIG[\"Config Singleton\"]\n    \n    subgraph \"Configuration Sections\"\n        AUDIO[\"AudioConfig\u003cbr/\u003edevice, bufferSize, sampleRate\"]\n        VIZ[\"VisualizerConfig\u003cbr/\u003epresetPath, width, height, fps\"]\n        REC[\"RecordingConfig\u003cbr/\u003eoutputDirectory, container\"]\n        UI[\"UIConfig\u003cbr/\u003etheme, showPlaylist, accentColor\"]\n        KB[\"KeyboardConfig\u003cbr/\u003eplayPause, nextTrack, etc.\"]\n        SUNO[\"SunoConfig\u003cbr/\u003etoken, cookie, downloadPath\"]\n        OVERLAY[\"vector\u0026lt;OverlayElementConfig\u0026gt;\u003cbr/\u003etext overlays\"]\n    end\n    \n    subgraph \"Nested Structures\"\n        VID_ENC[\"VideoEncoderConfig\u003cbr/\u003ecodec, crf, preset, width, height\"]\n        AUD_ENC[\"AudioEncoderConfig\u003cbr/\u003ecodec, bitrate, sampleRate\"]\n    end\n    \n    CONFIG --\u003e AUDIO\n    CONFIG --\u003e VIZ\n    CONFIG --\u003e REC\n    CONFIG --\u003e UI\n    CONFIG --\u003e KB\n    CONFIG --\u003e SUNO\n    CONFIG --\u003e OVERLAY\n    \n    REC --\u003e VID_ENC\n    REC --\u003e AUD_ENC\n```\n\n**Sources:** [src/core/Config.cpp:173-329]()\n\n### File Operations Flow\n\n```mermaid\nsequenceDiagram\n    participant App as \"Application\"\n    participant Cfg as \"Config::instance()\"\n    participant FS as \"File System\"\n    \n    App-\u003e\u003eCfg: \"loadDefault()\"\n    Cfg-\u003e\u003eFS: \"Check ~/.config/chadvis-projectm-qt/config.toml\"\n    alt \"File exists\"\n        FS--\u003e\u003eCfg: \"Found\"\n        Cfg-\u003e\u003eCfg: \"load(path)\"\n        Cfg-\u003e\u003eFS: \"toml::parse_file()\"\n        Cfg-\u003e\u003eCfg: \"parseAudio(), parseVisualizer(), etc.\"\n    else \"File missing\"\n        FS--\u003e\u003eCfg: \"Not found\"\n        Cfg-\u003e\u003eFS: \"Check /usr/share/.../default.toml\"\n        alt \"System default exists\"\n            Cfg-\u003e\u003eFS: \"Copy to user dir\"\n        else \"Project default exists\"\n            Cfg-\u003e\u003eFS: \"Copy config/default.toml\"\n        else \"No defaults\"\n            Cfg-\u003e\u003eCfg: \"Use built-in defaults\"\n        end\n        Cfg-\u003e\u003eCfg: \"save(defaultPath)\"\n    end\n    \n    Note over App,FS: \"Later modifications...\"\n    App-\u003e\u003eCfg: \"CONFIG.setDebug(true)\"\n    Cfg-\u003e\u003eCfg: \"markDirty()\"\n    App-\u003e\u003eCfg: \"save()\"\n    Cfg-\u003e\u003eFS: \"Write to .tmp file\"\n    Cfg-\u003e\u003eFS: \"rename(.tmp -\u003e config.toml)\"\n```\n\n**Sources:** [src/core/Config.cpp:82-141](), [src/core/Config.cpp:143-171]()\n\n### Access Pattern\n\nThe `CONFIG` macro provides global access without explicit dependency injection:\n\n```cpp\n// Reading configuration\nu32 bufferSize = CONFIG.audio().bufferSize;\nfs::path presetPath = CONFIG.visualizer().presetPath;\n\n// Modifying configuration\nCONFIG.setDebug(true);\nCONFIG.addOverlayElement(overlayConfig);\n\n// Persistence\nauto result = CONFIG.save();\nif (!result) {\n    LOG_ERROR(\"Failed to save config: {}\", result.error().message);\n}\n```\n\nThis approach trades compile-time dependency tracking for runtime convenience, which is appropriate for global configuration that virtually all modules need to access.\n\n**Sources:** [AGENTS.md:80](), [src/core/Config.cpp:47-50]()\n\n---\n\n## Logger System\n\nThe Logger provides structured diagnostic output through a set of convenience macros. It is designed for simplicity and zero-overhead when logging is disabled.\n\n### Logging Levels\n\n| Macro | Level | Use Case |\n|-------|-------|----------|\n| `LOG_TRACE()` | Trace | Fine-grained debugging (hot paths) |\n| `LOG_DEBUG()` | Debug | Development diagnostics |\n| `LOG_INFO()` | Info | Normal operational messages |\n| `LOG_WARN()` | Warn | Recoverable errors or unusual conditions |\n| `LOG_ERROR()` | Error | Serious failures requiring attention |\n\n### Usage Pattern\n\n```cpp\nLOG_INFO(\"Config loaded from: {}\", path.string());\nLOG_DEBUG(\"FFmpeg initialized successfully\");\nLOG_WARN(\"Audio codec not found: {}, skipping audio\", codecName);\nLOG_ERROR(\"Failed to create output context: {}\", errorMsg);\n```\n\nThe logger uses `spdlog` internally and supports format-string style arguments for type-safe message construction. All logging operations are thread-safe.\n\n**Sources:** [AGENTS.md:68-69](), [src/core/Config.cpp:73](), [src/core/Config.cpp:199]()\n\n---\n\n## Integration with Application Modules\n\nThe core systems are designed to be universally accessible and provide services to all application modules without requiring explicit dependency injection.\n\n### Typical Usage Pattern\n\n```mermaid\ngraph LR\n    MODULE[\"Any Module\u003cbr/\u003e(e.g., VideoRecorder)\"]\n    \n    MODULE --\u003e|\"1. Access config\"| CONFIG_ACCESS[\"CONFIG.recording()\"]\n    MODULE --\u003e|\"2. Validate settings\"| VALIDATE[\"settings.validate()\"]\n    MODULE --\u003e|\"3. Log operations\"| LOG[\"LOG_INFO/DEBUG/WARN\"]\n    MODULE --\u003e|\"4. Report errors\"| ERROR_LOG[\"LOG_ERROR()\"]\n    MODULE --\u003e|\"5. Update config\"| CONFIG_WRITE[\"CONFIG.markDirty()\"]\n    \n    CONFIG_ACCESS --\u003e|\"Returns\"| SETTINGS[\"RecordingConfig\"]\n    SETTINGS --\u003e|\"Used by\"| OPERATIONS[\"Module Operations\"]\n```\n\n**Sources:** [src/recorder/VideoRecorder.cpp:2-3](), [src/recorder/VideoRecorder.cpp:68-70]()\n\n### Example: VideoRecorder Integration\n\nThe `VideoRecorder` demonstrates typical core system usage:\n\n1. **Configuration access**: [src/recorder/VideoRecorder.cpp:68-70]()\n   - Calls `EncoderSettings::fromConfig()` which internally uses `CONFIG.recording()`\n   \n2. **Logging operations**: [src/recorder/VideoRecorder.cpp:63](), [src/recorder/VideoRecorder.cpp:106-108]()\n   - Logs start/stop events and statistics\n   \n3. **Error reporting**: [src/recorder/VideoRecorder.cpp:542-544]()\n   - Uses `LOG_WARN()` for recoverable errors during encoding\n\nThis pattern is replicated across all major modules: `AudioEngine`, `VisualizerWindow`, `ProjectMBridge`, `OverlayEngine`, and UI controllers.\n\n**Sources:** [src/recorder/VideoRecorder.cpp:1-639]()\n\n---\n\n## File Structure and Locations\n\n### Source Files\n\n| Path | Purpose |\n|------|---------|\n| `src/core/Application.hpp` | Application singleton declaration |\n| `src/core/Application.cpp` | Application implementation and engine ownership |\n| `src/core/Config.hpp` | Config singleton declaration and section structs |\n| `src/core/Config.cpp` | TOML parsing, serialization, and file I/O |\n| `src/core/Logger.hpp` | Logger macros and initialization |\n\n### Configuration Files\n\n| Path | Purpose |\n|------|---------|\n| `~/.config/chadvis-projectm-qt/config.toml` | User configuration (runtime) |\n| `/usr/share/chadvis-projectm-qt/config/default.toml` | System-wide default (installed) |\n| `config/default.toml` | Project default (source tree) |\n\nThe Config system implements a fallback chain: user config  system default  project default  built-in defaults. This ensures the application can always run even without any configuration files present.\n\n**Sources:** [src/core/Config.cpp:82-141]()\n\n---\n\n## Thread Safety Considerations\n\nBoth `Application` and `Config` singletons are thread-safe:\n\n- **Config**: All public methods acquire `std::lock_guard\u003cstd::mutex\u003e` on `mutex_` [src/core/Config.cpp:53]()\n- **Logger**: Thread-safety provided by underlying `spdlog` implementation\n- **Application**: Engine access is single-threaded (main thread only), but engines themselves may spawn worker threads\n\nThe `CONFIG` macro is safe to call from any thread, but modifications should generally be made from the main thread to avoid race conditions in UI updates.\n\n**Sources:** [src/core/Config.cpp:53](), [src/core/Config.cpp:144](), [src/core/Config.cpp:439]()\n\n---\n\n## Error Handling\n\nAll core systems use the `Result\u003cT\u003e` type for fallible operations:\n\n```cpp\nResult\u003cvoid\u003e Config::load(const fs::path\u0026 path);\nResult\u003cvoid\u003e Config::save(const fs::path\u0026 path) const;\n```\n\nErrors are logged immediately using the Logger, and then propagated to callers for handling:\n\n```cpp\nif (auto result = CONFIG.save(path); !result) {\n    LOG_WARN(\"Failed to save config: {}\", result.error().message);\n    // Handle error...\n}\n```\n\nThis pattern is consistent across the entire codebase and avoids the use of exceptions.\n\n**Sources:** [src/core/Config.cpp:52-80](), [src/core/Config.cpp:143-171](), [AGENTS.md:54-65]()"])</script><script>self.__next_f.push([1,"1b:T3ead,"])</script><script>self.__next_f.push([1,"# Application \u0026 Config\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [CMakeLists.txt](CMakeLists.txt)\n- [src/core/Config.cpp](src/core/Config.cpp)\n- [src/core/Config.hpp](src/core/Config.hpp)\n- [src/recorder/VideoRecorder.cpp](src/recorder/VideoRecorder.cpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document covers the **core application infrastructure**: the `Application` singleton that serves as the entry point and engine owner, and the `Config` system that provides TOML-based configuration management with global access. These two components form the foundation of the codebase's architecture.\n\nFor information about the build system and dependencies, see [Build System \u0026 Dependencies](#2.2). For details about the Logger system, see [Overview](#2) (Core Systems section).\n\n**Sources:** [CMakeLists.txt:119-126](), [src/core/Config.hpp:1-237](), [src/core/Config.cpp:1-460]()\n\n---\n\n## Application Singleton\n\nThe `Application` class serves as the **main entry point** and **ownership root** for all engine subsystems. It follows the singleton pattern to ensure a single application instance exists throughout the program lifecycle.\n\n### Ownership Model\n\nAccording to the high-level architecture (Diagram 1), the Application singleton owns:\n- `AudioEngine` - handles audio playback and analysis\n- `VideoRecorder` - manages video recording\n- `OverlayEngine` - text overlay rendering\n\nThe Application also accesses (but does not own):\n- `Config` singleton - configuration data\n- `Logger` singleton - diagnostic output\n\nThis ownership model ensures clear resource management: when the Application is destroyed, all engines are properly cleaned up in reverse dependency order.\n\n**Diagram: Application Ownership Structure**\n\n```mermaid\ngraph TB\n    subgraph \"Application Singleton\"\n        APP[\"Application\u003cbr/\u003e(Entry Point)\"]\n    end\n    \n    subgraph \"Owned Engines\"\n        AE[\"AudioEngine\u003cbr/\u003e(unique_ptr)\"]\n        VR[\"VideoRecorder\u003cbr/\u003e(unique_ptr)\"]\n        OE[\"OverlayEngine\u003cbr/\u003e(unique_ptr)\"]\n    end\n    \n    subgraph \"Accessed Singletons\"\n        CFG[\"Config::instance()\"]\n        LOG[\"Logger::instance()\"]\n    end\n    \n    APP --\u003e|\"owns\"| AE\n    APP --\u003e|\"owns\"| VR\n    APP --\u003e|\"owns\"| OE\n    APP -.-\u003e|\"accesses\"| CFG\n    APP -.-\u003e|\"accesses\"| LOG\n    \n    AE -.-\u003e|\"CONFIG macro\"| CFG\n    VR -.-\u003e|\"CONFIG macro\"| CFG\n    OE -.-\u003e|\"CONFIG macro\"| CFG\n```\n\n**Sources:** [CMakeLists.txt:124-125]()\n\n---\n\n## Config System Architecture\n\nThe `Config` class implements a **thread-safe singleton** that manages all application settings using the **toml++** library for TOML file parsing and serialization.\n\n### Singleton Pattern\n\nThe Config singleton is accessed via a static method and a convenience macro:\n\n```cpp\n// Direct access\nConfig\u0026 cfg = Config::instance();\n\n// Via macro (used throughout codebase)\nconst auto\u0026 vizConfig = CONFIG.visualizer();\n```\n\nThe `CONFIG` macro is defined in [src/core/Config.hpp:234]() as:\n```cpp\n#define CONFIG vc::Config::instance()\n```\n\nThis macro provides global access without requiring dependency injection, simplifying code that needs to read configuration values.\n\n### Thread Safety\n\nAll Config methods use a `std::mutex` to ensure thread-safe access. The mutex is declared as [src/core/Config.hpp:230]():\n```cpp\nmutable std::mutex mutex_;\n```\n\nLock guards protect critical sections in:\n- `load()` [src/core/Config.cpp:53]()\n- `save()` [src/core/Config.cpp:144]()\n- `addOverlayElement()` [src/core/Config.cpp:439]()\n- `removeOverlayElement()` [src/core/Config.cpp:445]()\n\n### Dirty Tracking\n\nThe Config system implements dirty tracking to optimize saves. When any mutable accessor is called, `markDirty()` is invoked [src/core/Config.hpp:202-204]():\n\n```cpp\nvoid markDirty() { dirty_ = true; }\n```\n\nThis allows the application to check `isDirty()` [src/core/Config.hpp:193-198]() before performing potentially expensive file writes.\n\n**Diagram: Config Class Structure**\n\n```mermaid\nclassDiagram\n    class Config {\n        -mutex_ : mutex\n        -dirty_ : bool\n        -debug_ : bool\n        -configPath_ : fs::path\n        -audio_ : AudioConfig\n        -visualizer_ : VisualizerConfig\n        -recording_ : RecordingConfig\n        -ui_ : UIConfig\n        -keyboard_ : KeyboardConfig\n        -suno_ : SunoConfig\n        -overlayElements_ : vector~OverlayElementConfig~\n        +instance() Config\u0026\n        +load(path) Result~void~\n        +save(path) Result~void~\n        +loadDefault() Result~void~\n        +audio() AudioConfig\u0026\n        +visualizer() VisualizerConfig\u0026\n        +recording() RecordingConfig\u0026\n        +ui() UIConfig\u0026\n        +keyboard() KeyboardConfig\u0026\n        +suno() SunoConfig\u0026\n        +overlayElements() vector\u0026\n        +isDirty() bool\n        +markClean() void\n        -parseAudio(tbl) void\n        -parseVisualizer(tbl) void\n        -parseRecording(tbl) void\n        -parseOverlay(tbl) void\n        -parseUI(tbl) void\n        -parseKeyboard(tbl) void\n        -parseSuno(tbl) void\n        -serialize() toml::table\n    }\n```\n\n**Sources:** [src/core/Config.hpp:109-231](), [src/core/Config.cpp:47-50]()\n\n---\n\n## Configuration Sections\n\nThe Config system organizes settings into logical sections, each represented by a dedicated struct. All sections are defined in [src/core/Config.hpp:14-107]().\n\n### Section Overview\n\n| Section | Struct | Purpose | Key Settings |\n|---------|--------|---------|--------------|\n| Audio | `AudioConfig` | Audio backend configuration | device, bufferSize, sampleRate |\n| Visualizer | `VisualizerConfig` | Visualization rendering | presetPath, width, height, fps, beatSensitivity |\n| Recording | `RecordingConfig` | Video recording settings | outputDirectory, container, nested video/audio configs |\n| UI | `UIConfig` | User interface preferences | theme, showPlaylist, backgroundColor, accentColor |\n| Keyboard | `KeyboardConfig` | Keyboard shortcuts | playPause, nextTrack, toggleRecord, etc. |\n| Suno | `SunoConfig` | Suno AI integration | token, cookie, downloadPath, autoDownload |\n| Overlay | `vector\u003cOverlayElementConfig\u003e` | Text overlay elements | Dynamic list of overlay configurations |\n\n### Nested Configuration\n\nThe `RecordingConfig` contains nested encoder configurations [src/core/Config.hpp:46-54]():\n\n```cpp\nstruct RecordingConfig {\n    bool enabled{true};\n    bool autoRecord{false};\n    fs::path outputDirectory;\n    std::string defaultFilename{\"chadvis-projectm-qt_{date}_{time}\"};\n    std::string container{\"mp4\"};\n    VideoEncoderConfig video;  // Nested\n    AudioEncoderConfig audio;  // Nested\n};\n```\n\nThis nesting mirrors the TOML file structure:\n```toml\n[recording]\nenabled = true\noutput_directory = \"~/Videos/ChadVis\"\n\n[recording.video]\ncodec = \"libx264\"\ncrf = 23\nwidth = 1920\nheight = 1080\n\n[recording.audio]\ncodec = \"aac\"\nbitrate = 192\n```\n\n**Diagram: Configuration Section Hierarchy**\n\n```mermaid\ngraph TB\n    CFG[\"Config Singleton\"]\n    \n    subgraph \"Config Sections\"\n        AUDIO[\"AudioConfig\u003cbr/\u003edevice, bufferSize, sampleRate\"]\n        VIZ[\"VisualizerConfig\u003cbr/\u003epresetPath, width, height, fps\"]\n        REC[\"RecordingConfig\u003cbr/\u003eoutputDirectory, container\"]\n        UI[\"UIConfig\u003cbr/\u003etheme, colors, visibility\"]\n        KB[\"KeyboardConfig\u003cbr/\u003ekey bindings\"]\n        SUNO[\"SunoConfig\u003cbr/\u003etoken, cookie, paths\"]\n        OVL[\"vector\u0026lt;OverlayElementConfig\u0026gt;\u003cbr/\u003edynamic overlay elements\"]\n    end\n    \n    subgraph \"Nested Configs\"\n        VID[\"VideoEncoderConfig\u003cbr/\u003ecodec, crf, preset, fps\"]\n        AUD[\"AudioEncoderConfig\u003cbr/\u003ecodec, bitrate\"]\n    end\n    \n    CFG --\u003e AUDIO\n    CFG --\u003e VIZ\n    CFG --\u003e REC\n    CFG --\u003e UI\n    CFG --\u003e KB\n    CFG --\u003e SUNO\n    CFG --\u003e OVL\n    \n    REC --\u003e VID\n    REC --\u003e AUD\n```\n\n**Sources:** [src/core/Config.hpp:14-107](), [src/core/Config.cpp:173-329]()\n\n---\n\n## File Locations and Loading\n\n### Configuration File Paths\n\nThe Config system searches for configuration files in multiple locations, with a defined fallback order:\n\n1. **User Config Directory:** `~/.config/chadvis-projectm-qt/config.toml`\n2. **System Installation:** `/usr/share/chadvis-projectm-qt/config/default.toml`\n3. **Project Source Tree:** `config/default.toml` (development)\n\nThe `loadDefault()` method implements this search order [src/core/Config.cpp:82-141]().\n\n### Load Process\n\n**Diagram: Configuration Loading Flow**\n\n```mermaid\nflowchart TD\n    START[\"Config::loadDefault()\"]\n    \n    USER_PATH[\"Check user config\u003cbr/\u003e~/.config/chadvis-projectm-qt/config.toml\"]\n    USER_EXISTS{{\"File exists?\"}}\n    LOAD_USER[\"load(userPath)\"]\n    \n    SYS_PATH[\"Check system default\u003cbr/\u003e/usr/share/chadvis-projectm-qt/config/default.toml\"]\n    SYS_EXISTS{{\"File exists?\"}}\n    COPY_SYS[\"Copy to user directory\"]\n    LOAD_SYS[\"load(userPath)\"]\n    \n    PROJ_PATH[\"Check project source\u003cbr/\u003econfig/default.toml\"]\n    PROJ_EXISTS{{\"File exists?\"}}\n    COPY_PROJ[\"Copy to user directory\"]\n    LOAD_PROJ[\"load(userPath)\"]\n    \n    BUILT_IN[\"Use built-in defaults\u003cbr/\u003eSet sensible defaults\"]\n    SAVE_DEFAULT[\"save(userPath)\"]\n    \n    SUCCESS[\"Config loaded\"]\n    \n    START --\u003e USER_PATH\n    USER_PATH --\u003e USER_EXISTS\n    USER_EXISTS --\u003e|\"Yes\"| LOAD_USER\n    LOAD_USER --\u003e SUCCESS\n    \n    USER_EXISTS --\u003e|\"No\"| SYS_PATH\n    SYS_PATH --\u003e SYS_EXISTS\n    SYS_EXISTS --\u003e|\"Yes\"| COPY_SYS\n    COPY_SYS --\u003e LOAD_SYS\n    LOAD_SYS --\u003e SUCCESS\n    \n    SYS_EXISTS --\u003e|\"No\"| PROJ_PATH\n    PROJ_PATH --\u003e PROJ_EXISTS\n    PROJ_EXISTS --\u003e|\"Yes\"| COPY_PROJ\n    COPY_PROJ --\u003e LOAD_PROJ\n    LOAD_PROJ --\u003e SUCCESS\n    \n    PROJ_EXISTS --\u003e|\"No\"| BUILT_IN\n    BUILT_IN --\u003e SAVE_DEFAULT\n    SAVE_DEFAULT --\u003e SUCCESS\n```\n\n**Sources:** [src/core/Config.cpp:82-141]()\n\n### Path Expansion\n\nThe Config system supports `~` expansion for home directory paths [src/core/Config.cpp:35-43]():\n\n```cpp\nfs::path expandPath(std::string_view path) {\n    std::string p(path);\n    if (p.starts_with(\"~/\")) {\n        if (const char* home = std::getenv(\"HOME\")) {\n            p = std::string(home) + p.substr(1);\n        }\n    }\n    return fs::path(p);\n}\n```\n\nThis allows users to write portable paths in TOML files:\n```toml\noutput_directory = \"~/Videos/ChadVis\"\n```\n\n### TOML Parsing\n\nThe `load()` method uses toml++ to parse configuration files [src/core/Config.cpp:52-80]():\n\n```cpp\nResult\u003cvoid\u003e Config::load(const fs::path\u0026 path) {\n    std::lock_guard lock(mutex_);\n    \n    try {\n        auto tbl = toml::parse_file(path.string());\n        configPath_ = path;\n        \n        // Parse each section\n        parseAudio(tbl);\n        parseVisualizer(tbl);\n        parseRecording(tbl);\n        parseOverlay(tbl);\n        parseUI(tbl);\n        parseKeyboard(tbl);\n        parseSuno(tbl);\n        \n        dirty_ = false;\n        return Result\u003cvoid\u003e::ok();\n    } catch (const toml::parse_error\u0026 err) {\n        return Result\u003cvoid\u003e::err(std::string(\"Config parse error: \") + err.what());\n    }\n}\n```\n\nEach `parse*()` method extracts values from the TOML table with defaults for missing keys. For example, `parseAudio()` [src/core/Config.cpp:173-179]():\n\n```cpp\nvoid Config::parseAudio(const toml::table\u0026 tbl) {\n    if (auto audio = tbl[\"audio\"].as_table()) {\n        audio_.device = get(*audio, \"device\", std::string(\"default\"));\n        audio_.bufferSize = get(*audio, \"buffer_size\", 2048u);\n        audio_.sampleRate = get(*audio, \"sample_rate\", 44100u);\n    }\n}\n```\n\n**Sources:** [src/core/Config.cpp:52-80](), [src/core/Config.cpp:173-329]()\n\n---\n\n## Atomic File Saving\n\nThe Config system implements **atomic writes** to prevent corruption from partial writes or crashes [src/core/Config.cpp:143-171]():\n\n### Save Process\n\n1. Serialize configuration to `toml::table` [src/core/Config.cpp:331-436]()\n2. Write to temporary file: `config.toml.tmp`\n3. Atomically rename temp file to actual path\n4. Filesystem ensures atomicity of rename operation\n\n**Diagram: Atomic Save Process**\n\n```mermaid\nsequenceDiagram\n    participant App as Application\n    participant Cfg as Config\n    participant FS as Filesystem\n    \n    App-\u003e\u003eCfg: save(path)\n    activate Cfg\n    \n    Cfg-\u003e\u003eCfg: serialize()  toml::table\n    Note over Cfg: Convert all config sections\u003cbr/\u003eto TOML representation\n    \n    Cfg-\u003e\u003eFS: open(path + \".tmp\")\n    FS--\u003e\u003eCfg: temp file handle\n    \n    Cfg-\u003e\u003eFS: write(toml::table)\n    Note over FS: Write complete config\u003cbr/\u003eto temporary file\n    \n    Cfg-\u003e\u003eFS: fs::rename(temp, path)\n    Note over FS: Atomic operation\u003cbr/\u003ereplaces old config\n    \n    FS--\u003e\u003eCfg: success\n    deactivate Cfg\n    Cfg--\u003e\u003eApp: Result::ok()\n```\n\nThe key code [src/core/Config.cpp:149-164]():\n\n```cpp\n// Atomic write: write to temp file, then rename\nfs::path tempPath = path;\ntempPath += \".tmp\";\n\n{\n    std::ofstream file(tempPath);\n    if (!file) {\n        return Result\u003cvoid\u003e::err(\"Failed to open temp config file for writing\");\n    }\n    file \u003c\u003c tbl;\n}\n\n// Rename is atomic on most filesystems\nfs::rename(tempPath, path);\n```\n\n**Sources:** [src/core/Config.cpp:143-171]()\n\n---\n\n## Global Access Pattern\n\nThe codebase uses the `CONFIG` macro extensively to access configuration without explicit dependency injection.\n\n### Usage Examples\n\nFrom [src/recorder/VideoRecorder.cpp:68]():\n```cpp\nResult\u003cvoid\u003e VideoRecorder::start(const fs::path\u0026 outputPath) {\n    auto settings = EncoderSettings::fromConfig();  // Uses CONFIG internally\n    settings.outputPath = outputPath;\n    return start(settings);\n}\n```\n\nModules read configuration directly:\n```cpp\n// Read visualizer settings\nu32 width = CONFIG.visualizer().width;\nu32 height = CONFIG.visualizer().height;\nu32 fps = CONFIG.visualizer().fps;\n\n// Read recording settings\nfs::path outputDir = CONFIG.recording().outputDirectory;\n```\n\nModify settings and mark dirty:\n```cpp\n// Mutable access automatically marks dirty\nCONFIG.visualizer().fps = 60;\nCONFIG.recording().autoRecord = true;\n\n// Check if save needed\nif (CONFIG.isDirty()) {\n    CONFIG.save(CONFIG.configPath());\n    CONFIG.markClean();\n}\n```\n\n### Configuration Section Accessors\n\nThe Config class provides both const and mutable accessors for each section [src/core/Config.hpp:133-177]():\n\n```cpp\n// Const accessors (read-only, no dirty marking)\nconst AudioConfig\u0026 audio() const { return audio_; }\nconst VisualizerConfig\u0026 visualizer() const { return visualizer_; }\n\n// Mutable accessors (mark dirty on access)\nAudioConfig\u0026 audio() { markDirty(); return audio_; }\nVisualizerConfig\u0026 visualizer() { markDirty(); return visualizer_; }\n```\n\nThis design automatically tracks modifications without requiring explicit dirty flag management.\n\n**Sources:** [src/core/Config.hpp:133-177](), [src/core/Config.hpp:234](), [src/recorder/VideoRecorder.cpp:67-71]()\n\n---\n\n## Configuration Validation\n\nIndividual config sections implement validation where needed. For example, the visualizer config clamps values to safe ranges [src/core/Config.cpp:187-203]():\n\n```cpp\nvisualizer_.width = std::clamp(get(*viz, \"width\", 1280u), 320u, 7680u);\nvisualizer_.height = std::clamp(get(*viz, \"height\", 720u), 200u, 4320u);\nvisualizer_.fps = std::clamp(get(*viz, \"fps\", 30u), 10u, 240u);\nvisualizer_.beatSensitivity = std::clamp(get(*viz, \"beat_sensitivity\", 1.0f), 0.1f, 10.0f);\n```\n\nThe recording config ensures FFmpeg-compatible dimensions (must be even) [src/core/Config.cpp:228-236]():\n\n```cpp\nu32 w = std::clamp(get(*video, \"width\", 1280u), 320u, 7680u);\nif (w % 2 != 0) w++;  // FFmpeg H.264 likes even dimensions\nrecording_.video.width = w;\n\nu32 h = std::clamp(get(*video, \"height\", 720u), 200u, 4320u);\nif (h % 2 != 0) h++;\nrecording_.video.height = h;\n```\n\n**Sources:** [src/core/Config.cpp:181-248]()\n\n---\n\n## Dependencies\n\nThe Config system depends on:\n\n| Dependency | Purpose | CMake Reference |\n|------------|---------|-----------------|\n| toml++ | TOML parsing and serialization | [CMakeLists.txt:66]() |\n| filesystem | Path operations and file I/O | C++17 standard library |\n| mutex | Thread-safe access | C++11 standard library |\n\nThe toml++ library is discovered via pkg-config:\n```cmake\npkg_check_modules(TOMLPP REQUIRED tomlplusplus)\n```\n\n**Sources:** [CMakeLists.txt:66](), [src/core/Config.hpp:5]()"])</script><script>self.__next_f.push([1,"1c:T4a59,"])</script><script>self.__next_f.push([1,"# Build System \u0026 Dependencies\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [.gitignore](.gitignore)\n- [CMakeLists.txt](CMakeLists.txt)\n- [build.zsh](build.zsh)\n- [src/core/Config.hpp](src/core/Config.hpp)\n- [src/overlay/OverlayRenderer.cpp](src/overlay/OverlayRenderer.cpp)\n\n\u003c/details\u003e\n\n\n\nThis document describes the CMake-based build system for chadvis-projectm-qt, including dependency discovery mechanisms, compiler flag management, source file organization, and the convenience build script. The build system targets C++20 with Qt6 and projectM v4 as primary dependencies.\n\nFor information about the Application singleton and Config system that loads at runtime, see [Application \u0026 Config](#2.1). For details on how individual systems are implemented, refer to their respective sections: [Audio System](#3), [Visualization System](#4), [Recording System](#5).\n\n---\n\n## Build Tools \u0026 Requirements\n\nThe project uses CMake 3.20+ as its build system generator with Ninja as the recommended backend. The build configuration enforces C++20 standard compliance and enables Qt's meta-object compiler (MOC), resource compiler (RCC), and UI compiler (UIC) automation.\n\n**Required Tools:**\n- CMake 3.20 or higher\n- Ninja build system (recommended) or Make\n- GCC/G++ with C++20 support\n- pkg-config for dependency discovery\n\n**Core Dependencies:**\n- **Qt6** (6.x): Core, Gui, Widgets, Multimedia, OpenGLWidgets, Svg, Network, Sql\n- **projectM v4**: Visualization library (local build or system package)\n- **FFmpeg**: libavcodec, libavformat, libavutil, libswscale, libswresample\n- **spdlog**: Logging framework\n- **fmt**: String formatting\n- **taglib**: Audio metadata parsing\n- **tomlplusplus**: TOML configuration parsing\n- **GLEW**: OpenGL extension wrangler\n- **glm**: OpenGL mathematics library\n\nSources: [CMakeLists.txt:1-31](), [build.zsh:158-179]()\n\n---\n\n## CMake Configuration Structure\n\n### Build Type \u0026 Compiler Standards\n\nThe CMake configuration sets C++20 as the required standard and defaults to Release build type if not specified. It explicitly removes problematic compiler flags that cause build failures on certain systems.\n\n```cmake\n# Key configuration settings\nCMAKE_CXX_STANDARD = 20\nCMAKE_CXX_STANDARD_REQUIRED = ON\nCMAKE_EXPORT_COMPILE_COMMANDS = ON (for IDE support)\nCMAKE_AUTOMOC = ON (Qt MOC automation)\nCMAKE_AUTORCC = ON (Qt resource compilation)\nCMAKE_AUTOUIC = ON (Qt UI file compilation)\n```\n\nThe build system strips the `-mno-direct-extern-access` flag from all compiler flag variables to prevent compatibility issues with certain toolchains. This sanitization happens at [CMakeLists.txt:4-9]() before the project definition.\n\n**Diagram: CMake Configuration Flow**\n\n```mermaid\ngraph TB\n    START[\"cmake invocation\"]\n    SANITIZE[\"Strip problematic flags\u003cbr/\u003e-mno-direct-extern-access\"]\n    PROJECT[\"project() declaration\u003cbr/\u003echadvis-projectm-qt v1.0.0\"]\n    STANDARDS[\"Set C++20 standard\u003cbr/\u003eCMAKE_CXX_STANDARD=20\"]\n    AUTOMOC[\"Enable Qt automation\u003cbr/\u003eAUTOMOC/AUTORCC/AUTOUIC\"]\n    BUILDTYPE[\"Set build type\u003cbr/\u003eDefault: Release\"]\n    WARNINGS[\"Add compiler warnings\u003cbr/\u003e-Wall -Wextra -Wpedantic\"]\n    \n    START --\u003e SANITIZE\n    SANITIZE --\u003e PROJECT\n    PROJECT --\u003e STANDARDS\n    STANDARDS --\u003e AUTOMOC\n    AUTOMOC --\u003e BUILDTYPE\n    BUILDTYPE --\u003e WARNINGS\n    \n    WARNINGS --\u003e FIND[\"Dependency discovery\"]\n```\n\nSources: [CMakeLists.txt:1-51]()\n\n---\n\n## Dependency Discovery Mechanisms\n\nThe build system uses a two-tiered approach to locate dependencies: pkg-config for most libraries, with manual fallback search paths for projectM v4.\n\n### Qt6 Dependencies\n\nQt6 packages are discovered using CMake's native `find_package()` mechanism with the `REQUIRED` flag. The following Qt6 modules are linked:\n\n| Qt6 Module | Purpose |\n|------------|---------|\n| `Qt6::Core` | Foundation classes, event loop, signals/slots |\n| `Qt6::Gui` | Window system integration, OpenGL context |\n| `Qt6::Widgets` | UI widget classes |\n| `Qt6::Multimedia` | Audio playback (QMediaPlayer, QAudioBufferOutput) |\n| `Qt6::OpenGLWidgets` | OpenGL rendering widgets |\n| `Qt6::Svg` | SVG icon support |\n| `Qt6::Network` | HTTP client for Suno API (QNetworkAccessManager) |\n| `Qt6::Sql` | SQLite database for Suno local storage |\n\nSources: [CMakeLists.txt:60](), [CMakeLists.txt:247-255]()\n\n### Pkg-config Dependencies\n\nMost external libraries are discovered via pkg-config, which provides compiler include paths and linker flags:\n\n```cmake\npkg_check_modules(SPDLOG REQUIRED spdlog)\npkg_check_modules(FMT REQUIRED fmt)\npkg_check_modules(TAGLIB REQUIRED taglib)\npkg_check_modules(TOMLPP REQUIRED tomlplusplus)\npkg_check_modules(GLEW REQUIRED glew)\npkg_check_modules(FFMPEG REQUIRED libavcodec libavformat libavutil libswscale libswresample)\n```\n\nThese modules populate variables like `${SPDLOG_INCLUDE_DIRS}` and `${SPDLOG_LIBRARIES}` that are used in `target_include_directories()` and `target_link_libraries()` respectively.\n\nSources: [CMakeLists.txt:63-69]()\n\n### ProjectM v4 Discovery Strategy\n\nProjectM v4 uses a three-tier discovery strategy due to its frequent unavailability in system package repositories:\n\n**Diagram: ProjectM Discovery Flow**\n\n```mermaid\ngraph TD\n    START[\"ProjectM discovery\"]\n    LOCAL[\"Check local installation\u003cbr/\u003eexternal/projectm-install/\"]\n    LOCAL_EXISTS{\"libprojectM-4.so\u003cbr/\u003eexists?\"}\n    PKG1[\"Try pkg-config\u003cbr/\u003eprojectM-4\"]\n    PKG1_OK{\"Found?\"}\n    PKG2[\"Try pkg-config\u003cbr/\u003elibprojectM\"]\n    PKG2_OK{\"Found?\"}\n    MANUAL[\"Manual search\u003cbr/\u003e/usr/local, /usr\"]\n    MANUAL_OK{\"Found?\"}\n    FAIL[\"FATAL_ERROR:\u003cbr/\u003eProjectM not found\"]\n    SUCCESS[\"Set PROJECTM_FOUND=TRUE\u003cbr/\u003eConfigure include/lib paths\"]\n    \n    START --\u003e LOCAL\n    LOCAL --\u003e LOCAL_EXISTS\n    LOCAL_EXISTS --\u003e|Yes| SUCCESS\n    LOCAL_EXISTS --\u003e|No| PKG1\n    PKG1 --\u003e PKG1_OK\n    PKG1_OK --\u003e|Yes| SUCCESS\n    PKG1_OK --\u003e|No| PKG2\n    PKG2 --\u003e PKG2_OK\n    PKG2_OK --\u003e|Yes| SUCCESS\n    PKG2_OK --\u003e|No| MANUAL\n    MANUAL --\u003e MANUAL_OK\n    MANUAL_OK --\u003e|Yes| SUCCESS\n    MANUAL_OK --\u003e|No| FAIL\n```\n\nThe local installation path at `${CMAKE_SOURCE_DIR}/external/projectm-install` is checked first. If found, the build system sets `CMAKE_INSTALL_RPATH` to ensure the binary can locate the shared library at runtime:\n\n```cmake\nset(PROJECTM_LOCAL_DIR \"${CMAKE_SOURCE_DIR}/external/projectm-install\")\nset(PROJECTM_INCLUDE_DIRS \"${PROJECTM_LOCAL_DIR}/include\")\nset(PROJECTM_LIBRARIES \"${PROJECTM_LOCAL_DIR}/lib/libprojectM-4.so\")\nset(CMAKE_INSTALL_RPATH \"${PROJECTM_LOCAL_DIR}/lib\")\nset(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)\n```\n\nThe manual search uses `find_path()` for headers and `find_library()` for the shared object:\n\n```cmake\nfind_path(PROJECTM_INCLUDE_DIRS projectM-4/projectM.h\n    HINTS /usr/local/include /usr/include\n)\nfind_library(PROJECTM_LIBRARIES projectM-4\n    HINTS /usr/local/lib /usr/lib\n)\n```\n\nA bug fix at [CMakeLists.txt:105-108]() corrects pkg-config's erroneous `-l:projectM-4` linker flag to the correct `-lprojectM-4` format.\n\nSources: [CMakeLists.txt:71-108]()\n\n---\n\n## Compiler Flags \u0026 Optimizations\n\n### CMakeLists.txt Compiler Flags\n\nThe CMake configuration applies warning flags to all build types and optimization flags specific to Debug/Release configurations:\n\n| Flag Category | Flags | Purpose |\n|---------------|-------|---------|\n| **Warnings** | `-Wall -Wextra -Wpedantic` | Enable comprehensive warnings |\n| **Warning Suppression** | `-Wno-unused-parameter` | Suppress unused parameter warnings |\n| **Debug Flags** | `-g3 -O0` | Full debug symbols, no optimization |\n| **Release Flags** | `-O3 -march=native` | Maximum optimization, CPU-specific tuning |\n\nThe `-march=native` flag enables CPU-specific optimizations for the build machine. This is overridden by the build.zsh script for explicit architecture targeting.\n\nSources: [CMakeLists.txt:48-57]()\n\n### build.zsh Optimization Strategy\n\nThe `build.zsh` script provides a more sophisticated flag composition system optimized for Intel N4500 (Tremont microarchitecture):\n\n**Diagram: Flag Composition in build.zsh**\n\n```mermaid\ngraph TB\n    CPU[\"CPU_OPT_FLAGS\u003cbr/\u003e-march=tremont -mtune=tremont\u003cbr/\u003e-msse4.2 -mpopcnt -maes\u003cbr/\u003e-mno-avx -mno-avx2\"]\n    COMMON[\"COMMON_OPT_FLAGS\u003cbr/\u003e-pipe -fomit-frame-pointer\u003cbr/\u003e-ffunction-sections -fdata-sections\"]\n    DEBUG[\"DEBUG_FLAGS\u003cbr/\u003e-O2 -g1\"]\n    RELEASE[\"RELEASE_FLAGS\u003cbr/\u003e-O3 -flto=N -fno-plt -DNDEBUG\"]\n    LINKER[\"LINKER_FLAGS\u003cbr/\u003e-Wl,--gc-sections -Wl,--as-needed\"]\n    \n    BUILD_TYPE{\"Build Type?\"}\n    \n    COMPOSE_DEBUG[\"compose_flags\u003cbr/\u003eCPU + COMMON + DEBUG\"]\n    COMPOSE_RELEASE[\"compose_flags\u003cbr/\u003eCPU + COMMON + RELEASE\"]\n    \n    CXXFLAGS_DEBUG[\"CMAKE_CXX_FLAGS\u003cbr/\u003e(Debug)\"]\n    CXXFLAGS_RELEASE[\"CMAKE_CXX_FLAGS\u003cbr/\u003e(Release)\"]\n    \n    LDFLAGS[\"CMAKE_EXE_LINKER_FLAGS\u003cbr/\u003eLINKER + LTO (if Release)\"]\n    \n    CPU --\u003e BUILD_TYPE\n    COMMON --\u003e BUILD_TYPE\n    DEBUG --\u003e BUILD_TYPE\n    RELEASE --\u003e BUILD_TYPE\n    \n    BUILD_TYPE --\u003e|Debug| COMPOSE_DEBUG\n    BUILD_TYPE --\u003e|Release| COMPOSE_RELEASE\n    \n    COMPOSE_DEBUG --\u003e CXXFLAGS_DEBUG\n    COMPOSE_RELEASE --\u003e CXXFLAGS_RELEASE\n    \n    LINKER --\u003e LDFLAGS\n    \n    CXXFLAGS_DEBUG --\u003e CMAKE[\"cmake invocation\"]\n    CXXFLAGS_RELEASE --\u003e CMAKE\n    LDFLAGS --\u003e CMAKE\n```\n\n**CPU-Specific Flags** (Intel N4500/Tremont):\n- `-march=tremont -mtune=tremont`: Target Tremont microarchitecture\n- `-msse4.2 -mpopcnt -maes`: Enable available instruction sets\n- `-mno-avx -mno-avx2`: Explicitly disable unavailable instructions\n\n**Optimization Flags**:\n- `-pipe`: Use pipes instead of temporary files between compilation stages\n- `-fomit-frame-pointer`: Omit frame pointer for performance\n- `-ffunction-sections -fdata-sections`: Enable dead code elimination\n- `-flto=N`: Link-time optimization with N parallel jobs (Release only)\n- `-fno-plt`: Avoid PLT indirection for performance\n\n**Linker Flags**:\n- `-Wl,--gc-sections`: Remove unused sections\n- `-Wl,--as-needed`: Only link actually used libraries\n\nThe script sanitizes environment variables to remove problematic flags before invoking CMake:\n\n```zsh\nremove_problematic_flags() {\n    local -a bad=(\"-mno-direct-extern-access\" \"-fcf-protection\" \"-fstack-clash-protection\")\n    # Remove from input string\n}\n```\n\nSources: [build.zsh:13-43](), [build.zsh:62-74](), [build.zsh:84-101]()\n\n---\n\n## Source File Organization\n\nThe CMake configuration organizes source files into logical modules, with explicit listing of both `.cpp` implementation files and `.hpp` header files. Headers must be listed explicitly to enable CMake's `AUTOMOC` to generate meta-object code for Qt classes containing `Q_OBJECT` macros.\n\n**Diagram: Source Module Organization**\n\n```mermaid\ngraph TB\n    ALL_SOURCES[\"ALL_SOURCES\"]\n    \n    MAIN[\"src/main.cpp\"]\n    \n    UTIL[\"UTIL_SOURCES\u003cbr/\u003eutil/Types.hpp\u003cbr/\u003eutil/Result.hpp\u003cbr/\u003eutil/Signal.hpp\u003cbr/\u003eutil/FileUtils.*\"]\n    \n    CORE[\"CORE_SOURCES\u003cbr/\u003ecore/Logger.*\u003cbr/\u003ecore/Config.*\u003cbr/\u003ecore/Application.*\"]\n    \n    AUDIO[\"AUDIO_SOURCES\u003cbr/\u003eaudio/AudioEngine.*\u003cbr/\u003eaudio/AudioAnalyzer.*\u003cbr/\u003eaudio/Playlist.*\u003cbr/\u003eaudio/MediaMetadata.*\u003cbr/\u003eaudio/FFmpegAudioSource.*\"]\n    \n    VIZ[\"VISUALIZER_SOURCES\u003cbr/\u003evisualizer/ProjectMBridge.*\u003cbr/\u003evisualizer/PresetManager.*\u003cbr/\u003evisualizer/RatingManager.*\u003cbr/\u003evisualizer/RenderTarget.*\u003cbr/\u003evisualizer/VisualizerWindow.*\"]\n    \n    SUNO[\"SUNO_SOURCES\u003cbr/\u003esuno/SunoModels.hpp\u003cbr/\u003esuno/SunoClient.*\u003cbr/\u003esuno/SunoDatabase.*\"]\n    \n    OVERLAY[\"OVERLAY_SOURCES\u003cbr/\u003eoverlay/TextElement.*\u003cbr/\u003eoverlay/TextAnimator.*\u003cbr/\u003eoverlay/OverlayConfig.*\u003cbr/\u003eoverlay/OverlayEngine.*\u003cbr/\u003eoverlay/OverlayRenderer.*\"]\n    \n    RECORDER[\"RECORDER_SOURCES\u003cbr/\u003erecorder/EncoderSettings.*\u003cbr/\u003erecorder/FrameGrabber.*\u003cbr/\u003erecorder/VideoRecorder.*\"]\n    \n    UI[\"UI_SOURCES\u003cbr/\u003eui/controllers/*Controller.*\u003cbr/\u003eui/MarqueeLabel.*\u003cbr/\u003eui/PlayerControls.*\u003cbr/\u003eui/PlaylistView.*\u003cbr/\u003eui/VisualizerPanel.*\u003cbr/\u003eui/OverlayEditor.*\u003cbr/\u003eui/SunoBrowser.*\u003cbr/\u003eui/SunoCookieDialog.*\u003cbr/\u003eui/PresetBrowser.*\u003cbr/\u003eui/RecordingControls.*\u003cbr/\u003eui/SettingsDialog.*\u003cbr/\u003eui/MainWindow.*\"]\n    \n    RESOURCES[\"RESOURCES\u003cbr/\u003eresources/chadvis-projectm-qt.qrc\"]\n    \n    ALL_SOURCES --\u003e MAIN\n    ALL_SOURCES --\u003e UTIL\n    ALL_SOURCES --\u003e CORE\n    ALL_SOURCES --\u003e AUDIO\n    ALL_SOURCES --\u003e VIZ\n    ALL_SOURCES --\u003e SUNO\n    ALL_SOURCES --\u003e OVERLAY\n    ALL_SOURCES --\u003e RECORDER\n    ALL_SOURCES --\u003e UI\n    \n    EXECUTABLE[\"add_executable\u003cbr/\u003echadvis-projectm-qt\"]\n    \n    ALL_SOURCES --\u003e EXECUTABLE\n    RESOURCES --\u003e EXECUTABLE\n```\n\n### Module Mapping to Systems\n\n| CMake Variable | Module Purpose | Related Wiki Section |\n|----------------|----------------|----------------------|\n| `UTIL_SOURCES` | Type definitions, Result\u003cT\u003e error handling, signal system, file utilities | [Architecture \u0026 Design Patterns](#1.1) |\n| `CORE_SOURCES` | Logger, Config singleton, Application singleton | [Application \u0026 Config](#2.1) |\n| `AUDIO_SOURCES` | Audio playback, decoding, spectrum analysis, playlist management | [Audio System](#3) |\n| `VISUALIZER_SOURCES` | projectM integration, preset management, OpenGL window, render targets | [Visualization System](#4) |\n| `SUNO_SOURCES` | Suno AI API client, data models, SQLite database | [Suno AI Integration](#8) |\n| `OVERLAY_SOURCES` | Text rendering, animations, overlay composition | [Overlay System](#6) |\n| `RECORDER_SOURCES` | FFmpeg encoding, frame capture, video output | [Recording System](#5) |\n| `UI_SOURCES` | Qt widgets, controllers, main window, dialogs | [User Interface](#7) |\n\nThe wildcard pattern `.*` in the diagram represents both `.hpp` and `.cpp` files. Each module is self-contained, with headers listed explicitly to enable AUTOMOC processing.\n\nSources: [CMakeLists.txt:111-227]()\n\n---\n\n## Build Script (build.zsh)\n\nThe `build.zsh` script provides a high-level interface to the CMake/Ninja build system with additional features for development workflow.\n\n### Available Commands\n\n| Command | Function | Description |\n|---------|----------|-------------|\n| `build` | `cmd_build()` | Incremental debug build |\n| `rebuild` | `cmd_rebuild()` | Clean debug build |\n| `clean` | `cmd_clean()` | Remove all build artifacts |\n| `run [args]` | `cmd_run()` | Build if needed, then execute binary with arguments |\n| `test` | `cmd_test()` | Run unit and integration test suites |\n| `check-deps` | `cmd_check_deps()` | Verify all required packages are installed |\n| `help` | `cmd_help()` | Display command reference |\n\n**Diagram: Build Script Execution Flow**\n\n```mermaid\ngraph TB\n    MAIN[\"main() entry point\"]\n    PARSE[\"Parse command\u003cbr/\u003efrom argv[1]\"]\n    DISPATCH[\"DISPATCH associative array\u003cbr/\u003emaps command to function\"]\n    \n    SANITIZE[\"sanitize_environment()\u003cbr/\u003eRemove problematic flags\"]\n    ENSURE[\"ensure_build_dir()\u003cbr/\u003eCreate/clean build/\"]\n    CMAKE[\"invoke_cmake()\u003cbr/\u003eConfigure with Ninja generator\"]\n    NINJA[\"invoke_ninja()\u003cbr/\u003eBuild with N cores\"]\n    SUCCESS[\"Log build success\u003cbr/\u003eDisplay binary size\"]\n    \n    CMD_BUILD[\"cmd_build()\u003cbr/\u003ebuild_pipeline Debug false\"]\n    CMD_REBUILD[\"cmd_rebuild()\u003cbr/\u003ebuild_pipeline Debug true\"]\n    CMD_RUN[\"cmd_run()\u003cbr/\u003eensure_binary() then exec\"]\n    CMD_CHECK[\"cmd_check_deps()\u003cbr/\u003eVerify pkg-config packages\"]\n    \n    MAIN --\u003e PARSE\n    PARSE --\u003e DISPATCH\n    \n    DISPATCH --\u003e|build| CMD_BUILD\n    DISPATCH --\u003e|rebuild| CMD_REBUILD\n    DISPATCH --\u003e|run| CMD_RUN\n    DISPATCH --\u003e|check-deps| CMD_CHECK\n    \n    CMD_BUILD --\u003e SANITIZE\n    CMD_REBUILD --\u003e SANITIZE\n    \n    SANITIZE --\u003e ENSURE\n    ENSURE --\u003e CMAKE\n    CMAKE --\u003e NINJA\n    NINJA --\u003e SUCCESS\n    \n    CMD_RUN --\u003e|if binary missing| CMD_BUILD\n    CMD_RUN --\u003e|if exists| EXEC[\"exec $BINARY_PATH $@\"]\n```\n\n### Key Implementation Details\n\n**Command Dispatch** at [build.zsh:196-209]():\n```zsh\ntypeset -A DISPATCH=(\n    [build]=cmd_build\n    [rebuild]=cmd_rebuild\n    [clean]=cmd_clean\n    [run]=cmd_run\n    [test]=cmd_test\n    [check-deps]=cmd_check_deps\n)\n```\n\n**Build Pipeline** at [build.zsh:108-123]():\n```zsh\nbuild_pipeline() {\n    local build_type=\"$1\" clean_first=\"${2:-false}\"\n    sanitize_environment\n    ensure_build_dir \"$clean_first\"\n    invoke_cmake \"$build_type\"\n    invoke_ninja \"$N4500_CORES\"\n}\n```\n\n**Dependency Checking** at [build.zsh:158-179]():\nThe `check-deps` command verifies both command-line tools (`cmd:` prefix) and pkg-config packages (`pkg:` prefix):\n\n```zsh\nlocal -a deps=(\n    \"cmd:cmake:cmake\" \"cmd:ninja:ninja\" \"cmd:g++:gcc\"\n    \"pkg:Qt6Core:qt6-base\" \"pkg:Qt6Widgets:qt6-base\"\n    \"pkg:libprojectM-4:projectm\" \"pkg:libavcodec:ffmpeg\"\n    # ... more dependencies\n)\n```\n\nMissing packages are reported with a suggested `pacman` installation command (Arch Linux package manager).\n\nSources: [build.zsh:1-213]()\n\n---\n\n## Target Configuration \u0026 Installation\n\n### Include Directories\n\nThe executable target includes directories from all dependencies:\n\n```cmake\ntarget_include_directories(chadvis-projectm-qt PRIVATE\n    ${CMAKE_SOURCE_DIR}/src           # Project source root\n    ${SPDLOG_INCLUDE_DIRS}\n    ${FMT_INCLUDE_DIRS}\n    ${TAGLIB_INCLUDE_DIRS}\n    ${TOMLPP_INCLUDE_DIRS}\n    ${GLEW_INCLUDE_DIRS}\n    ${GLM_INCLUDE_DIRS}\n    ${FFMPEG_INCLUDE_DIRS}\n    ${PROJECTM_INCLUDE_DIRS}\n)\n```\n\nThe `${CMAKE_SOURCE_DIR}/src` entry enables include paths like `#include \"core/Logger.hpp\"` without relative path traversal.\n\nSources: [CMakeLists.txt:235-245]()\n\n### Linker Configuration\n\nThe target links against Qt6 modules, external libraries, and OpenGL:\n\n```cmake\ntarget_link_libraries(chadvis-projectm-qt PRIVATE\n    Qt6::Core Qt6::Gui Qt6::Widgets Qt6::Multimedia\n    Qt6::OpenGLWidgets Qt6::Svg Qt6::Network Qt6::Sql\n    ${SPDLOG_LIBRARIES}\n    ${FMT_LIBRARIES}\n    ${TAGLIB_LIBRARIES}\n    ${GLEW_LIBRARIES}\n    ${FFMPEG_LIBRARIES}\n    projectM-4\n    projectM-4-playlist\n    OpenGL\n)\n```\n\nNote that `projectM-4` and `projectM-4-playlist` are linked directly by name rather than through the `${PROJECTM_LIBRARIES}` variable due to the custom discovery logic.\n\nSources: [CMakeLists.txt:247-264]()\n\n### Installation Targets\n\nThe build system defines installation rules for system-wide deployment:\n\n| Target | Destination | Purpose |\n|--------|-------------|---------|\n| `chadvis-projectm-qt` | `bin/` | Main executable binary |\n| `config/` directory | `share/chadvis-projectm-qt/config/` | Default configuration templates |\n| `chadvis-projectm-qt.desktop` | `share/applications/` | Desktop environment integration |\n| `chadvis-projectm-qt.svg` | `share/icons/hicolor/scalable/apps/` | Application icon |\n\nInstallation is performed via:\n```bash\ncmake --install build --prefix /usr/local\n```\n\nSources: [CMakeLists.txt:272-276]()\n\n---\n\n## CPack Packaging\n\nThe build system includes CPack configuration for generating distribution packages:\n\n```cmake\nset(CPACK_PACKAGE_NAME \"chadvis-projectm-qt\")\nset(CPACK_PACKAGE_VERSION ${PROJECT_VERSION})\nset(CPACK_PACKAGE_DESCRIPTION_SUMMARY \"Qt6 projectM v4 visualizer with modern C++20\")\ninclude(CPack)\n```\n\nThis enables package generation with:\n```bash\ncd build\ncpack -G DEB  # Debian package\ncpack -G RPM  # RPM package\ncpack -G TGZ  # Tarball\n```\n\nSources: [CMakeLists.txt:278-281]()"])</script><script>self.__next_f.push([1,"1d:T3e91,"])</script><script>self.__next_f.push([1,"# Audio System\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AGENTS.md](AGENTS.md)\n- [src/audio/AudioEngine.cpp](src/audio/AudioEngine.cpp)\n- [src/audio/AudioEngine.hpp](src/audio/AudioEngine.hpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThe Audio System handles all aspects of audio playback, decoding, analysis, and track management in chadvis-projectm-qt. It serves as the audio data source for the visualization pipeline, providing real-time PCM samples and spectrum data to projectM. This document covers the architecture of the audio subsystem, the buffer processing pipeline, and integration points with other systems.\n\nFor detailed implementation of the main audio engine, see [AudioEngine](#3.1). For playlist functionality and M3U file handling, see [Playlist Management](#3.2). For how audio data drives visualizations, see [Visualization System](#4).\n\n---\n\n## System Architecture\n\nThe Audio System consists of three primary components working in concert: `AudioEngine` for playback orchestration, `AudioAnalyzer` for frequency spectrum extraction, and `Playlist` for track management. The system is designed around Qt's Multimedia framework with custom signal routing to provide zero-copy audio data to visualization and recording subsystems.\n\n```mermaid\ngraph TB\n    subgraph \"AudioEngine Component\"\n        AE[\"AudioEngine\u003cbr/\u003e(QObject)\"]\n        PLAYER[\"QMediaPlayer\u003cbr/\u003eplayer_\"]\n        AUDIO_OUT[\"QAudioOutput\u003cbr/\u003eaudioOutput_\"]\n        BUFFER_OUT[\"QAudioBufferOutput\u003cbr/\u003ebufferOutput_\"]\n    end\n    \n    subgraph \"Analysis Component\"\n        ANALYZER[\"AudioAnalyzer\u003cbr/\u003eanalyzer_\"]\n        SPECTRUM[\"AudioSpectrum\u003cbr/\u003ecurrentSpectrum_\"]\n        SCRATCH[\"vector\u0026lt;f32\u0026gt;\u003cbr/\u003escratchBuffer_\"]\n    end\n    \n    subgraph \"Playlist Component\"\n        PL[\"Playlist\u003cbr/\u003eplaylist_\"]\n        ITEMS[\"vector\u0026lt;PlaylistItem\u0026gt;\"]\n        M3U[\"last_session.m3u\"]\n    end\n    \n    subgraph \"External Interfaces\"\n        MEDIA_FILE[\"Local Audio Files\u003cbr/\u003eMP3/FLAC/WAV/etc\"]\n        SUNO[\"Suno Downloads\u003cbr/\u003evia SunoController\"]\n    end\n    \n    subgraph \"Output Signals\"\n        STATE_SIG[\"Signal\u0026lt;PlaybackState\u0026gt;\u003cbr/\u003estateChanged\"]\n        SPECTRUM_SIG[\"Signal\u0026lt;AudioSpectrum\u0026gt;\u003cbr/\u003espectrumUpdated\"]\n        PCM_SIG[\"Signal\u0026lt;vector\u0026lt;f32\u0026gt;, u32, u32, u32\u0026gt;\u003cbr/\u003epcmReceived\"]\n        TRACK_SIG[\"Signal\u0026lt;\u0026gt;\u003cbr/\u003etrackChanged\"]\n    end\n    \n    MEDIA_FILE --\u003e PL\n    SUNO --\u003e PL\n    PL --\u003e ITEMS\n    PL -.-\u003e|\"load on change\"| AE\n    \n    AE --\u003e PLAYER\n    PLAYER --\u003e AUDIO_OUT\n    PLAYER --\u003e BUFFER_OUT\n    \n    BUFFER_OUT --\u003e|\"onAudioBufferReceived\"| AE\n    AE --\u003e|\"processAudioBuffer\"| SCRATCH\n    SCRATCH --\u003e ANALYZER\n    ANALYZER --\u003e SPECTRUM\n    \n    AE --\u003e STATE_SIG\n    AE --\u003e SPECTRUM_SIG\n    AE --\u003e PCM_SIG\n    AE --\u003e TRACK_SIG\n    \n    PL -.-\u003e|\"persist\"| M3U\n```\n\n**Sources:** [src/audio/AudioEngine.hpp:1-127](), [src/audio/AudioEngine.cpp:1-279]()\n\n---\n\n## Component Responsibilities\n\n| Component | Primary Responsibilities | Key Types |\n|-----------|-------------------------|-----------|\n| `AudioEngine` | Playback orchestration, volume control, seeking, signal emission | `PlaybackState`, `Duration` |\n| `AudioAnalyzer` | FFT-based frequency analysis, beat detection | `AudioSpectrum` |\n| `Playlist` | Track queue management, M3U I/O, shuffle/repeat modes | `PlaylistItem` |\n| `QMediaPlayer` | Hardware-accelerated decoding via Qt Multimedia | Qt-owned |\n| `QAudioBufferOutput` | Real-time PCM buffer capture for analysis | Qt-owned |\n\n**Sources:** [src/audio/AudioEngine.hpp:26-127](), [AGENTS.md:80-86]()\n\n---\n\n## Audio Processing Pipeline\n\nThe audio processing pipeline transforms compressed audio files into frequency spectrum data for visualization. This happens in real-time during playback with minimal latency.\n\n```mermaid\nflowchart LR\n    subgraph \"Input Stage\"\n        FILE[\"Audio File\u003cbr/\u003eQMediaPlayer::setSource\"]\n    end\n    \n    subgraph \"Decode Stage\"\n        DECODER[\"Qt Multimedia Decoder\u003cbr/\u003eHardware-accelerated\"]\n        BUFFER[\"QAudioBuffer\u003cbr/\u003e16-bit or 32-bit samples\"]\n    end\n    \n    subgraph \"Conversion Stage\"\n        CONVERT[\"Format Conversion\u003cbr/\u003eprocessAudioBuffer\"]\n        SCRATCH[\"scratchBuffer_\u003cbr/\u003ef32 normalized samples\"]\n    end\n    \n    subgraph \"Analysis Stage\"\n        FFT[\"AudioAnalyzer::analyze\u003cbr/\u003eFFT computation\"]\n        SPECTRUM_OUT[\"AudioSpectrum\u003cbr/\u003efrequency bins\"]\n    end\n    \n    subgraph \"Output Stage\"\n        EMIT_SPECTRUM[\"spectrumUpdated signal\"]\n        EMIT_PCM[\"pcmReceived signal\"]\n    end\n    \n    FILE --\u003e DECODER\n    DECODER --\u003e BUFFER\n    BUFFER --\u003e|\"onAudioBufferReceived\"| CONVERT\n    CONVERT --\u003e SCRATCH\n    SCRATCH --\u003e FFT\n    FFT --\u003e SPECTRUM_OUT\n    SPECTRUM_OUT --\u003e EMIT_SPECTRUM\n    SCRATCH --\u003e EMIT_PCM\n```\n\n**Sources:** [src/audio/AudioEngine.cpp:191-274]()\n\n---\n\n## Buffer Processing Details\n\nThe `processAudioBuffer` method performs zero-allocation audio processing by reusing a pre-allocated `scratchBuffer_`. This method handles multiple sample formats from Qt Multimedia and normalizes them to `f32` values in the range [-1.0, 1.0].\n\n### Sample Format Conversion\n\n| Input Format | Source Type | Conversion Formula | Code Location |\n|--------------|-------------|-------------------|---------------|\n| `QAudioFormat::Float` | `f32*` | Direct copy (no conversion) | [src/audio/AudioEngine.cpp:250-252]() |\n| `QAudioFormat::Int16` | `i16*` | `sample / 32768.0f` | [src/audio/AudioEngine.cpp:254-257]() |\n| `QAudioFormat::Int32` | `i32*` | `sample / 2147483648.0f` | [src/audio/AudioEngine.cpp:258-263]() |\n\n### Processing Flow\n\n```mermaid\nflowchart TB\n    START[\"onAudioBufferReceived\u003cbr/\u003eQAudioBuffer buffer\"]\n    \n    VALIDATE{\"buffer.isValid()\"}\n    \n    LOCK[\"std::lock_guard\u0026lt;std::mutex\u0026gt;\u003cbr/\u003eaudioMutex_\"]\n    \n    EXTRACT[\"Extract metadata:\u003cbr/\u003esampleRate, channels,\u003cbr/\u003eframeCount, format\"]\n    \n    RESIZE{\"scratchBuffer_.size()\u003cbr/\u003e\u0026lt; totalSamples?\"}\n    \n    GROW[\"scratchBuffer_.resize\u003cbr/\u003e(totalSamples)\"]\n    \n    CONVERT[\"Format-specific conversion\u003cbr/\u003eto f32 in scratchBuffer_\"]\n    \n    ANALYZE[\"analyzer_.analyze\u003cbr/\u003e(scratchBuffer_, rate, ch)\"]\n    \n    STORE[\"currentSpectrum_ =\u003cbr/\u003ereturned spectrum\"]\n    \n    EMIT_SPEC[\"spectrumUpdated.emitSignal\u003cbr/\u003e(currentSpectrum_)\"]\n    \n    EMIT_PCM[\"pcmReceived.emitSignal\u003cbr/\u003e(scratchBuffer_, ...)\"]\n    \n    END[\"Return\"]\n    \n    START --\u003e VALIDATE\n    VALIDATE --\u003e|false| END\n    VALIDATE --\u003e|true| LOCK\n    LOCK --\u003e EXTRACT\n    EXTRACT --\u003e RESIZE\n    RESIZE --\u003e|true| GROW\n    RESIZE --\u003e|false| CONVERT\n    GROW --\u003e CONVERT\n    CONVERT --\u003e ANALYZE\n    ANALYZE --\u003e STORE\n    STORE --\u003e EMIT_SPEC\n    EMIT_SPEC --\u003e EMIT_PCM\n    EMIT_PCM --\u003e END\n```\n\n**Sources:** [src/audio/AudioEngine.cpp:232-274]()\n\n---\n\n## Playback State Management\n\nThe `AudioEngine` maintains a simplified three-state model mapped from Qt's `QMediaPlayer::PlaybackState`. State transitions trigger signal emissions that update the UI and visualization systems.\n\n### State Diagram\n\n```mermaid\nstateDiagram-v2\n    [*] --\u003e Stopped\n    \n    Stopped --\u003e Playing: play()\n    Playing --\u003e Paused: pause()\n    Playing --\u003e Stopped: stop()\n    Paused --\u003e Playing: play()\n    Paused --\u003e Stopped: stop()\n    \n    Playing --\u003e Stopped: End of track\u003cbr/\u003e(autoPlayNext=false)\n    Playing --\u003e Playing: End of track\u003cbr/\u003eplaylist_.next()\n    \n    note right of Stopped\n        player_-\u003estop()\n        analyzer_.reset()\n    end note\n    \n    note right of Playing\n        bufferReceivedSinceLastCheck_ = false\n        Diagnostic timer active\n    end note\n```\n\n**Sources:** [src/audio/AudioEngine.cpp:147-166](), [src/audio/AudioEngine.cpp:182-189]()\n\n---\n\n## Signal Interface\n\nThe `AudioEngine` exposes a signal-based API for reactive integration with UI and visualization components. All signals are instances of the custom `vc::Signal\u003cT\u003e` template, which provides type-safe callback registration without Qt's meta-object overhead for non-QObject classes.\n\n### Signal Types\n\n| Signal | Type Signature | Emission Trigger | Primary Consumer |\n|--------|----------------|------------------|------------------|\n| `stateChanged` | `Signal\u003cPlaybackState\u003e` | `onPlayerStateChanged` | UI controllers, overlay engine |\n| `positionChanged` | `Signal\u003cDuration\u003e` | `onPositionChanged` (from QMediaPlayer) | Progress bar, time display |\n| `durationChanged` | `Signal\u003cDuration\u003e` | `onDurationChanged` (from QMediaPlayer) | Progress bar total time |\n| `spectrumUpdated` | `Signal\u003cconst AudioSpectrum\u0026\u003e` | After `analyzer_.analyze()` | ProjectMBridge visualization |\n| `pcmReceived` | `Signal\u003cconst vector\u003cf32\u003e\u0026, u32, u32, u32\u003e` | After buffer conversion | VideoRecorder (if recording) |\n| `trackChanged` | `Signal\u003c\u003e` | `onPlaylistCurrentChanged` | Metadata display, overlay |\n| `errorSignal` | `Signal\u003cstd::string\u003e` | `onErrorOccurred` | Error dialog, logging |\n\n**Sources:** [src/audio/AudioEngine.hpp:76-83](), [src/audio/AudioEngine.cpp:32-57]()\n\n---\n\n## Playlist Integration\n\nThe `AudioEngine` owns a `Playlist` instance that manages the track queue. When the playlist's current item changes, the engine automatically loads and plays the new track. Playlist state persists to `last_session.m3u` in the config directory for session continuity.\n\n### Track Loading Sequence\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Playlist\n    participant AudioEngine\n    participant QMediaPlayer\n    \n    User-\u003e\u003ePlaylist: next() / previous() / jumpTo(index)\n    Playlist-\u003e\u003ePlaylist: Update currentIndex_\n    Playlist-\u003e\u003eAudioEngine: currentChanged signal (index)\n    AudioEngine-\u003e\u003eAudioEngine: onPlaylistCurrentChanged(index)\n    AudioEngine-\u003e\u003eAudioEngine: loadCurrentTrack()\n    AudioEngine-\u003e\u003ePlaylist: currentItem()\n    Playlist--\u003e\u003eAudioEngine: PlaylistItem*\n    AudioEngine-\u003e\u003eQMediaPlayer: setSource(QUrl::fromLocalFile)\n    AudioEngine-\u003e\u003eQMediaPlayer: play()\n    QMediaPlayer--\u003e\u003eAudioEngine: playbackStateChanged\n    AudioEngine-\u003e\u003eAudioEngine: onPlayerStateChanged\n    AudioEngine-\u003e\u003eUser: stateChanged signal\n    AudioEngine-\u003e\u003eUser: trackChanged signal\n```\n\n**Sources:** [src/audio/AudioEngine.cpp:59-62](), [src/audio/AudioEngine.cpp:199-213]()\n\n---\n\n## Initialization Sequence\n\nThe `AudioEngine::init()` method sets up the Qt Multimedia pipeline and connects all internal signal handlers. This method returns a `Result\u003cvoid\u003e` to propagate initialization errors.\n\n```mermaid\nflowchart TB\n    START[\"AudioEngine::init()\"]\n    \n    CREATE_OUTPUT[\"audioOutput_ =\u003cbr/\u003emake_unique\u0026lt;QAudioOutput\u0026gt;()\"]\n    \n    SET_VOLUME[\"audioOutput_-\u003esetVolume\u003cbr/\u003e(volume_)\"]\n    \n    CREATE_PLAYER[\"player_ =\u003cbr/\u003emake_unique\u0026lt;QMediaPlayer\u0026gt;()\"]\n    \n    LINK_OUTPUT[\"player_-\u003esetAudioOutput\u003cbr/\u003e(audioOutput_.get())\"]\n    \n    CREATE_BUFFER[\"bufferOutput_ =\u003cbr/\u003emake_unique\u0026lt;QAudioBufferOutput\u0026gt;()\"]\n    \n    LINK_BUFFER[\"player_-\u003esetAudioBufferOutput\u003cbr/\u003e(bufferOutput_.get())\"]\n    \n    CONNECT_PLAYER[\"Connect QMediaPlayer signals:\u003cbr/\u003eplaybackStateChanged,\u003cbr/\u003epositionChanged, etc.\"]\n    \n    CONNECT_BUFFER[\"Connect bufferOutput:\u003cbr/\u003eaudioBufferReceived\"]\n    \n    CONNECT_PLAYLIST[\"Connect Playlist signals:\u003cbr/\u003ecurrentChanged, changed\"]\n    \n    LOAD_LAST[\"loadLastPlaylist()\u003cbr/\u003efrom last_session.m3u\"]\n    \n    START_TIMER[\"bufferCheckTimer_.start\u003cbr/\u003e(1000ms diagnostic)\"]\n    \n    LOG[\"LOG_INFO initialization complete\"]\n    \n    RETURN[\"return Result\u0026lt;void\u0026gt;::ok()\"]\n    \n    START --\u003e CREATE_OUTPUT\n    CREATE_OUTPUT --\u003e SET_VOLUME\n    SET_VOLUME --\u003e CREATE_PLAYER\n    CREATE_PLAYER --\u003e LINK_OUTPUT\n    LINK_OUTPUT --\u003e CREATE_BUFFER\n    CREATE_BUFFER --\u003e LINK_BUFFER\n    LINK_BUFFER --\u003e CONNECT_PLAYER\n    CONNECT_PLAYER --\u003e CONNECT_BUFFER\n    CONNECT_BUFFER --\u003e CONNECT_PLAYLIST\n    CONNECT_PLAYLIST --\u003e LOAD_LAST\n    LOAD_LAST --\u003e START_TIMER\n    START_TIMER --\u003e LOG\n    LOG --\u003e RETURN\n```\n\n**Sources:** [src/audio/AudioEngine.cpp:19-81]()\n\n---\n\n## Thread Safety\n\nThe `AudioEngine` processes audio buffers on Qt's multimedia thread and emits signals that may be consumed by the visualization thread. A `std::mutex audioMutex_` protects shared state accessed from multiple threads.\n\n### Protected Resources\n\n| Resource | Type | Protected Operations | Access Pattern |\n|----------|------|---------------------|----------------|\n| `scratchBuffer_` | `std::vector\u003cf32\u003e` | Resize, write, read | Write in `processAudioBuffer`, read in `currentPCM()` |\n| `currentSpectrum_` | `AudioSpectrum` | Write after analysis, read | Write in `processAudioBuffer`, read in `currentSpectrum()` |\n| `analyzer_` internal state | `AudioAnalyzer` | FFT computation | Write in `processAudioBuffer`, read in `currentPCM()` |\n\n**Sources:** [src/audio/AudioEngine.hpp:123](), [src/audio/AudioEngine.cpp:236](), [src/audio/AudioEngine.cpp:67-73]()\n\n---\n\n## Diagnostic Features\n\nThe audio system includes a diagnostic timer that checks whether audio buffers are being received during playback. This helps identify issues with `QAudioBufferOutput` functionality, which can fail silently on some platforms.\n\n### Buffer Reception Monitoring\n\nThe `bufferCheckTimer_` runs every 1000ms while the engine is active. If the engine is in the `Playing` state but no buffers have been received since the last check, a warning is logged. This diagnostic proved essential during development when Qt Multimedia's buffer output failed without error messages.\n\n```cpp\n// Diagnostic pattern from src/audio/AudioEngine.cpp:68-76\nconnect(\u0026bufferCheckTimer_, \u0026QTimer::timeout, this, [this]() {\n    if (state_ == PlaybackState::Playing \u0026\u0026 !bufferReceivedSinceLastCheck_) {\n        LOG_WARN(\"AudioEngine: No audio buffers received in last 1000ms - \"\n                 \"QAudioBufferOutput may not be working\");\n    }\n    bufferReceivedSinceLastCheck_ = false;\n});\n```\n\n**Sources:** [src/audio/AudioEngine.cpp:68-77](), [src/audio/AudioEngine.cpp:191-193]()\n\n---\n\n## Integration Points\n\nThe Audio System interfaces with several other subsystems to provide a cohesive playback and visualization experience.\n\n### Downstream Consumers\n\n```mermaid\ngraph LR\n    AE[\"AudioEngine\"]\n    \n    VIZ[\"ProjectMBridge\u003cbr/\u003e(Visualization)\"]\n    REC[\"VideoRecorder\u003cbr/\u003e(Recording)\"]\n    OVERLAY[\"OverlayEngine\u003cbr/\u003e(Metadata Display)\"]\n    UI[\"AudioController\u003cbr/\u003e(UI Updates)\"]\n    SUNO[\"SunoController\u003cbr/\u003e(Playlist Integration)\"]\n    \n    AE --\u003e|\"spectrumUpdated\u003cbr/\u003eAudioSpectrum\"| VIZ\n    AE --\u003e|\"pcmReceived\u003cbr/\u003ef32 samples\"| REC\n    AE --\u003e|\"trackChanged\u003cbr/\u003estateChanged\"| OVERLAY\n    AE --\u003e|\"positionChanged\u003cbr/\u003edurationChanged\u003cbr/\u003estateChanged\"| UI\n    AE \u003c--\u003e|\"playlist() access\u003cbr/\u003eadd tracks\"| SUNO\n```\n\n**Sources:** [src/audio/AudioEngine.hpp:76-83](), [AGENTS.md:80-86]()\n\n---\n\n## Configuration\n\nThe Audio System reads configuration from the `AudioConfig` section of the global `CONFIG` singleton. Settings are persisted to `config.toml` in the user's config directory.\n\n### Audio Configuration Parameters\n\n| Parameter | Type | Purpose | Default |\n|-----------|------|---------|---------|\n| `volume` | `f32` | Initial playback volume (0.0-1.0) | 1.0 |\n| `autoPlayNext` | `bool` | Automatically play next track on track end | `true` |\n| `lastPlaylistPath` | `std::string` | Path to `last_session.m3u` | `~/.config/.../last_session.m3u` |\n\n**Sources:** [src/audio/AudioEngine.cpp:215-230](), [AGENTS.md:80]()\n\n---\n\n## Error Handling\n\nAll initialization operations return `Result\u003cvoid\u003e` types to propagate errors without exceptions. Runtime errors from Qt Multimedia are captured via the `QMediaPlayer::errorOccurred` signal and converted to `std::string` messages emitted through the `errorSignal` signal.\n\n### Error Flow\n\n```mermaid\nflowchart LR\n    QMP[\"QMediaPlayer::errorOccurred\u003cbr/\u003e(QMediaPlayer::Error, QString)\"]\n    SLOT[\"AudioEngine::\u003cbr/\u003eonErrorOccurred\"]\n    LOG[\"LOG_ERROR\u003cbr/\u003e(formatted message)\"]\n    EMIT[\"errorSignal.emitSignal\u003cbr/\u003e(std::string)\"]\n    UI[\"Error dialog in UI\"]\n    \n    QMP --\u003e SLOT\n    SLOT --\u003e LOG\n    SLOT --\u003e EMIT\n    EMIT --\u003e UI\n```\n\n**Sources:** [src/audio/AudioEngine.cpp:176-180](), [AGENTS.md:54-65]()"])</script><script>self.__next_f.push([1,"1e:T42cb,"])</script><script>self.__next_f.push([1,"# AudioEngine\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [src/audio/AudioEngine.cpp](src/audio/AudioEngine.cpp)\n- [src/audio/AudioEngine.hpp](src/audio/AudioEngine.hpp)\n\n\u003c/details\u003e\n\n\n\nThe `AudioEngine` class is the core audio playback and processing component that orchestrates audio decoding, playback, spectrum analysis, and data capture for visualization. It wraps Qt Multimedia's `QMediaPlayer` and `QAudioOutput` for playback, uses `QAudioBufferOutput` to intercept decoded audio buffers, and feeds them to an `AudioAnalyzer` for real-time spectrum analysis. The engine emits custom signals for state changes, position updates, and audio data that drive the visualization and recording pipelines.\n\nFor playlist management details, see [Playlist Management](#3.2). For visualization integration, see [ProjectM Integration](#4.2).\n\nSources: [src/audio/AudioEngine.hpp:1-127](), [src/audio/AudioEngine.cpp:1-279]()\n\n---\n\n## Architecture Overview\n\nThe `AudioEngine` integrates multiple Qt Multimedia components with custom audio analysis and playlist management. It owns a `QMediaPlayer` for decoding, a `QAudioOutput` for playback routing, and a `QAudioBufferOutput` for intercepting decoded buffers. Each incoming buffer is processed through `AudioAnalyzer` for FFT-based spectrum extraction, then emitted via custom `Signal\u003c\u003e` templates for consumption by the visualizer and recorder.\n\n```mermaid\ngraph TB\n    subgraph AudioEngine[\"AudioEngine (QObject)\"]\n        PLAYER[\"player_\u003cbr/\u003estd::unique_ptr\u0026lt;QMediaPlayer\u0026gt;\"]\n        OUTPUT[\"audioOutput_\u003cbr/\u003estd::unique_ptr\u0026lt;QAudioOutput\u0026gt;\"]\n        BUFFER_OUT[\"bufferOutput_\u003cbr/\u003estd::unique_ptr\u0026lt;QAudioBufferOutput\u0026gt;\"]\n        PLAYLIST[\"playlist_\u003cbr/\u003ePlaylist\"]\n        ANALYZER[\"analyzer_\u003cbr/\u003eAudioAnalyzer\"]\n        SPECTRUM[\"currentSpectrum_\u003cbr/\u003eAudioSpectrum\"]\n        SCRATCH[\"scratchBuffer_\u003cbr/\u003estd::vector\u0026lt;f32\u0026gt;\"]\n        STATE[\"state_\u003cbr/\u003ePlaybackState enum\"]\n    end\n    \n    subgraph Signals[\"Custom Signal Emissions\"]\n        SIG_STATE[\"stateChanged\u003cbr/\u003eSignal\u0026lt;PlaybackState\u0026gt;\"]\n        SIG_POS[\"positionChanged\u003cbr/\u003eSignal\u0026lt;Duration\u0026gt;\"]\n        SIG_DUR[\"durationChanged\u003cbr/\u003eSignal\u0026lt;Duration\u0026gt;\"]\n        SIG_SPEC[\"spectrumUpdated\u003cbr/\u003eSignal\u0026lt;AudioSpectrum\u0026amp;\u0026gt;\"]\n        SIG_PCM[\"pcmReceived\u003cbr/\u003eSignal\u0026lt;vector\u0026lt;f32\u0026gt;, u32, u32, u32\u0026gt;\"]\n        SIG_TRACK[\"trackChanged\u003cbr/\u003eSignal\u0026lt;\u0026gt;\"]\n        SIG_ERR[\"errorSignal\u003cbr/\u003eSignal\u0026lt;std::string\u0026gt;\"]\n    end\n    \n    subgraph External[\"External Systems\"]\n        VIZ[\"VisualizerWindow\u003cbr/\u003eprojectM feeding\"]\n        REC[\"VideoRecorder\u003cbr/\u003ePCM capture\"]\n        UI[\"UI Controllers\u003cbr/\u003estate display\"]\n    end\n    \n    PLAYER --\u003e|\"audio output\"| OUTPUT\n    PLAYER --\u003e|\"buffer interception\"| BUFFER_OUT\n    PLAYER --\u003e|\"loads from\"| PLAYLIST\n    \n    BUFFER_OUT --\u003e|\"onAudioBufferReceived()\"| SCRATCH\n    SCRATCH --\u003e|\"analyze()\"| ANALYZER\n    ANALYZER --\u003e|\"updates\"| SPECTRUM\n    \n    SPECTRUM --\u003e SIG_SPEC\n    SCRATCH --\u003e SIG_PCM\n    STATE --\u003e SIG_STATE\n    \n    SIG_SPEC -.-\u003e|\"feeds\"| VIZ\n    SIG_PCM -.-\u003e|\"captures\"| REC\n    SIG_STATE -.-\u003e|\"updates\"| UI\n    SIG_POS -.-\u003e|\"updates\"| UI\n    SIG_TRACK -.-\u003e|\"updates\"| UI\n```\n\n**Component Relationships:**\n\n| Component | Type | Purpose |\n|-----------|------|---------|\n| `player_` | `QMediaPlayer` | Decodes audio files, manages playback state |\n| `audioOutput_` | `QAudioOutput` | Routes decoded audio to OS audio device |\n| `bufferOutput_` | `QAudioBufferOutput` | Intercepts decoded buffers for analysis |\n| `playlist_` | `Playlist` | Manages track list, navigation, persistence |\n| `analyzer_` | `AudioAnalyzer` | Performs FFT, generates spectrum data |\n| `scratchBuffer_` | `std::vector\u003cf32\u003e` | Zero-allocation reusable buffer for conversions |\n| `currentSpectrum_` | `AudioSpectrum` | Latest spectrum analysis result |\n\nSources: [src/audio/AudioEngine.hpp:26-124](), [src/audio/AudioEngine.cpp:12-81]()\n\n---\n\n## Initialization\n\nThe `init()` method initializes all Qt Multimedia components, establishes signal/slot connections, loads the last session playlist, and starts diagnostic timers. It returns a `Result\u003cvoid\u003e` type for error handling consistency.\n\n**Initialization Sequence:**\n\n1. **Create Audio Output**: Instantiates `QAudioOutput` with configured volume\n2. **Create Media Player**: Instantiates `QMediaPlayer`, connects it to audio output\n3. **Create Buffer Output**: Instantiates `QAudioBufferOutput` for buffer interception\n4. **Connect Qt Signals**: Binds 8 Qt signals to corresponding slots\n5. **Connect Playlist Signals**: Binds custom `Signal\u003c\u003e` emissions from `Playlist`\n6. **Load Last Session**: Restores playlist from `~/.config/chadvis-projectm-qt/last_session.m3u`\n7. **Start Diagnostic Timer**: 1-second interval to detect buffer starvation\n\n```mermaid\nsequenceDiagram\n    participant Client\n    participant AudioEngine\n    participant QMediaPlayer\n    participant QAudioOutput\n    participant QAudioBufferOutput\n    participant Playlist\n    \n    Client-\u003e\u003eAudioEngine: init()\n    AudioEngine-\u003e\u003eQAudioOutput: new QAudioOutput()\n    AudioEngine-\u003e\u003eQAudioOutput: setVolume(volume_)\n    AudioEngine-\u003e\u003eQMediaPlayer: new QMediaPlayer()\n    AudioEngine-\u003e\u003eQMediaPlayer: setAudioOutput(audioOutput_)\n    AudioEngine-\u003e\u003eQAudioBufferOutput: new QAudioBufferOutput()\n    AudioEngine-\u003e\u003eQMediaPlayer: setAudioBufferOutput(bufferOutput_)\n    AudioEngine-\u003e\u003eQMediaPlayer: connect signals (8 connections)\n    AudioEngine-\u003e\u003eQAudioBufferOutput: connect(audioBufferReceived)\n    AudioEngine-\u003e\u003ePlaylist: connect(currentChanged, changed)\n    AudioEngine-\u003e\u003eAudioEngine: loadLastPlaylist()\n    AudioEngine-\u003e\u003eAudioEngine: bufferCheckTimer_.start(1000)\n    AudioEngine--\u003e\u003eClient: Result\u0026lt;void\u0026gt;::ok()\n```\n\nSources: [src/audio/AudioEngine.cpp:19-81]()\n\n---\n\n## Playback Control\n\nThe engine exposes standard playback methods that wrap `QMediaPlayer` operations while managing playlist navigation and state synchronization.\n\n**Public Playback API:**\n\n| Method | Implementation | Notes |\n|--------|---------------|-------|\n| `play()` | Calls `player_-\u003eplay()` | Auto-loads first track if none selected |\n| `pause()` | Calls `player_-\u003epause()` | Retains playback position |\n| `stop()` | Calls `player_-\u003estop()`, resets `analyzer_` | Clears audio buffers |\n| `togglePlayPause()` | Conditional `play()`/`pause()` based on `state_` | Idempotent toggle |\n| `seek(Duration)` | Calls `player_-\u003esetPosition(ms)` | Position in milliseconds |\n| `setVolume(f32)` | Clamps to [0.0, 1.0], applies to `audioOutput_` | Volume normalization |\n\nThe `play()` method implements auto-loading logic to handle empty sources:\n\n```\nplay() logic:\n1. If no current playlist item but playlist not empty  jump to index 0\n2. If player source is empty but playlist has current item  loadCurrentTrack()\n3. If source still empty  log warning and return\n4. Call player_-\u003eplay()\n```\n\nSources: [src/audio/AudioEngine.cpp:83-145](), [src/audio/AudioEngine.hpp:35-56]()\n\n---\n\n## Audio Buffer Processing Pipeline\n\nThe core audio processing occurs in `processAudioBuffer()`, which is triggered by Qt's `audioBufferReceived` signal. This method converts arbitrary `QAudioBuffer` formats to normalized float samples, feeds them to the analyzer, and emits results.\n\n```mermaid\nflowchart TB\n    START[\"QAudioBufferOutput::audioBufferReceived\u003cbr/\u003e(QAudioBuffer)\"]\n    \n    SLOT[\"onAudioBufferReceived()\u003cbr/\u003eslot invocation\"]\n    \n    FLAG[\"Set bufferReceivedSinceLastCheck_\u003cbr/\u003efor diagnostics\"]\n    \n    PROCESS[\"processAudioBuffer()\u003cbr/\u003emain processing logic\"]\n    \n    CHECK{\"buffer.isValid()?\"}\n    \n    LOCK[\"std::lock_guard\u0026lt;std::mutex\u0026gt;\u003cbr/\u003eaudioMutex_\"]\n    \n    EXTRACT[\"Extract format metadata:\u003cbr/\u003esampleRate, channels, frameCount\"]\n    \n    RESIZE{\"scratchBuffer_.size()\u003cbr/\u003e\u0026lt; totalSamples?\"}\n    \n    GROW[\"scratchBuffer_.resize(totalSamples)\"]\n    \n    DETECT{\"format.sampleFormat()\"}\n    \n    FLOAT[\"Direct copy:\u003cbr/\u003estd::copy(f32*  scratchBuffer_)\"]\n    INT16[\"Convert Int16:\u003cbr/\u003edata[i] / 32768.0f\"]\n    INT32[\"Convert Int32:\u003cbr/\u003edata[i] / 2147483648.0f\"]\n    \n    ANALYZE[\"analyzer_.analyze()\u003cbr/\u003eFFT + spectrum extraction\"]\n    \n    UPDATE[\"currentSpectrum_ = result\"]\n    \n    EMIT_SPEC[\"spectrumUpdated.emitSignal(currentSpectrum_)\"]\n    \n    EMIT_PCM[\"pcmReceived.emitSignal(scratchBuffer_,\u003cbr/\u003eframeCount, channels, sampleRate)\"]\n    \n    END[\"Return\"]\n    \n    START --\u003e SLOT\n    SLOT --\u003e FLAG\n    FLAG --\u003e PROCESS\n    PROCESS --\u003e CHECK\n    CHECK --\u003e|\"false\"| END\n    CHECK --\u003e|\"true\"| LOCK\n    LOCK --\u003e EXTRACT\n    EXTRACT --\u003e RESIZE\n    RESIZE --\u003e|\"yes\"| GROW\n    RESIZE --\u003e|\"no\"| DETECT\n    GROW --\u003e DETECT\n    DETECT --\u003e|\"Float\"| FLOAT\n    DETECT --\u003e|\"Int16\"| INT16\n    DETECT --\u003e|\"Int32\"| INT32\n    FLOAT --\u003e ANALYZE\n    INT16 --\u003e ANALYZE\n    INT32 --\u003e ANALYZE\n    ANALYZE --\u003e UPDATE\n    UPDATE --\u003e EMIT_SPEC\n    EMIT_SPEC --\u003e EMIT_PCM\n    EMIT_PCM --\u003e END\n```\n\n**Format Conversion Details:**\n\nThe engine supports three `QAudioFormat::SampleFormat` types with appropriate normalization:\n\n- **Float**: Direct copy, already normalized to [-1.0, 1.0]\n- **Int16**: Divide by 32768.0 to normalize signed 16-bit range\n- **Int32**: Divide by 2147483648.0 to normalize signed 32-bit range\n\nThe `scratchBuffer_` is a reusable allocation that grows on-demand but never shrinks, minimizing allocator pressure during playback.\n\nSources: [src/audio/AudioEngine.cpp:232-274](), [src/audio/AudioEngine.cpp:191-197]()\n\n---\n\n## Signal Emission System\n\n`AudioEngine` uses a custom `Signal\u003cArgs...\u003e` template for type-safe, decoupled event emission. This pattern avoids Qt's `QObject` inheritance requirements for signals and allows C++-style functional binding.\n\n**Available Signals:**\n\n| Signal | Type Signature | Emitted When | Primary Consumers |\n|--------|---------------|--------------|-------------------|\n| `stateChanged` | `Signal\u003cPlaybackState\u003e` | `QMediaPlayer::playbackStateChanged` | UI controllers, visualizer |\n| `positionChanged` | `Signal\u003cDuration\u003e` | `QMediaPlayer::positionChanged` | Player controls, seek bar |\n| `durationChanged` | `Signal\u003cDuration\u003e` | `QMediaPlayer::durationChanged` | Player controls, total time display |\n| `spectrumUpdated` | `Signal\u003cconst AudioSpectrum\u0026\u003e` | After `analyzer_.analyze()` | ProjectMBridge, visualizer |\n| `pcmReceived` | `Signal\u003cconst vector\u003cf32\u003e\u0026, u32, u32, u32\u003e` | After buffer conversion | VideoRecorder (audio track) |\n| `trackChanged` | `Signal\u003c\u003e` | Playlist navigation | Overlay metadata update |\n| `errorSignal` | `Signal\u003cstd::string\u003e` | `QMediaPlayer::errorOccurred` | UI error display |\n\n**Qt Signal  Custom Signal Forwarding:**\n\nThe engine connects Qt's signals to private slots, which then emit custom signals:\n\n```\nQMediaPlayer::playbackStateChanged\n   onPlayerStateChanged(QMediaPlayer::PlaybackState)\n     state_ = convertToPlaybackState(state)\n     stateChanged.emitSignal(state_)\n```\n\nThis forwarding pattern decouples Qt's type system from internal signal consumers and allows multiple subscribers without Qt object overhead.\n\nSources: [src/audio/AudioEngine.hpp:75-83](), [src/audio/AudioEngine.cpp:147-189]()\n\n---\n\n## Playlist Integration\n\nThe engine owns a `Playlist` instance and connects to its custom signals for automatic track loading and playlist persistence.\n\n**Playlist Signal Bindings:**\n\n```cpp\n// src/audio/AudioEngine.cpp:60-62\nplaylist_.currentChanged.connect(\n    [this](usize index) { onPlaylistCurrentChanged(index); });\nplaylist_.changed.connect([this] { saveLastPlaylist(); });\n```\n\n**Automatic Track Loading:**\n\nWhen `playlist_.currentChanged` fires, the engine:\n\n1. Calls `loadCurrentTrack()` to update `QMediaPlayer::setSource()`\n2. Emits `trackChanged` signal for UI/overlay updates\n3. Calls `play()` to start playback immediately\n\nThis creates a seamless navigation experience where users can use playlist controls and playback begins instantly.\n\n**Persistent Playlist State:**\n\nThe engine saves the playlist to `~/.config/chadvis-projectm-qt/last_session.m3u` whenever the playlist changes. On initialization, it loads this file via `loadLastPlaylist()`, restoring the previous session's track list.\n\nSources: [src/audio/AudioEngine.cpp:199-230](), [src/audio/AudioEngine.hpp:57-63]()\n\n---\n\n## Thread Safety\n\nAudio buffer processing occurs on Qt's audio I/O thread, while UI interactions and state queries happen on the main thread. The engine protects shared audio data with a `std::mutex`.\n\n**Protected Data:**\n\n- `currentSpectrum_`: Latest spectrum analysis result\n- `scratchBuffer_`: Temporary PCM conversion buffer (accessed during processing)\n- `analyzer_.pcmData()`: Cached PCM data in analyzer\n\n**Locking Strategy:**\n\n```cpp\n// src/audio/AudioEngine.cpp:236\nvoid AudioEngine::processAudioBuffer(const QAudioBuffer\u0026 buffer) {\n    // ...\n    std::lock_guard lock(audioMutex_);\n    // All spectrum/PCM access happens within this scope\n}\n\n// src/audio/AudioEngine.hpp:66-73\nAudioSpectrum currentSpectrum() const {\n    std::lock_guard lock(audioMutex_);\n    return currentSpectrum_; // Copy by value\n}\n```\n\nThe engine returns copies of spectrum/PCM data rather than references, ensuring callers never hold pointers to mutating data structures.\n\nSources: [src/audio/AudioEngine.hpp:123](), [src/audio/AudioEngine.cpp:236](), [src/audio/AudioEngine.hpp:66-73]()\n\n---\n\n## Diagnostic Systems\n\nThe engine implements a diagnostic timer to detect audio buffer starvation, a common issue when `QAudioBufferOutput` fails to produce buffers.\n\n**Buffer Starvation Detection:**\n\n```cpp\n// src/audio/AudioEngine.cpp:68-77\nconnect(\u0026bufferCheckTimer_, \u0026QTimer::timeout, this, [this]() {\n    if (state_ == PlaybackState::Playing \u0026\u0026\n        !bufferReceivedSinceLastCheck_) {\n        LOG_WARN(\"AudioEngine: No audio buffers received in last 1000ms - \"\n                 \"QAudioBufferOutput may not be working\");\n    }\n    bufferReceivedSinceLastCheck_ = false;\n});\nbufferCheckTimer_.start(1000);\n```\n\nEvery second, the timer checks if `bufferReceivedSinceLastCheck_` was set. The flag is set in `onAudioBufferReceived()` and also reset when playback starts. If playback is active but no buffers arrived, it logs a warning.\n\n**Additional Logging:**\n\nThe engine logs diagnostic information at key points:\n\n- Initialization completion\n- Play/pause/stop invocations\n- Player state transitions with old/new state values\n- Track loading with filename\n- Buffer reception with validity and frame count\n\nSources: [src/audio/AudioEngine.cpp:68-77](), [src/audio/AudioEngine.cpp:191-197]()\n\n---\n\n## State Management\n\nThe engine maintains a simplified `PlaybackState` enum that maps from Qt's tri-state model:\n\n```cpp\nenum class PlaybackState { Stopped, Playing, Paused };\n```\n\n**State Transition Logic:**\n\n```\nQMediaPlayer::StoppedState   PlaybackState::Stopped\nQMediaPlayer::PlayingState   PlaybackState::Playing\nQMediaPlayer::PausedState    PlaybackState::Paused\n```\n\nThe `state_` member is updated in `onPlayerStateChanged()` and exposed via `state()` getter and `isPlaying()` convenience method. The `stateChanged` signal notifies subscribers of transitions.\n\n**End-of-Media Handling:**\n\n```cpp\n// src/audio/AudioEngine.cpp:182-189\nvoid AudioEngine::onMediaStatusChanged(QMediaPlayer::MediaStatus status) {\n    if (status == QMediaPlayer::EndOfMedia \u0026\u0026 autoPlayNext_) {\n        LOG_DEBUG(\"Track ended, playing next\");\n        if (!playlist_.next()) {\n            stop();\n        }\n    }\n}\n```\n\nWhen a track ends, the engine automatically advances to the next track if `autoPlayNext_` is enabled. If `playlist_.next()` returns false (end of playlist), it stops playback.\n\nSources: [src/audio/AudioEngine.hpp:24](), [src/audio/AudioEngine.cpp:147-189]()\n\n---\n\n## API Reference\n\n**Core Methods:**\n\n| Method | Signature | Description |\n|--------|-----------|-------------|\n| `init()` | `Result\u003cvoid\u003e` | Initialize Qt components, load last playlist |\n| `play()` | `void` | Start playback, auto-load track if needed |\n| `pause()` | `void` | Pause playback at current position |\n| `stop()` | `void` | Stop playback, reset analyzer state |\n| `togglePlayPause()` | `void` | Toggle between playing and paused states |\n| `seek()` | `void seek(Duration)` | Seek to absolute position |\n| `setVolume()` | `void setVolume(f32)` | Set volume in range [0.0, 1.0] |\n\n**State Queries:**\n\n| Method | Return Type | Description |\n|--------|-------------|-------------|\n| `state()` | `PlaybackState` | Current playback state |\n| `position()` | `Duration` | Current playback position in milliseconds |\n| `duration()` | `Duration` | Total track duration in milliseconds |\n| `volume()` | `f32` | Current volume [0.0, 1.0] |\n| `isPlaying()` | `bool` | Convenience check for `state_ == Playing` |\n\n**Data Access:**\n\n| Method | Return Type | Description |\n|--------|-------------|-------------|\n| `playlist()` | `Playlist\u0026` | Mutable reference to playlist |\n| `currentSpectrum()` | `AudioSpectrum` | Thread-safe copy of latest spectrum |\n| `currentPCM()` | `std::vector\u003cf32\u003e` | Thread-safe copy of latest PCM data |\n\nSources: [src/audio/AudioEngine.hpp:26-83]()"])</script><script>self.__next_f.push([1,"1f:T396d,"])</script><script>self.__next_f.push([1,"# Playlist Management\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [src/audio/AudioEngine.cpp](src/audio/AudioEngine.cpp)\n- [src/audio/AudioEngine.hpp](src/audio/AudioEngine.hpp)\n- [src/ui/MainWindow.cpp](src/ui/MainWindow.cpp)\n- [src/ui/MainWindow.hpp](src/ui/MainWindow.hpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document describes the playlist management system in chadvis-projectm-qt, which handles track organization, navigation, and persistence. The `Playlist` class maintains an ordered collection of audio tracks, supports M3U playlist files, and provides session continuity through automatic state restoration.\n\nFor information about audio playback and decoding, see [AudioEngine](#3.1). For UI components that display and interact with the playlist, see [Controller Layer](#7.2).\n\n**Sources:** [src/audio/AudioEngine.hpp:58-63](), [src/audio/AudioEngine.cpp:215-230]()\n\n---\n\n## Architecture Overview\n\nThe playlist system is embedded within the `AudioEngine` as a core component. It uses a signal-based architecture to notify the engine when track selection changes, triggering automatic track loading and playback.\n\n### Core Components\n\n| Component | Type | Purpose |\n|-----------|------|---------|\n| `Playlist` | Class | Manages track collection, navigation, and persistence |\n| `PlaylistItem` | Struct | Represents individual track with path and metadata |\n| `AudioEngine::playlist_` | Member | Playlist instance owned by AudioEngine |\n| `AudioEngine::onPlaylistCurrentChanged()` | Slot | Responds to track changes by loading and playing |\n\n**Diagram: Playlist Component Architecture**\n\n```mermaid\ngraph TB\n    subgraph \"AudioEngine\"\n        AE[\"AudioEngine\"]\n        PLAYLIST[\"Playlist\u003cbr/\u003eprivate member\"]\n        ON_CHANGE[\"onPlaylistCurrentChanged()\u003cbr/\u003eslot\"]\n    end\n    \n    subgraph \"Playlist Internal State\"\n        ITEMS[\"vector\u0026lt;PlaylistItem\u0026gt;\u003cbr/\u003etracks\"]\n        CURRENT_IDX[\"usize currentIndex\"]\n        SIGNALS[\"Signal\u0026lt;\u0026gt; changed\u003cbr/\u003eSignal\u0026lt;usize\u0026gt; currentChanged\"]\n    end\n    \n    subgraph \"External Interaction\"\n        UI[\"PlaylistView\u003cbr/\u003eUI Widget\"]\n        MAIN[\"MainWindow\"]\n        M3U_FILE[\"last_session.m3u\u003cbr/\u003ePersistence\"]\n    end\n    \n    AE --\u003e|\"owns\"| PLAYLIST\n    PLAYLIST --\u003e|\"contains\"| ITEMS\n    PLAYLIST --\u003e|\"tracks\"| CURRENT_IDX\n    PLAYLIST --\u003e|\"emits\"| SIGNALS\n    \n    SIGNALS --\u003e|\"currentChanged.connect()\"| ON_CHANGE\n    ON_CHANGE --\u003e|\"loadCurrentTrack()\"| AE\n    ON_CHANGE --\u003e|\"play()\"| AE\n    \n    MAIN --\u003e|\"audioEngine_-\u003eplaylist()\"| PLAYLIST\n    UI --\u003e|\"via AudioController\"| PLAYLIST\n    \n    PLAYLIST -.-\u003e|\"saveM3U()\"| M3U_FILE\n    M3U_FILE -.-\u003e|\"loadM3U()\"| PLAYLIST\n```\n\n**Sources:** [src/audio/AudioEngine.hpp:109](), [src/audio/AudioEngine.cpp:59-62](), [src/audio/AudioEngine.cpp:199-203]()\n\n---\n\n## PlaylistItem Structure\n\nEach track in the playlist is represented by a `PlaylistItem` structure containing the file path and metadata.\n\n### PlaylistItem Fields\n\n```cpp\nstruct PlaylistItem {\n    fs::path path;           // Absolute path to audio file\n    TrackMetadata metadata;  // Title, artist, album, duration, etc.\n};\n```\n\nThe `TrackMetadata` structure provides display information that can be extracted from file tags or derived from the filename. The metadata is used for:\n- Window title updates ([src/ui/MainWindow.cpp:288-298]())\n- Overlay engine text display ([src/ui/MainWindow.cpp:255-261]())\n- UI playlist display\n\n**Sources:** [src/audio/AudioEngine.cpp:206-213](), [src/ui/MainWindow.cpp:257-258](), [src/ui/MainWindow.cpp:290-291]()\n\n---\n\n## Track Management\n\n### Adding Tracks\n\nTracks can be added to the playlist through multiple pathways:\n\n**Diagram: Track Addition Flow**\n\n```mermaid\nflowchart TD\n    USER_ACTION[\"User Action\"]\n    \n    MENU_OPEN[\"File \u003e Open Files...\"]\n    MENU_FOLDER[\"File \u003e Open Folder...\"]\n    DRAG_DROP[\"Drag \u0026 Drop\"]\n    SUNO[\"Suno Download\"]\n    \n    ADD_PLAYLIST[\"MainWindow::addToPlaylist()\"]\n    CHECK_DIR{\"is_directory()?\"}\n    LIST_FILES[\"file::listFiles()\u003cbr/\u003erecursive scan\"]\n    \n    PLAYLIST_ADD[\"playlist_.addFile(path)\"]\n    SAVE_SESSION[\"saveLastPlaylist()\"]\n    \n    USER_ACTION --\u003e MENU_OPEN\n    USER_ACTION --\u003e MENU_FOLDER\n    USER_ACTION --\u003e DRAG_DROP\n    USER_ACTION --\u003e SUNO\n    \n    MENU_OPEN --\u003e ADD_PLAYLIST\n    MENU_FOLDER --\u003e ADD_PLAYLIST\n    DRAG_DROP --\u003e ADD_PLAYLIST\n    SUNO --\u003e PLAYLIST_ADD\n    \n    ADD_PLAYLIST --\u003e CHECK_DIR\n    CHECK_DIR --\u003e|\"yes\"| LIST_FILES\n    CHECK_DIR --\u003e|\"no\"| PLAYLIST_ADD\n    LIST_FILES --\u003e PLAYLIST_ADD\n    \n    PLAYLIST_ADD --\u003e SAVE_SESSION\n```\n\n**Adding Individual Files**\n\n```cpp\n// MainWindow.cpp:300-306\nvoid MainWindow::addToPlaylist(const fs::path\u0026 path) {\n    if (fs::is_directory(path)) {\n        for (const auto\u0026 f : file::listFiles(path, file::audioExtensions, true))\n            audioEngine_-\u003eplaylist().addFile(f);\n    } else\n        audioEngine_-\u003eplaylist().addFile(path);\n}\n```\n\nWhen a directory is added, the system recursively scans for audio files with supported extensions (mp3, flac, ogg, opus, wav, m4a, aac).\n\n**Sources:** [src/ui/MainWindow.cpp:300-311](), [src/ui/MainWindow.cpp:364-383](), [src/ui/MainWindow.cpp:453-468]()\n\n### Auto-save on Changes\n\nEvery modification to the playlist triggers the `changed` signal, which is connected to `saveLastPlaylist()`. This ensures the session is continuously persisted.\n\n```cpp\n// AudioEngine.cpp:62\nplaylist_.changed.connect([this] { saveLastPlaylist(); });\n```\n\n**Sources:** [src/audio/AudioEngine.cpp:62](), [src/audio/AudioEngine.cpp:226-230]()\n\n---\n\n## Navigation and Playback Control\n\nThe playlist provides methods for sequential and random access to tracks. Navigation automatically triggers track loading and playback through the signal mechanism.\n\n### Navigation Methods\n\n| Method | Description | Returns |\n|--------|-------------|---------|\n| `next()` | Advance to next track | `bool` - true if successful |\n| `previous()` | Go to previous track | `bool` - true if successful |\n| `jumpTo(usize index)` | Jump to specific index | `void` |\n| `currentItem()` | Get current track item | `const PlaylistItem*` |\n| `currentIndex()` | Get current track index | `usize` |\n| `empty()` | Check if playlist is empty | `bool` |\n\n**Diagram: Navigation Signal Flow**\n\n```mermaid\nsequenceDiagram\n    participant UI as \"UI Component\"\n    participant PLAYLIST as \"Playlist\"\n    participant AE as \"AudioEngine\"\n    participant PLAYER as \"QMediaPlayer\"\n    \n    UI-\u003e\u003ePLAYLIST: next() or previous()\n    PLAYLIST-\u003e\u003ePLAYLIST: update currentIndex\n    PLAYLIST-\u003e\u003eAE: currentChanged.emitSignal(index)\n    \n    AE-\u003e\u003eAE: onPlaylistCurrentChanged(index)\n    AE-\u003e\u003eAE: loadCurrentTrack()\n    AE-\u003e\u003eAE: \"get playlist_.currentItem()\"\n    AE-\u003e\u003ePLAYER: setSource(QUrl)\n    AE-\u003e\u003ePLAYER: play()\n    AE-\u003e\u003eAE: \"emit trackChanged signal\"\n    \n    Note over UI,PLAYER: Track metadata propagates to UI via trackChanged\n```\n\n**Sources:** [src/ui/MainWindow.cpp:158-164](), [src/audio/AudioEngine.cpp:59-61](), [src/audio/AudioEngine.cpp:199-203]()\n\n### Auto-play on Track End\n\nWhen a track finishes playing, the `AudioEngine` automatically advances to the next track if `autoPlayNext_` is enabled:\n\n```cpp\n// AudioEngine.cpp:182-189\nvoid AudioEngine::onMediaStatusChanged(QMediaPlayer::MediaStatus status) {\n    if (status == QMediaPlayer::EndOfMedia \u0026\u0026 autoPlayNext_) {\n        LOG_DEBUG(\"Track ended, playing next\");\n        if (!playlist_.next()) {\n            stop();\n        }\n    }\n}\n```\n\n**Sources:** [src/audio/AudioEngine.cpp:182-189]()\n\n### Initial Playback\n\nWhen `play()` is called on an empty player state, the engine automatically loads the first track:\n\n```cpp\n// AudioEngine.cpp:89-92\nif (!playlist_.currentItem() \u0026\u0026 !playlist_.empty()) {\n    playlist_.jumpTo(0);\n    LOG_INFO(\"Jumped to first playlist item\");\n}\n```\n\n**Sources:** [src/audio/AudioEngine.cpp:83-109]()\n\n---\n\n## M3U Persistence\n\nThe playlist system supports the M3U playlist format for both import/export and session restoration. M3U files are plain-text playlists containing file paths, one per line.\n\n### M3U Operations\n\n**Diagram: M3U File Lifecycle**\n\n```mermaid\ngraph LR\n    subgraph \"User Actions\"\n        SAVE_ACTION[\"File \u003e Save Playlist...\"]\n        LOAD_ACTION[\"File \u003e Load Playlist...\"]\n    end\n    \n    subgraph \"MainWindow Handlers\"\n        ON_SAVE[\"onSavePlaylist()\"]\n        ON_LOAD[\"onLoadPlaylist()\"]\n        FILE_DLG[\"QFileDialog\"]\n    end\n    \n    subgraph \"Playlist Methods\"\n        SAVE_M3U[\"playlist_.saveM3U(path)\"]\n        LOAD_M3U[\"playlist_.loadM3U(path)\"]\n    end\n    \n    subgraph \"File System\"\n        USER_M3U[\"user_playlist.m3u\"]\n        SESSION_M3U[\"~/.config/chadvis-projectm-qt/\u003cbr/\u003elast_session.m3u\"]\n    end\n    \n    SAVE_ACTION --\u003e ON_SAVE\n    LOAD_ACTION --\u003e ON_LOAD\n    \n    ON_SAVE --\u003e FILE_DLG\n    ON_LOAD --\u003e FILE_DLG\n    \n    FILE_DLG --\u003e SAVE_M3U\n    FILE_DLG --\u003e LOAD_M3U\n    \n    SAVE_M3U --\u003e USER_M3U\n    LOAD_M3U --\u003e USER_M3U\n    \n    SAVE_M3U -.-\u003e|\"auto-save\"| SESSION_M3U\n    SESSION_M3U -.-\u003e|\"on init\"| LOAD_M3U\n```\n\n**Save Playlist Dialog**\n\n```cpp\n// MainWindow.cpp:385-395\nvoid MainWindow::onSavePlaylist() {\n    QString path = QFileDialog::getSaveFileName(\n        this, \"Save Playlist\", QDir::homePath(),\n        \"M3U Playlist (*.m3u)\", nullptr,\n        QFileDialog::DontUseNativeDialog);\n    if (!path.isEmpty())\n        audioEngine_-\u003eplaylist().saveM3U(path.toStdString());\n}\n```\n\n**Load Playlist Dialog**\n\n```cpp\n// MainWindow.cpp:397-407\nvoid MainWindow::onLoadPlaylist() {\n    QString path = QFileDialog::getOpenFileName(\n        this, \"Load Playlist\", QDir::homePath(),\n        \"M3U Playlist (*.m3u *.m3u8)\", nullptr,\n        QFileDialog::DontUseNativeDialog);\n    if (!path.isEmpty())\n        audioEngine_-\u003eplaylist().loadM3U(path.toStdString());\n}\n```\n\n**Sources:** [src/ui/MainWindow.cpp:385-407](), [src/ui/MainWindow.cpp:138-140]()\n\n---\n\n## Session Restoration\n\nThe playlist automatically saves and restores state between application sessions using a dedicated `last_session.m3u` file.\n\n### Automatic Session Management\n\n**Session Save Location**\n\n```cpp\n// AudioEngine.cpp:226-230\nvoid AudioEngine::saveLastPlaylist() {\n    auto path = file::configDir() / \"last_session.m3u\";\n    file::ensureDir(path.parent_path());\n    playlist_.saveM3U(path);\n}\n```\n\nThe configuration directory is typically `~/.config/chadvis-projectm-qt/` on Linux systems.\n\n**Session Restore on Init**\n\n```cpp\n// AudioEngine.cpp:215-224\nvoid AudioEngine::loadLastPlaylist() {\n    auto path = file::configDir() / \"last_session.m3u\";\n    if (fs::exists(path)) {\n        LOG_INFO(\"Loading last session playlist...\");\n        playlist_.loadM3U(path);\n        // Note: Current index restoration not yet implemented\n    }\n}\n```\n\nThe session restoration is called during `AudioEngine::init()` ([src/audio/AudioEngine.cpp:65]()), ensuring the previous session's playlist is available immediately on startup.\n\n**Trigger Points for Auto-save**\n\nThe playlist is automatically saved when:\n1. **Any track is added** - via the `changed` signal connection ([src/audio/AudioEngine.cpp:62]())\n2. **Application closes** - MainWindow saves config, triggering final save ([src/ui/MainWindow.cpp:439]())\n\n**Sources:** [src/audio/AudioEngine.cpp:64-65](), [src/audio/AudioEngine.cpp:215-230]()\n\n---\n\n## Shuffle and Repeat Modes\n\nThe purpose section mentions shuffle and repeat modes as features of the playlist system. While the specific implementation details are not visible in the provided code files, these modes would typically be implemented as:\n\n- **Shuffle Mode**: Randomize track order or select next track randomly\n- **Repeat Modes**: All (loop playlist), One (loop current track), None\n\nThese modes would be controlled through configuration flags and would affect the behavior of `next()` and the auto-play logic in `onMediaStatusChanged()`.\n\n**Sources:** Purpose statement from table of contents\n\n---\n\n## Integration with UI\n\n### MainWindow Menu Actions\n\nThe playlist is accessible through the File menu with keyboard shortcuts:\n\n| Action | Shortcut | Handler |\n|--------|----------|---------|\n| Open Files... | Ctrl+O | `onOpenFiles()` |\n| Open Folder... | Ctrl+Shift+O | `onOpenFolder()` |\n| Save Playlist... | - | `onSavePlaylist()` |\n| Load Playlist... | - | `onLoadPlaylist()` |\n\n**Playback menu actions** also directly access the playlist:\n\n```cpp\n// MainWindow.cpp:158-164\nplaybackMenu-\u003eaddAction(\"\u0026Next\", this,\n    [this] { audioEngine_-\u003eplaylist().next(); },\n    QKeySequence(Qt::Key_N));\nplaybackMenu-\u003eaddAction(\"\u0026Previous\", this,\n    [this] { audioEngine_-\u003eplaylist().previous(); },\n    QKeySequence(Qt::Key_P));\n```\n\n**Sources:** [src/ui/MainWindow.cpp:128-164](), [src/ui/MainWindow.cpp:138-140]()\n\n### PlaylistView Widget\n\nThe `PlaylistView` widget provides visual representation of the playlist. It is configured by the `AudioController` through the controller pattern:\n\n```cpp\n// MainWindow.cpp:101-104, 123\nplaylistView_ = new PlaylistView(this);\n// ... later ...\naudioController_-\u003esetupUI(playerControls_, playlistView_);\n```\n\nThe `PlaylistView` is displayed in the right tools dock under the \"Playlist\" tab.\n\n**Sources:** [src/ui/MainWindow.cpp:101-104](), [src/ui/MainWindow.cpp:123]()\n\n### Drag-and-Drop Support\n\nThe main window accepts file drops and adds them to the playlist:\n\n```cpp\n// MainWindow.cpp:457-468\nvoid MainWindow::dropEvent(QDropEvent* event) {\n    QStringList paths;\n    for (const auto\u0026 url : event-\u003emimeData()-\u003eurls())\n        if (url.isLocalFile())\n            paths.append(url.toLocalFile());\n    if (!paths.isEmpty()) {\n        for (const auto\u0026 p : paths)\n            addToPlaylist(fs::path(p.toStdString()));\n        statusBar()-\u003eshowMessage(\n            QString(\"Added %1 files to playlist\").arg(paths.size()));\n    }\n}\n```\n\n**Sources:** [src/ui/MainWindow.cpp:40](), [src/ui/MainWindow.cpp:453-468]()\n\n---\n\n## Summary\n\nThe playlist management system provides:\n\n1. **Centralized Track Management** - Single `Playlist` instance owned by `AudioEngine`\n2. **Signal-Based Integration** - Automatic track loading via `currentChanged` signal\n3. **Persistent State** - Auto-save to `last_session.m3u` with session restoration\n4. **M3U Import/Export** - Standard playlist file format support\n5. **Navigation API** - `next()`, `previous()`, `jumpTo()` methods\n6. **UI Integration** - Menu actions, drag-drop, and dedicated `PlaylistView` widget\n\nThe architecture ensures that playlist changes immediately propagate to the audio engine and UI components through the signal system, maintaining synchronization across the application.\n\n**Sources:** [src/audio/AudioEngine.hpp:58-63](), [src/audio/AudioEngine.cpp:59-65](), [src/ui/MainWindow.cpp:300-311]()"])</script><script>self.__next_f.push([1,"20:T43ed,"])</script><script>self.__next_f.push([1,"# Visualization System\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AGENTS.md](AGENTS.md)\n- [src/ui/VisualizerPanel.cpp](src/ui/VisualizerPanel.cpp)\n- [src/visualizer/PresetManager.cpp](src/visualizer/PresetManager.cpp)\n- [src/visualizer/PresetManager.hpp](src/visualizer/PresetManager.hpp)\n- [src/visualizer/ProjectMBridge.cpp](src/visualizer/ProjectMBridge.cpp)\n- [src/visualizer/VisualizerWindow.cpp](src/visualizer/VisualizerWindow.cpp)\n- [src/visualizer/VisualizerWindow.hpp](src/visualizer/VisualizerWindow.hpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThe Visualization System transforms audio spectrum data into real-time graphics using the projectM v4 library. It manages the OpenGL rendering pipeline, preset (.milk file) selection and loading, frame capture for video recording, and user interaction with the visualizer display.\n\nThis page covers the high-level architecture and data flow through the visualization pipeline. For details on the OpenGL rendering window and frame capture mechanics, see [VisualizerWindow](#4.1). For projectM library integration specifics, see [ProjectM Integration](#4.2). For preset file management, see [Preset Management](#4.3).\n\n## System Architecture\n\nThe Visualization System consists of three primary components working in coordination:\n\n| Component | Responsibility |\n|-----------|---------------|\n| `VisualizerWindow` | QWindow with OpenGL context, orchestrates rendering loop and frame capture |\n| `ProjectMBridge` | Wraps projectM v4 C API, manages audio feeding and preset loading |\n| `PresetManager` | Scans, filters, and navigates .milk preset files |\n\nAdditional supporting components include `RenderTarget` for FBO management, PBOs for asynchronous frame capture, and integration points with `OverlayEngine` for text compositing.\n\n**System Component Relationships**\n\n```mermaid\ngraph TB\n    subgraph \"VisualizerWindow [QWindow]\"\n        CONTEXT[\"QOpenGLContext\u003cbr/\u003eCore 3.3 Profile\"]\n        RENDER_TIMER[\"QTimer renderTimer_\u003cbr/\u003eDrives render loop\"]\n        FPS_TIMER[\"QTimer fpsTimer_\u003cbr/\u003e1000ms interval\"]\n        PRESET_ROT[\"QTimer presetRotationTimer_\u003cbr/\u003eAuto-advance timer\"]\n    end\n    \n    subgraph \"ProjectMBridge\"\n        PM_HANDLE[\"projectm_handle projectM_\u003cbr/\u003eC API handle\"]\n        PRESET_MGR[\"PresetManager presets_\"]\n        PRESET_LOCKED[\"bool presetLocked_\"]\n    end\n    \n    subgraph \"PresetManager\"\n        PRESETS[\"vector\u003cPresetInfo\u003e presets_\"]\n        FAVORITES[\"set\u003cstring\u003e favoriteNames_\"]\n        BLACKLIST[\"set\u003cstring\u003e blacklistedNames_\"]\n        HISTORY[\"vector\u003cusize\u003e history_\"]\n    end\n    \n    subgraph \"Rendering Resources\"\n        RENDER_TARGET[\"RenderTarget renderTarget_\u003cbr/\u003eFBO for projectM output\"]\n        OVERLAY_TARGET[\"RenderTarget overlayTarget_\u003cbr/\u003eFBO for compositing\"]\n        PBOS[\"GLuint pbos_[2]\u003cbr/\u003eDouble-buffered capture\"]\n    end\n    \n    subgraph \"Audio Pipeline\"\n        AUDIO_MUTEX[\"mutex audioMutex_\"]\n        AUDIO_QUEUE[\"vector\u003cf32\u003e audioQueue_\u003cbr/\u003eInterleaved stereo PCM\"]\n    end\n    \n    CONTEXT --\u003e|\"owns\"| RENDER_TARGET\n    CONTEXT --\u003e|\"owns\"| OVERLAY_TARGET\n    CONTEXT --\u003e|\"owns\"| PBOS\n    \n    RENDER_TIMER --\u003e|\"timeout() signal\"| RENDER_FRAME[\"renderFrame()\"]\n    FPS_TIMER --\u003e|\"timeout() signal\"| UPDATE_FPS[\"updateFPS()\"]\n    PRESET_ROT --\u003e|\"timeout() signal\"| NEXT_PRESET[\"nextPreset()\"]\n    \n    RENDER_FRAME --\u003e|\"feeds audio\"| PM_HANDLE\n    RENDER_FRAME --\u003e|\"renders to\"| RENDER_TARGET\n    \n    PM_HANDLE --\u003e|\"owns\"| PRESET_MGR\n    PRESET_MGR --\u003e|\"presetChanged signal\"| PM_HANDLE\n    \n    AUDIO_QUEUE --\u003e|\"protected by\"| AUDIO_MUTEX\n    \n    style CONTEXT fill:#f9f9f9\n    style PM_HANDLE fill:#f9f9f9\n    style PRESET_MGR fill:#f9f9f9\n```\n\nSources: [src/visualizer/VisualizerWindow.hpp:23-122](), [src/visualizer/ProjectMBridge.cpp:1-170](), [src/visualizer/PresetManager.hpp:1-109]()\n\n## Audio-to-Visual Data Flow\n\nAudio spectrum data flows from `AudioEngine` to the visualizer through a queued pipeline. The `VisualizerWindow` receives PCM samples via `feedAudio()`, buffers them in a thread-safe queue, and feeds calculated frame counts to projectM's analysis engine.\n\n**Audio Feeding Pipeline**\n\n```mermaid\nflowchart LR\n    subgraph \"AudioEngine\"\n        PCM_OUT[\"PCM f32 samples\u003cbr/\u003eInterleaved stereo\"]\n    end\n    \n    subgraph \"VisualizerWindow\"\n        FEED_AUDIO[\"feedAudio()\u003cbr/\u003eline 290-300\"]\n        MUTEX[\"std::lock_guard\u003cbr/\u003eaudioMutex_\"]\n        QUEUE[\"audioQueue_\u003cbr/\u003evector\u003cf32\u003e\"]\n    end\n    \n    subgraph \"Render Loop\"\n        RENDER_FRAME[\"renderFrame()\u003cbr/\u003eline 133-237\"]\n        CALC_FRAMES[\"Calculate frames to feed\u003cbr/\u003e(sampleRate + fps - 1) / fps\"]\n        FEED_PM[\"projectM_.addPCMDataInterleaved()\u003cbr/\u003eline 160-162\"]\n    end\n    \n    subgraph \"ProjectMBridge\"\n        ADD_PCM[\"addPCMDataInterleaved()\u003cbr/\u003eline 90-99\"]\n        PM_API[\"projectm_pcm_add_float()\u003cbr/\u003eC API call\"]\n    end\n    \n    subgraph \"projectM v4 Library\"\n        SPECTRUM[\"Spectrum Analysis\u003cbr/\u003eFFT + Beat Detection\"]\n        PRESETS[\"Preset Rendering\u003cbr/\u003eMath expressions\"]\n    end\n    \n    PCM_OUT --\u003e FEED_AUDIO\n    FEED_AUDIO --\u003e MUTEX\n    MUTEX --\u003e QUEUE\n    \n    RENDER_FRAME --\u003e|\"lock audioMutex_\"| QUEUE\n    QUEUE --\u003e CALC_FRAMES\n    CALC_FRAMES --\u003e FEED_PM\n    FEED_PM --\u003e ADD_PCM\n    ADD_PCM --\u003e PM_API\n    \n    PM_API --\u003e SPECTRUM\n    SPECTRUM --\u003e PRESETS\n```\n\nSources: [src/visualizer/VisualizerWindow.cpp:153-166](), [src/visualizer/VisualizerWindow.cpp:290-300](), [src/visualizer/ProjectMBridge.cpp:90-99]()\n\nThe frame calculation uses the formula `(audioSampleRate + targetFps - 1) / targetFps` to determine how many audio frames to feed per video frame. This ensures projectM always has sufficient audio data for smooth spectrum analysis, even when frame rates and sample rates don't divide evenly.\n\n## Rendering Modes\n\n`VisualizerWindow` supports two rendering paths, selected dynamically based on system state:\n\n### Direct Rendering (Peak Performance Mode)\n\nWhen not recording and `lowResourceMode` is disabled, projectM renders directly to the default framebuffer. This path eliminates FBO overhead and achieves maximum frame rates.\n\n```cpp\n// Direct rendering path\nprojectM_.resetViewport(w, h);\nprojectM_.render();\n```\n\nSources: [src/visualizer/VisualizerWindow.cpp:215-229]()\n\n### FBO Rendering (Recording/Low Resource Mode)\n\nWhen recording or in low resource mode, projectM renders to an offscreen FBO. This enables:\n- Resolution-independent recording (e.g., render at 1920x1080 regardless of window size)\n- Downscaled rendering for performance (e.g., render at half resolution when CPU-bound)\n- Frame capture via PBOs without stalling the GPU\n\nThe system uses two FBOs:\n- `renderTarget_`: projectM output with depth buffer [src/visualizer/VisualizerWindow.cpp:96]()\n- `overlayTarget_`: Compositing target without depth buffer [src/visualizer/VisualizerWindow.cpp:97]()\n\nSources: [src/visualizer/VisualizerWindow.cpp:139-214]()\n\n**FBO Rendering Flow**\n\n```mermaid\nflowchart TB\n    CHECK_MODE[\"useFBO = recording_ || lowResourceMode\"]\n    \n    subgraph \"Resolution Calculation\"\n        CALC_RES[\"renderW, renderH = \u003cbr/\u003erecording ? recordWidth_, recordHeight_\u003cbr/\u003elowResourceMode ? max(160, w/2), max(120, h/2)\u003cbr/\u003eelse w, h\"]\n    end\n    \n    subgraph \"FBO Path\"\n        BIND_RENDER[\"renderTarget_.bind()\"]\n        PM_RENDER[\"projectm_opengl_render_frame()\"]\n        UNBIND_RENDER[\"renderTarget_.unbind()\"]\n    end\n    \n    subgraph \"Recording Capture\"\n        BIND_OVERLAY[\"overlayTarget_.bind()\"]\n        BLIT[\"renderTarget_.blitTo(overlayTarget_)\"]\n        OVERLAY_RENDER[\"overlayEngine_-\u003erender()\"]\n        CAPTURE[\"captureAsync() via PBOs\"]\n        EMIT[\"emit frameCaptured()\"]\n    end\n    \n    subgraph \"Screen Output\"\n        BIND_DEFAULT[\"glBindFramebuffer(0)\"]\n        CLEAR[\"glClear()\"]\n        BLIT_SCREEN[\"renderTarget_.blitToScreen()\"]\n    end\n    \n    CHECK_MODE --\u003e|\"true\"| CALC_RES\n    CALC_RES --\u003e BIND_RENDER\n    BIND_RENDER --\u003e PM_RENDER\n    PM_RENDER --\u003e UNBIND_RENDER\n    \n    UNBIND_RENDER --\u003e|\"if recording\"| BIND_OVERLAY\n    BIND_OVERLAY --\u003e BLIT\n    BLIT --\u003e OVERLAY_RENDER\n    OVERLAY_RENDER --\u003e CAPTURE\n    CAPTURE --\u003e EMIT\n    \n    UNBIND_RENDER --\u003e BIND_DEFAULT\n    BIND_DEFAULT --\u003e CLEAR\n    CLEAR --\u003e BLIT_SCREEN\n```\n\nSources: [src/visualizer/VisualizerWindow.cpp:168-214]()\n\nThe FBO path conditionally resizes render targets when dimensions change, ensuring projectM's internal state remains synchronized with the render resolution [src/visualizer/VisualizerWindow.cpp:170-174]().\n\n## Preset Management\n\nPresets are `.milk` files containing math expressions and rendering parameters that define visual styles. The `PresetManager` class handles discovery, filtering, and navigation of preset libraries.\n\n**Preset Lifecycle**\n\n```mermaid\nstateDiagram-v2\n    [*] --\u003e Scanning\n    Scanning --\u003e Loaded: scan() completed\n    Loaded --\u003e Selected: selectByIndex/Name/Path\n    Selected --\u003e Active: presetChanged signal\n    Active --\u003e Loading: loadPresetFromManager()\n    Loading --\u003e Rendering: projectm_load_preset_file()\n    Rendering --\u003e Selected: nextPreset/previousPreset\n    Selected --\u003e [*]: shutdown()\n    \n    Loaded --\u003e Filtering: setFavorite/setBlacklisted\n    Filtering --\u003e Loaded: state updated\n    \n    note right of Scanning\n        scan() reads directory\n        Parses .milk files\n        Applies favorites/blacklist\n    end note\n    \n    note right of Loading\n        Mutex-protected\n        presetLoading_ flag set\n        Renders black frame\n    end note\n```\n\nSources: [src/visualizer/PresetManager.cpp:12-71](), [src/visualizer/VisualizerWindow.cpp:357-382]()\n\n### Preset Selection and History\n\n`PresetManager` maintains a navigation history with forward/backward support. When `selectByIndex()` is called, the index is appended to history unless navigating through existing history entries [src/visualizer/PresetManager.cpp:125-155]().\n\n```cpp\n// History-aware navigation\nif (!history_.empty() \u0026\u0026 historyPosition_ \u003c history_.size() - 1) {\n    historyPosition_++;\n    currentIndex_ = history_[historyPosition_];\n}\n```\n\nSources: [src/visualizer/PresetManager.cpp:260-267]()\n\n### Favorites and Blacklisting\n\nPreset states persist to `preset_state.txt` in INI-style format:\n\n```\n[favorites]\npreset_name_1\npreset_name_2\n\n[blacklist]\nbroken_preset_name\n```\n\nThe system uses `std::set\u003cstd::string\u003e` for O(log n) lookups when filtering active presets [src/visualizer/PresetManager.hpp:102-103]().\n\nSources: [src/visualizer/PresetManager.cpp:414-464]()\n\n## Initialization Sequence\n\nThe `VisualizerWindow` initialization follows a strict ordering to ensure OpenGL resources are created in a valid context:\n\n| Step | Function | Action |\n|------|----------|--------|\n| 1 | `exposeEvent()` | Triggers initialization when window becomes visible |\n| 2 | `initialize()` | Creates OpenGL context and makes it current |\n| 3 | GLEW init | Loads OpenGL extensions via `glewInit()` |\n| 4 | `projectM_.init()` | Creates projectM handle, loads presets |\n| 5 | FBO creation | `renderTarget_.create()` with depth, `overlayTarget_.create()` without |\n| 6 | Timer start | `renderTimer_.start()`, `fpsTimer_.start()`, optional `presetRotationTimer_` |\n| 7 | Context release | `context_-\u003edoneCurrent()` before returning to event loop |\n\nSources: [src/visualizer/VisualizerWindow.cpp:44-114]()\n\n**OpenGL Context Configuration**\n\nThe context uses OpenGL 3.3 Core profile with double buffering and 4x MSAA:\n\n```cpp\nQSurfaceFormat format;\nformat.setVersion(3, 3);\nformat.setProfile(QSurfaceFormat::CoreProfile);\nformat.setSwapBehavior(QSurfaceFormat::DoubleBuffer);\nformat.setSwapInterval(1);  // VSync\nformat.setSamples(4);        // 4x MSAA\nformat.setDepthBufferSize(24);\n```\n\nSources: [src/visualizer/VisualizerWindow.cpp:15-23]()\n\n## Recording Integration\n\nWhen recording starts, `VisualizerWindow` switches to FBO rendering mode and allocates double-buffered PBOs for asynchronous frame capture. The PBO system eliminates GPU stalls by allowing the CPU to read from one PBO while the GPU writes to the other.\n\n**Double-Buffered PBO Capture**\n\n```mermaid\nsequenceDiagram\n    participant RT as \"RenderTarget FBO\"\n    participant PBO0 as \"PBO[0]\"\n    participant PBO1 as \"PBO[1]\"\n    participant CPU as \"CPU Memory\"\n    \n    Note over RT,CPU: Frame N\n    RT-\u003e\u003ePBO0: glReadPixels (async DMA)\n    Note over PBO1: Previous frame ready\n    PBO1-\u003e\u003eCPU: glMapBuffer (copy)\n    CPU-\u003e\u003eCPU: emit frameCaptured()\n    \n    Note over RT,CPU: Frame N+1\n    RT-\u003e\u003ePBO1: glReadPixels (async DMA)\n    Note over PBO0: Previous frame ready\n    PBO0-\u003e\u003eCPU: glMapBuffer (copy)\n    CPU-\u003e\u003eCPU: emit frameCaptured()\n    \n    Note over RT,CPU: Frame N+2\n    RT-\u003e\u003ePBO0: glReadPixels (async DMA)\n```\n\nSources: [src/visualizer/VisualizerWindow.cpp:258-288]()\n\nThe `captureAsync()` function implements the ping-pong buffer pattern:\n\n```cpp\nu32 nextIndex = (pboIndex_ + 1) % 2;\nglBindBuffer(GL_PIXEL_PACK_BUFFER, pbos_[pboIndex_]);\nglReadPixels(0, 0, recordWidth_, recordHeight_, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);\n\nif (pboAvailable_) {\n    glBindBuffer(GL_PIXEL_PACK_BUFFER, pbos_[nextIndex]);\n    u8* ptr = (u8*)glMapBuffer(GL_PIXEL_PACK_BUFFER, GL_READ_ONLY);\n    if (ptr) {\n        std::vector\u003cu8\u003e buffer(ptr, ptr + size);\n        glUnmapBuffer(GL_PIXEL_PACK_BUFFER);\n        emit frameCaptured(std::move(buffer), recordWidth_, recordHeight_, timestamp);\n    }\n}\npboIndex_ = nextIndex;\npboAvailable_ = true;\n```\n\nSources: [src/visualizer/VisualizerWindow.cpp:258-288]()\n\n## Performance Characteristics\n\n### Frame Rate Management\n\nThe render timer interval directly controls visualization frame rate. When `setRenderRate(fps)` is called, it configures both the `renderTimer_` period and projectM's internal FPS setting:\n\n```cpp\nrenderTimer_.start(1000 / fps);\nprojectM_.setFPS(fps);\n```\n\nSources: [src/visualizer/VisualizerWindow.cpp:302-309]()\n\nThe `fpsTimer_` runs independently at 1-second intervals to calculate actual achieved frame rate, which may differ from target FPS due to system load [src/visualizer/VisualizerWindow.cpp:351-355]().\n\n### Low Resource Mode\n\nWhen `CONFIG.visualizer().lowResourceMode` is enabled, render resolution is halved with a minimum floor:\n\n```cpp\nrenderW = std::max(160u, w / 2);\nrenderH = std::max(120u, h / 2);\n```\n\nThis reduces GPU fill rate requirements by approximately 75% while maintaining acceptable visual quality on lower-end hardware.\n\nSources: [src/visualizer/VisualizerWindow.cpp:147-150]()\n\n## Configuration Integration\n\nVisualization settings are read from the `CONFIG.visualizer()` section and applied during initialization and via `updateSettings()`:\n\n| Config Field | Usage | Applied Via |\n|--------------|-------|-------------|\n| `fps` | Render timer interval | `setRenderRate()` |\n| `beatSensitivity` | projectM beat detection threshold | `projectm_set_beat_sensitivity()` |\n| `presetPath` | Directory to scan for .milk files | `PresetManager::scan()` |\n| `presetDuration` | Auto-advance interval (seconds) | `presetRotationTimer_.setInterval()` |\n| `smoothPresetDuration` | Transition fade time | `projectm_set_soft_cut_duration()` |\n| `shufflePresets` | Random vs sequential selection | `PresetManager::selectRandom()` or `selectNext()` |\n| `useDefaultPreset` | Skip preset loading, use built-in | Skips `PresetManager` operations |\n| `lowResourceMode` | Enable half-resolution rendering | FBO size calculation |\n\nSources: [src/visualizer/VisualizerWindow.cpp:75-99](), [src/visualizer/VisualizerWindow.cpp:384-396]()\n\n## User Interaction\n\n`VisualizerWindow` handles keyboard and mouse events for direct visualizer control:\n\n**Keyboard Shortcuts**\n\n| Key | Action | Implementation |\n|-----|--------|----------------|\n| F11 or configured key | Toggle fullscreen | `toggleFullscreen()` |\n| Right arrow or configured | Next preset | `projectM_.nextPreset()` |\n| Left arrow or configured | Previous preset | `projectM_.previousPreset()` |\n| R | Random preset | `projectM_.randomPreset()` |\n| L | Lock/unlock preset | `projectM_.lockPreset(!locked)` |\n| Escape (in fullscreen) | Exit fullscreen | `toggleFullscreen()` |\n\n**Mouse Interaction**\n\nDouble-clicking the visualizer window toggles fullscreen mode [src/visualizer/VisualizerWindow.cpp:419-423]().\n\nSources: [src/visualizer/VisualizerWindow.cpp:398-423]()\n\n## Signal Emissions\n\n`VisualizerWindow` emits several Qt signals for UI synchronization:\n\n| Signal | Emitted When | Typical Handler |\n|--------|--------------|-----------------|\n| `presetNameUpdated(QString)` | Preset finishes loading | Updates `VisualizerPanel` label |\n| `frameReady()` | Frame render completes during recording | Signals recording system |\n| `frameCaptured(vector\u003cu8\u003e, u32, u32, i64)` | PBO capture completes | Queues frame to `VideoRecorder` |\n| `fpsChanged(f32)` | FPS timer ticks (1 Hz) | Updates FPS display |\n\nAdditionally, `ProjectMBridge` uses custom `Signal\u003cT\u003e` for non-QObject communication:\n- `ProjectMBridge::presetChanged`: Emitted when preset selection changes [src/visualizer/ProjectMBridge.cpp:131]()\n- `PresetManager::presetChanged`: Emitted when current preset updates [src/visualizer/PresetManager.cpp:151]()\n- `PresetManager::listChanged`: Emitted when preset list is modified [src/visualizer/PresetManager.cpp:68]()\n\nSources: [src/visualizer/VisualizerWindow.hpp:26-33](), [src/visualizer/ProjectMBridge.cpp:127-132](), [src/visualizer/PresetManager.cpp:66-71]()"])</script><script>self.__next_f.push([1,"21:T5a6a,"])</script><script>self.__next_f.push([1,"# VisualizerWindow\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [src/visualizer/VisualizerWindow.cpp](src/visualizer/VisualizerWindow.cpp)\n- [src/visualizer/VisualizerWindow.hpp](src/visualizer/VisualizerWindow.hpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThe `VisualizerWindow` class is the primary rendering surface for projectM v4 visualizations. It is a `QWindow`-based component that manages a custom OpenGL 3.3 Core Profile context, implements the core rendering loop, and handles frame capture for video recording. This class serves as the integration point between the audio pipeline, projectM rendering engine, overlay system, and recording system.\n\nFor projectM API integration details, see [ProjectM Integration](#4.2). For preset management functionality, see [Preset Management](#4.3). For the recording pipeline that consumes captured frames, see [VideoRecorder](#5.1).\n\n**Sources:** [src/visualizer/VisualizerWindow.hpp:1-125](), [src/visualizer/VisualizerWindow.cpp:1-426]()\n\n---\n\n## Class Structure and Dependencies\n\nThe `VisualizerWindow` class inherits from both `QWindow` (for windowing functionality) and `QOpenGLFunctions_3_3_Core` (for OpenGL API access). It owns a `ProjectMBridge` instance and manages multiple rendering targets.\n\n```mermaid\nclassDiagram\n    class VisualizerWindow {\n        +QWindow\n        +QOpenGLFunctions_3_3_Core\n        -context_: unique_ptr~QOpenGLContext~\n        -projectM_: ProjectMBridge\n        -renderTarget_: RenderTarget\n        -overlayTarget_: RenderTarget\n        -overlayEngine_: OverlayEngine*\n        -renderTimer_: QTimer\n        -fpsTimer_: QTimer\n        -presetRotationTimer_: QTimer\n        -pbos_[2]: GLuint\n        -audioQueue_: vector~f32~\n        -audioMutex_: mutex\n        -presetLoadMutex_: mutex\n        +initialize() void\n        +render() void\n        +renderFrame() void\n        +feedAudio() void\n        +startRecording() void\n        +stopRecording() void\n        +captureAsync() void\n        +toggleFullscreen() void\n        +loadPresetFromManager() void\n    }\n    \n    class QWindow {\n        \u003c\u003cQt Framework\u003e\u003e\n    }\n    \n    class QOpenGLFunctions_3_3_Core {\n        \u003c\u003cQt Framework\u003e\u003e\n    }\n    \n    class ProjectMBridge {\n        +init() Result\n        +render() void\n        +renderToTarget() void\n        +addPCMDataInterleaved() void\n        +resize() void\n        +nextPreset() void\n        +previousPreset() void\n        +randomPreset() void\n    }\n    \n    class RenderTarget {\n        +create() void\n        +destroy() void\n        +bind() void\n        +unbind() void\n        +resize() void\n        +blitToScreen() void\n        +blitTo() void\n    }\n    \n    class OverlayEngine {\n        +render() void\n    }\n    \n    class QOpenGLContext {\n        \u003c\u003cQt Framework\u003e\u003e\n        +makeCurrent() bool\n        +doneCurrent() void\n        +swapBuffers() void\n    }\n    \n    VisualizerWindow --|\u003e QWindow\n    VisualizerWindow --|\u003e QOpenGLFunctions_3_3_Core\n    VisualizerWindow *-- QOpenGLContext\n    VisualizerWindow *-- ProjectMBridge\n    VisualizerWindow *-- RenderTarget\n    VisualizerWindow --\u003e OverlayEngine\n```\n\n**Sources:** [src/visualizer/VisualizerWindow.hpp:23-124](), [src/visualizer/VisualizerWindow.cpp:14-32]()\n\n---\n\n## OpenGL Context Initialization\n\nThe window creates a custom OpenGL context with specific requirements for projectM v4 compatibility. The context uses OpenGL 3.3 Core Profile with double buffering, vertical synchronization, 4x multisampling, and a 24-bit depth buffer.\n\n### Context Configuration\n\n| Parameter | Value | Purpose |\n|-----------|-------|---------|\n| OpenGL Version | 3.3 | Core Profile minimum for projectM v4 |\n| Swap Behavior | Double Buffer | Smooth frame presentation |\n| Swap Interval | 1 | Enable V-Sync |\n| Samples | 4 | 4x MSAA for edge smoothing |\n| Alpha Buffer | 0 | No alpha channel (opaque window) |\n| Depth Buffer | 24 bits | Required for projectM depth testing |\n\nThe initialization sequence follows this flow:\n\n```mermaid\nsequenceDiagram\n    participant Window as \"VisualizerWindow\"\n    participant Context as \"QOpenGLContext\"\n    participant GLEW as \"GLEW Library\"\n    participant ProjectM as \"ProjectMBridge\"\n    participant FBO as \"RenderTarget\"\n    \n    Window-\u003e\u003eContext: create()\n    Window-\u003e\u003eContext: makeCurrent(this)\n    Window-\u003e\u003eWindow: initializeOpenGLFunctions()\n    Window-\u003e\u003eGLEW: glewInit()\n    Note over GLEW: Load OpenGL extensions\n    Window-\u003e\u003eProjectM: init(pmConfig)\n    Note over ProjectM: Initialize projectM v4\n    Window-\u003e\u003eFBO: create(width, height, withDepth=true)\n    Note over FBO: Create renderTarget_ FBO\n    Window-\u003e\u003eFBO: create(width, height, withDepth=false)\n    Note over FBO: Create overlayTarget_ FBO\n    Window-\u003e\u003eWindow: Start timers\n    Window-\u003e\u003eContext: doneCurrent()\n```\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:14-32](), [src/visualizer/VisualizerWindow.cpp:63-114]()\n\n---\n\n## Rendering Pipeline\n\nThe rendering system operates on a timer-driven loop with two distinct rendering paths: **direct-to-screen** for peak performance and **FBO-based** for recording or low-resource mode.\n\n### Rendering Modes\n\n```mermaid\nflowchart TD\n    Start[\"renderFrame() called\"]\n    CheckMode{\"recording_ || lowResourceMode?\"}\n    DirectPath[\"Direct Rendering Path\"]\n    FBOPath[\"FBO Rendering Path\"]\n    FeedAudio[\"Feed audio to projectM\"]\n    CheckPreset{\"presetLoading_?\"}\n    RenderBlack1[\"Clear to black\"]\n    RenderProjectM1[\"projectM.render()\"]\n    FixAlpha[\"Fix alpha channel\"]\n    ResizeFBO[\"Resize FBOs if needed\"]\n    RenderToFBO[\"projectM.renderToTarget(renderTarget_)\"]\n    CheckRecording{\"recording_?\"}\n    CompositeOverlay[\"Composite overlay to overlayTarget_\"]\n    CaptureFrame[\"captureAsync()\"]\n    BlitToScreen[\"renderTarget_.blitToScreen()\"]\n    RenderOverlay[\"overlayEngine_-\u003erender()\"]\n    SwapBuffers[\"context_-\u003eswapBuffers()\"]\n    \n    Start --\u003e FeedAudio\n    FeedAudio --\u003e CheckMode\n    CheckMode --\u003e|Yes| FBOPath\n    CheckMode --\u003e|No| DirectPath\n    \n    FBOPath --\u003e ResizeFBO\n    ResizeFBO --\u003e CheckPreset\n    CheckPreset --\u003e|Yes| RenderBlack1\n    CheckPreset --\u003e|No| RenderToFBO\n    RenderBlack1 --\u003e CheckRecording\n    RenderToFBO --\u003e CheckRecording\n    \n    CheckRecording --\u003e|Yes| CompositeOverlay\n    CompositeOverlay --\u003e CaptureFrame\n    CaptureFrame --\u003e BlitToScreen\n    CheckRecording --\u003e|No| BlitToScreen\n    \n    DirectPath --\u003e CheckPreset\n    CheckPreset --\u003e|No| RenderProjectM1\n    RenderProjectM1 --\u003e FixAlpha\n    FixAlpha --\u003e RenderOverlay\n    \n    BlitToScreen --\u003e RenderOverlay\n    RenderOverlay --\u003e SwapBuffers\n```\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:133-237]()\n\n### Direct Rendering Path\n\nWhen not recording and not in low-resource mode, projectM renders directly to the screen framebuffer. This path achieves maximum performance by avoiding intermediate FBO copies.\n\nKey steps in [src/visualizer/VisualizerWindow.cpp:215-234]():\n1. Call `projectM_.resetViewport(w, h)` to set viewport\n2. Execute `projectM_.render()` to draw directly to default framebuffer\n3. Fix alpha channel to prevent compositor issues (projectM leaves alpha at 0)\n4. Render overlays on top via `overlayEngine_-\u003erender(w, h)`\n\n### FBO-Based Rendering Path\n\nWhen recording or in low-resource mode, rendering occurs at a potentially different resolution using FBOs. This enables resolution-independent capture and performance optimization.\n\nKey steps in [src/visualizer/VisualizerWindow.cpp:168-214]():\n1. Determine target resolution (recording resolution or downscaled for low-resource)\n2. Resize `renderTarget_` and projectM if dimensions changed\n3. Render projectM to `renderTarget_` FBO via `projectM_.renderToTarget()`\n4. If recording:\n   - Composite overlay to `overlayTarget_` FBO\n   - Capture frame via double-buffered PBOs\n   - Emit `frameCaptured()` signal with pixel data\n5. Blit `renderTarget_` back to screen at window resolution\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:133-237]()\n\n---\n\n## Audio Integration\n\nThe audio feeding mechanism uses a mutex-protected queue to buffer PCM samples from the audio engine. Audio data flows from `AudioEngine` to `VisualizerWindow` to `ProjectMBridge`.\n\n### Audio Queue Architecture\n\n```mermaid\nflowchart LR\n    subgraph AudioEngine\n        Decode[\"Audio Decoder\"]\n    end\n    \n    subgraph VisualizerWindow\n        FeedMethod[\"feedAudio()\"]\n        Mutex[\"audioMutex_\"]\n        Queue[\"audioQueue_\u003cbr/\u003evector\u0026lt;f32\u0026gt;\"]\n        RenderLoop[\"renderFrame()\"]\n    end\n    \n    subgraph ProjectMBridge\n        AddPCM[\"addPCMDataInterleaved()\"]\n        ProjectMCore[\"projectM v4 Core\"]\n    end\n    \n    Decode --\u003e|\"f32* data\u003cbr/\u003eframes, channels, sampleRate\"| FeedMethod\n    FeedMethod --\u003e|lock| Mutex\n    FeedMethod --\u003e|append| Queue\n    RenderLoop --\u003e|lock| Mutex\n    RenderLoop --\u003e|consume| Queue\n    RenderLoop --\u003e AddPCM\n    AddPCM --\u003e ProjectMCore\n```\n\n### Audio Feeding Process\n\nThe `feedAudio()` method accepts interleaved PCM float data and appends it to the internal queue:\n\n**Method signature from [src/visualizer/VisualizerWindow.cpp:290-300]():**\n```cpp\nvoid feedAudio(const f32* data, u32 frames, u32 channels, u32 sampleRate)\n```\n\nThe render loop consumes audio at a rate matching the target FPS:\n- Calculates frames needed: `(audioSampleRate_ + targetFps_ - 1) / targetFps_`\n- Feeds minimum of available and needed frames to projectM\n- Removes consumed frames from queue\n\nThis design decouples audio production from rendering, preventing buffer underruns while maintaining synchronization.\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:290-300](), [src/visualizer/VisualizerWindow.cpp:152-166](), [src/visualizer/VisualizerWindow.hpp:116-118]()\n\n---\n\n## Frame Capture System\n\nThe frame capture system uses **double-buffered Pixel Buffer Objects (PBOs)** for asynchronous, zero-copy GPU-to-CPU transfer. This technique allows the GPU to continue rendering while previous frames are transferred, minimizing performance impact.\n\n### PBO Double-Buffering\n\n```mermaid\nstateDiagram-v2\n    [*] --\u003e Frame0: setupPBOs()\n    \n    state \"Frame N\" as Frame0 {\n        [*] --\u003e ReadFrame0: glReadPixels to PBO[0]\n        ReadFrame0 --\u003e MapFrame1: glMapBuffer from PBO[1]\n        MapFrame1 --\u003e EmitSignal: frameCaptured(buffer)\n        EmitSignal --\u003e [*]\n    }\n    \n    state \"Frame N+1\" as Frame1 {\n        [*] --\u003e ReadFrame1: glReadPixels to PBO[1]\n        ReadFrame1 --\u003e MapFrame0: glMapBuffer from PBO[0]\n        MapFrame0 --\u003e EmitSignal2: frameCaptured(buffer)\n        EmitSignal2 --\u003e [*]\n    }\n    \n    Frame0 --\u003e Frame1: pboIndex_ = 1\n    Frame1 --\u003e Frame0: pboIndex_ = 0\n```\n\n### Capture Implementation\n\nThe `captureAsync()` method implements the double-buffering logic in [src/visualizer/VisualizerWindow.cpp:258-288]():\n\n| Step | Operation | Buffer | Purpose |\n|------|-----------|--------|---------|\n| 1 | `glReadPixels(..., nullptr)` | `pbos_[pboIndex_]` | Initiate async transfer from FBO |\n| 2 | `glMapBuffer(GL_READ_ONLY)` | `pbos_[nextIndex]` | Map previously filled buffer |\n| 3 | `std::vector\u003cu8\u003e buffer(ptr, ...)` | CPU memory | Copy to movable vector |\n| 4 | `glUnmapBuffer()` | `pbos_[nextIndex]` | Release PBO |\n| 5 | `emit frameCaptured(std::move(buffer), ...)` | Signal | Pass ownership to VideoRecorder |\n\nThe `pboAvailable_` flag prevents mapping on the first frame before any PBO has been filled.\n\n### PBO Lifecycle Management\n\n**Setup:** [src/visualizer/VisualizerWindow.cpp:239-250]()\n- Generates two PBO handles via `glGenBuffers(2, pbos_)`\n- Allocates GPU memory: `glBufferData(GL_PIXEL_PACK_BUFFER, size, nullptr, GL_STREAM_READ)`\n- Size calculated as `recordWidth_ * recordHeight_ * 4` (RGBA)\n\n**Teardown:** [src/visualizer/VisualizerWindow.cpp:252-256]()\n- Deletes PBO handles via `glDeleteBuffers(2, pbos_)`\n- Called in destructor and when stopping recording\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:239-288](), [src/visualizer/VisualizerWindow.hpp:99-106]()\n\n---\n\n## Recording Mode Management\n\nRecording mode switches the rendering pipeline from direct-to-screen to FBO-based capture at a specified resolution. This mode is toggled via `startRecording()` and `stopRecording()` methods.\n\n### Recording State Transitions\n\n```mermaid\nstateDiagram-v2\n    [*] --\u003e Idle: Constructor\n    \n    state Idle {\n        recording_ = false\n        Direct rendering to screen\n        No PBOs allocated\n    }\n    \n    state Recording {\n        recording_ = true\n        FBO rendering at recordWidth_recordHeight_\n        PBOs active for frame capture\n        Emit frameCaptured() signals\n    }\n    \n    Idle --\u003e Recording: startRecording()\n    Recording --\u003e Idle: stopRecording()\n    \n    note right of Recording\n        Resolution: setRecordingSize()\n        Overlay composition if overlayEngine_\n        Double-buffered PBO capture\n    end note\n    \n    note left of Idle\n        Resolution: window dimensions\n        Optional overlay rendering\n        Peak performance mode\n    end note\n```\n\n### Recording Initialization\n\nThe `startRecording()` method in [src/visualizer/VisualizerWindow.cpp:316-325]():\n1. Sets `recording_ = true` flag\n2. Acquires OpenGL context\n3. Resizes FBOs to recording resolution (`recordWidth_`  `recordHeight_`)\n4. Calls `projectM_.resize()` to match projectM output\n5. Calls `setupPBOs()` to allocate capture buffers\n\n### Recording Teardown\n\nThe `stopRecording()` method in [src/visualizer/VisualizerWindow.cpp:327-334]():\n1. Sets `recording_ = false` flag\n2. Acquires OpenGL context\n3. Calls `destroyPBOs()` to release GPU memory\n4. Next `renderFrame()` will resize FBOs back to window dimensions\n\n### Signal Emission\n\nDuring recording, the window emits two signals per frame:\n- `frameReady()`: Emitted immediately after capture starts ([line 206]())\n- `frameCaptured(std::vector\u003cu8\u003e, u32, u32, i64)`: Emitted when PBO data is mapped ([lines 276-282]())\n\nThe `VideoRecorder` connects to `frameCaptured()` to receive pixel data with timestamp.\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:316-334](), [src/visualizer/VisualizerWindow.hpp:52-61]()\n\n---\n\n## Input Handling\n\nThe window processes keyboard and mouse events for visualization control, implementing both configurable keyboard shortcuts and hardcoded fallbacks.\n\n### Keyboard Shortcuts\n\nThe `keyPressEvent()` handler in [src/visualizer/VisualizerWindow.cpp:398-417]() maps keys to actions:\n\n| Key | Action | Method Called |\n|-----|--------|---------------|\n| Configured `toggleFullscreen` or F11 | Toggle fullscreen | `toggleFullscreen()` |\n| Configured `nextPreset` or Right Arrow | Next preset | `projectM_.nextPreset()` |\n| Configured `prevPreset` or Left Arrow | Previous preset | `projectM_.previousPreset()` |\n| R | Random preset | `projectM_.randomPreset()` |\n| L | Lock/unlock preset | `projectM_.lockPreset(!locked)` |\n| Escape (in fullscreen) | Exit fullscreen | `toggleFullscreen()` |\n\nThe keyboard configuration is read from `CONFIG.keyboard()` which provides user-customizable key bindings.\n\n### Mouse Input\n\nDouble-clicking with the left mouse button toggles fullscreen mode via `mouseDoubleClickEvent()` in [src/visualizer/VisualizerWindow.cpp:419-423]().\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:398-423](), [src/visualizer/VisualizerWindow.hpp:71-72]()\n\n---\n\n## Fullscreen Support\n\nFullscreen functionality preserves the normal window geometry for seamless transitions. The implementation uses Qt's built-in fullscreen API with custom geometry management.\n\n### Fullscreen Toggle Logic\n\nThe `toggleFullscreen()` method in [src/visualizer/VisualizerWindow.cpp:336-349]():\n\n**Entering Fullscreen:**\n1. Store current geometry in `normalGeometry_`\n2. Get primary screen geometry via `QGuiApplication::primaryScreen()-\u003egeometry()`\n3. Call `setGeometry(screen-\u003egeometry())`\n4. Call `showFullScreen()`\n5. Set `fullscreen_ = true`\n\n**Exiting Fullscreen:**\n1. Call `showNormal()`\n2. Restore saved geometry via `setGeometry(normalGeometry_)`\n3. Set `fullscreen_ = false`\n\nThis approach ensures the window returns to its exact previous position and size when exiting fullscreen, rather than using Qt's default behavior.\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:336-349](), [src/visualizer/VisualizerWindow.hpp:113-114]()\n\n---\n\n## FPS Tracking and Performance Monitoring\n\nThe window maintains real-time FPS statistics by counting frames and emitting updates every second.\n\n### FPS Measurement System\n\n```mermaid\nsequenceDiagram\n    participant Render as \"renderFrame()\"\n    participant FPSTimer as \"fpsTimer_ (1000ms)\"\n    participant Update as \"updateFPS()\"\n    participant Signal as \"fpsChanged(f32)\"\n    \n    loop Every frame\n        Render-\u003e\u003eRender: ++frameCount_\n    end\n    \n    loop Every 1000ms\n        FPSTimer-\u003e\u003eUpdate: timeout()\n        Update-\u003e\u003eUpdate: actualFps_ = frameCount_\n        Update-\u003e\u003eUpdate: frameCount_ = 0\n        Update-\u003e\u003eSignal: emit fpsChanged(actualFps_)\n    end\n```\n\nThe FPS calculation is simple and accurate:\n- Increment `frameCount_` at the end of each `renderFrame()` call ([line 236]())\n- Every 1000ms, the `updateFPS()` slot ([lines 351-355]()) captures `frameCount_` as `actualFps_`\n- Reset `frameCount_` to 0\n- Emit `fpsChanged(actualFps_)` signal for UI updates\n\nThis measurement reflects actual rendering performance, accounting for V-Sync limits, frame drops, and system load.\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:351-355](), [src/visualizer/VisualizerWindow.cpp:236](), [src/visualizer/VisualizerWindow.hpp:108-110]()\n\n---\n\n## Preset Loading and Synchronization\n\nPreset loading is protected by a mutex to prevent concurrent loads, which can crash projectM v4. The loading mechanism integrates with the `PresetManager` via signals.\n\n### Preset Loading Flow\n\n```mermaid\nflowchart TD\n    Signal[\"projectM_.presetChanged signal\"]\n    LoadMethod[\"loadPresetFromManager()\"]\n    CheckInProgress{\"presetLoadInProgress_?\"}\n    AcquireLock[\"Lock presetLoadMutex_\"]\n    MakeCurrent[\"context_-\u003emakeCurrent()\"]\n    SetFlag[\"presetLoadInProgress_ = true\u003cbr/\u003epresetLoading_ = true\"]\n    GetPreset[\"Get current preset from PresetManager\"]\n    LoadFile[\"projectm_load_preset_file()\"]\n    EmitName[\"emit presetNameUpdated()\"]\n    ClearFlags[\"presetLoading_ = false\u003cbr/\u003epresetLoadInProgress_ = false\"]\n    DoneCurrent[\"context_-\u003edoneCurrent()\"]\n    \n    Signal --\u003e LoadMethod\n    LoadMethod --\u003e AcquireLock\n    AcquireLock --\u003e CheckInProgress\n    CheckInProgress --\u003e|true| Return[\"Return early\"]\n    CheckInProgress --\u003e|false| MakeCurrent\n    MakeCurrent --\u003e SetFlag\n    SetFlag --\u003e GetPreset\n    GetPreset --\u003e LoadFile\n    LoadFile --\u003e EmitName\n    EmitName --\u003e ClearFlags\n    ClearFlags --\u003e DoneCurrent\n```\n\n### Synchronization Mechanism\n\nThe `loadPresetFromManager()` method in [src/visualizer/VisualizerWindow.cpp:357-382]() implements critical section protection:\n\n1. Acquire `presetLoadMutex_` via `std::lock_guard`\n2. Check `presetLoadInProgress_` flag and return if set\n3. Set flag to `true` to block concurrent loads\n4. Acquire OpenGL context (required for projectM API calls)\n5. Get current preset from `projectM_.presets().current()`\n6. Call raw projectM C API: `projectm_load_preset_file(handle, path, smooth=false)`\n7. Emit `presetNameUpdated()` signal for UI updates\n8. Clear flags and release context\n\nThe `presetLoading_` flag is also used during rendering to display a black screen instead of rendering during preset transitions.\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:357-382](), [src/visualizer/VisualizerWindow.cpp:87-90](), [src/visualizer/VisualizerWindow.hpp:120-121]()\n\n---\n\n## Configuration Integration\n\nThe window reads configuration from the global `CONFIG` singleton and provides an `updateSettings()` method to apply changes at runtime.\n\n### Configuration Usage\n\n| Config Section | Member | Usage |\n|----------------|--------|-------|\n| `CONFIG.visualizer().fps` | Target frame rate | `setRenderRate()`, projectM initialization |\n| `CONFIG.visualizer().beatSensitivity` | Beat detection | `projectM_.setBeatSensitivity()` |\n| `CONFIG.visualizer().presetPath` | Preset directory | `ProjectMConfig.presetPath` |\n| `CONFIG.visualizer().presetDuration` | Auto-rotation interval | `presetRotationTimer_.setInterval()` |\n| `CONFIG.visualizer().transitionDuration` | Preset blending time | `ProjectMConfig.transitionDuration` |\n| `CONFIG.visualizer().shufflePresets` | Random vs sequential | `projectM_.setShuffleEnabled()` |\n| `CONFIG.visualizer().lowResourceMode` | Performance mode | Rendering path selection |\n| `CONFIG.keyboard()` | Key bindings | Input event mapping |\n\n### Runtime Configuration Updates\n\nThe `updateSettings()` method in [src/visualizer/VisualizerWindow.cpp:384-396]() applies configuration changes without recreating the window:\n\n1. Update render rate via `setRenderRate()`\n2. Update projectM beat sensitivity\n3. Enable/disable shuffle mode\n4. Reconfigure preset rotation timer\n5. Restart timer if preset duration \u003e 0\n\nThis method is called by `VisualizerController` when the user saves settings via `SettingsDialog`.\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:384-396](), [src/visualizer/VisualizerWindow.cpp:75-85](), [src/visualizer/VisualizerWindow.hpp:47]()\n\n---\n\n## Thread Safety Considerations\n\nThe `VisualizerWindow` manages concurrency carefully, particularly around OpenGL context usage and shared data structures.\n\n### Synchronization Points\n\n| Resource | Protection | Reason |\n|----------|------------|--------|\n| `audioQueue_` | `audioMutex_` | Accessed by both audio thread and render thread |\n| OpenGL context | `makeCurrent()/doneCurrent()` | OpenGL is not thread-safe |\n| Preset loading | `presetLoadMutex_` + `presetLoadInProgress_` | Prevent concurrent projectM API calls |\n\n### Context Thread Affinity\n\nAll OpenGL operations must occur on the main thread after calling `context_-\u003emakeCurrent(this)`. The destructor carefully ensures cleanup happens with a valid current context:\n\n```cpp\nif (context_ \u0026\u0026 context_-\u003emakeCurrent(this)) {\n    destroyPBOs();\n    projectM_.shutdown();\n    renderTarget_.destroy();\n    overlayTarget_.destroy();\n    context_-\u003edoneCurrent();\n}\n```\n\nThis pattern is repeated in all methods that interact with OpenGL resources.\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:34-42](), [src/visualizer/VisualizerWindow.hpp:116-121]()\n\n---\n\n## Signal Emissions\n\nThe window emits Qt signals to communicate state changes and frame availability to other components:\n\n| Signal | Parameters | Purpose | Typical Receiver |\n|--------|-----------|---------|------------------|\n| `presetNameUpdated` | `QString name` | Current preset name | UI status bar |\n| `frameReady` | None | Frame capture initiated | Frame timing sync |\n| `frameCaptured` | `vector\u003cu8\u003e data`\u003cbr/\u003e`u32 width, height`\u003cbr/\u003e`i64 timestamp` | Frame pixels available | `VideoRecorder` |\n| `fpsChanged` | `f32 actualFps` | Measured FPS | UI FPS display |\n\nThe `frameCaptured()` signal uses move semantics (`std::move(buffer)`) to transfer ownership of the pixel data without copying, essential for 192010804 = 8MB buffers at 60 FPS.\n\n**Sources:** [src/visualizer/VisualizerWindow.hpp:26-33](), [src/visualizer/VisualizerWindow.cpp:276-282]()"])</script><script>self.__next_f.push([1,"22:T41fb,"])</script><script>self.__next_f.push([1,"# ProjectM Integration\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [src/ui/VisualizerPanel.cpp](src/ui/VisualizerPanel.cpp)\n- [src/visualizer/PresetManager.cpp](src/visualizer/PresetManager.cpp)\n- [src/visualizer/PresetManager.hpp](src/visualizer/PresetManager.hpp)\n- [src/visualizer/ProjectMBridge.cpp](src/visualizer/ProjectMBridge.cpp)\n\n\u003c/details\u003e\n\n\n\nThis document describes how chadvis-projectm-qt integrates with the [projectM v4 library](https://github.com/projectM-visualizer/projectm), a real-time music visualization engine. The integration is implemented through the `ProjectMBridge` wrapper class, which encapsulates the projectM C API and coordinates with the `PresetManager` for preset handling.\n\nFor information about the rendering context and OpenGL setup, see [VisualizerWindow](#4.1). For preset browsing UI, see [Preset Management](#4.3).\n\n---\n\n## Architecture Overview\n\nThe projectM integration follows a **wrapper pattern** where `ProjectMBridge` encapsulates the native projectM C API (`projectm_*` functions) and provides a C++ interface with ownership semantics, error handling via `Result\u003cT\u003e`, and signal-based communication.\n\n```mermaid\ngraph TB\n    subgraph \"Application Layer\"\n        VW[\"VisualizerWindow\u003cbr/\u003e(QWindow + OpenGL)\"]\n        VP[\"VisualizerPanel\u003cbr/\u003e(UI Controls)\"]\n    end\n    \n    subgraph \"Integration Layer\"\n        PMB[\"ProjectMBridge\u003cbr/\u003eC++ Wrapper\"]\n        PM[\"PresetManager\u003cbr/\u003ePreset Library\"]\n    end\n    \n    subgraph \"projectM v4 Library\"\n        PROJECTM_API[\"projectm_* C API\u003cbr/\u003e(libprojectM.so)\"]\n        PRESET_ENGINE[\"Preset Engine\u003cbr/\u003e(.milk parser)\"]\n        RENDER_ENGINE[\"Render Engine\u003cbr/\u003e(OpenGL shaders)\"]\n    end\n    \n    subgraph \"Configuration\"\n        CFG[\"ProjectMConfig\u003cbr/\u003e(struct)\"]\n        PRESET_STATE[\"preset_state.txt\u003cbr/\u003e(favorites/blacklist)\"]\n    end\n    \n    VW --\u003e|\"owns\"| PMB\n    PMB --\u003e|\"owns\"| PM\n    PMB --\u003e|\"calls projectm_create()\u003cbr/\u003eprojectm_opengl_render_frame()\u003cbr/\u003eprojectm_pcm_add_float()\"| PROJECTM_API\n    PM --\u003e|\"presetChanged signal\"| PMB\n    PMB --\u003e|\"projectm_load_preset_file()\"| PROJECTM_API\n    PROJECTM_API --\u003e PRESET_ENGINE\n    PROJECTM_API --\u003e RENDER_ENGINE\n    \n    CFG -.-\u003e|\"init()\"| PMB\n    PM -.-\u003e|\"loadState()\u003cbr/\u003esaveState()\"| PRESET_STATE\n    \n    VP --\u003e|\"nextPreset()\u003cbr/\u003epreviousPreset()\u003cbr/\u003elockPreset()\"| PMB\n```\n\n**Sources:** [src/visualizer/ProjectMBridge.cpp:1-170](), [src/visualizer/PresetManager.hpp:1-109]()\n\n---\n\n## ProjectMBridge Class\n\n`ProjectMBridge` is the primary integration point with projectM v4. It manages the lifecycle of the native `projectm` handle and provides methods for initialization, audio feeding, rendering, and preset control.\n\n### Core Responsibilities\n\n| Responsibility | Methods | Description |\n|----------------|---------|-------------|\n| **Lifecycle** | `init()`, `shutdown()` | Creates/destroys projectM instance |\n| **Audio Input** | `addPCMData()`, `addPCMDataInterleaved()` | Feeds PCM samples to projectM for analysis |\n| **Rendering** | `render()`, `renderToTarget()` | Triggers OpenGL rendering |\n| **Preset Control** | `nextPreset()`, `previousPreset()`, `randomPreset()`, `lockPreset()` | Navigates preset library |\n| **Configuration** | `resize()`, `setFPS()`, `setBeatSensitivity()` | Runtime parameter adjustment |\n\n**Sources:** [src/visualizer/ProjectMBridge.cpp:1-170]()\n\n### Initialization\n\nThe `init()` method creates the projectM instance and configures it according to the `ProjectMConfig` struct:\n\n```mermaid\nsequenceDiagram\n    participant Client\n    participant PMB as ProjectMBridge\n    participant PM as PresetManager\n    participant PROJECTM as projectM C API\n    \n    Client-\u003e\u003ePMB: init(ProjectMConfig)\n    PMB-\u003e\u003ePROJECTM: projectm_create()\n    PMB-\u003e\u003ePROJECTM: projectm_set_window_size(w, h)\n    PMB-\u003e\u003ePROJECTM: projectm_set_fps(fps)\n    PMB-\u003e\u003ePROJECTM: projectm_set_beat_sensitivity(s)\n    PMB-\u003e\u003ePROJECTM: projectm_set_preset_duration(0)\n    PMB-\u003e\u003ePROJECTM: projectm_set_soft_cut_duration(d)\n    PMB-\u003e\u003ePROJECTM: projectm_set_mesh_size(x, y)\n    PMB-\u003e\u003ePROJECTM: projectm_set_preset_locked(false)\n    \n    PMB-\u003e\u003ePM: scan(presetPath)\n    PM--\u003e\u003ePMB: presetChanged signal connection\n    \n    alt config.forcePreset not empty\n        PMB-\u003e\u003ePM: selectByName(forcePreset)\n    else config.shufflePresets\n        PMB-\u003e\u003ePM: selectRandom()\n    else\n        PMB-\u003e\u003ePM: selectByIndex(0)\n    end\n    \n    PMB--\u003e\u003eClient: Result\u003cvoid\u003e::ok()\n```\n\n**Key configuration parameters:**\n\n- `width`, `height`: Rendering resolution [src/visualizer/ProjectMBridge.cpp:17-18]()\n- `fps`: Target frame rate (typically 60) [src/visualizer/ProjectMBridge.cpp:26]()\n- `beatSensitivity`: Controls visual response to audio beats [src/visualizer/ProjectMBridge.cpp:27]()\n- `transitionDuration`: Smooth transition time between presets [src/visualizer/ProjectMBridge.cpp:29]()\n- `meshX`, `meshY`: Resolution of the render mesh grid [src/visualizer/ProjectMBridge.cpp:30]()\n- `presetDuration`: Set to `0` for manual preset changes only [src/visualizer/ProjectMBridge.cpp:28]()\n\n**Sources:** [src/visualizer/ProjectMBridge.cpp:14-54]()\n\n### Audio Data Flow\n\nProjectMBridge accepts PCM audio data in float32 format and forwards it to projectM's internal audio analysis engine:\n\n```mermaid\ngraph LR\n    AE[\"AudioEngine\u003cbr/\u003e(QAudioBufferOutput)\"]\n    PMB[\"ProjectMBridge\"]\n    PROJECTM[\"projectM\u003cbr/\u003ePCM Buffer\"]\n    FFT[\"FFT Analysis\"]\n    SPECTRUM[\"Frequency Spectrum\"]\n    RENDER[\"Preset Rendering\"]\n    \n    AE --\u003e|\"f32 samples\u003cbr/\u003e(interleaved or planar)\"| PMB\n    PMB --\u003e|\"projectm_pcm_add_float()\"| PROJECTM\n    PROJECTM --\u003e FFT\n    FFT --\u003e SPECTRUM\n    SPECTRUM --\u003e RENDER\n```\n\nTwo methods are provided for different PCM layouts:\n\n- **`addPCMData(const f32* data, u32 samples, u32 channels)`** - Planar or interleaved samples [src/visualizer/ProjectMBridge.cpp:81-88]()\n- **`addPCMDataInterleaved(const f32* data, u32 frames, u32 channels)`** - Explicitly interleaved [src/visualizer/ProjectMBridge.cpp:90-99]()\n\nBoth methods map mono (`channels == 1`) to `PROJECTM_MONO` and stereo to `PROJECTM_STEREO`.\n\n**Sources:** [src/visualizer/ProjectMBridge.cpp:81-99]()\n\n### Rendering API\n\nProjectMBridge provides two rendering modes:\n\n#### Direct Rendering\n```cpp\nvoid render();  // Renders to current OpenGL context\n```\nCalls `projectm_opengl_render_frame()` assuming the caller has already set up the OpenGL context and viewport. Used by `VisualizerWindow` during normal display. [src/visualizer/ProjectMBridge.cpp:64-68]()\n\n#### Render-to-Target\n```cpp\nvoid renderToTarget(RenderTarget\u0026 target);\n```\nBinds an FBO, sets the viewport, renders, and unbinds. Automatically handles resolution mismatches by calling `resize()` if needed. Used for off-screen recording. [src/visualizer/ProjectMBridge.cpp:70-79]()\n\n**Sources:** [src/visualizer/ProjectMBridge.cpp:64-79]()\n\n---\n\n## PresetManager Integration\n\n`ProjectMBridge` owns a `PresetManager` instance that handles the preset library. The integration is **signal-based**: when `PresetManager` changes the current preset, it emits a `presetChanged` signal, which `ProjectMBridge` handles by loading the preset file into projectM.\n\n### Signal Flow\n\n```mermaid\ngraph LR\n    USER[\"User Action\u003cbr/\u003e(nextPreset button)\"]\n    PMB[\"ProjectMBridge\u003cbr/\u003enextPreset()\"]\n    PM[\"PresetManager\u003cbr/\u003eselectNext()\"]\n    SIGNAL[\"presetChanged\u003cbr/\u003eSignal\"]\n    CALLBACK[\"onPresetManagerChanged()\"]\n    PROJECTM[\"projectm_load_preset_file()\"]\n    \n    USER --\u003e PMB\n    PMB --\u003e|\"if !presetLocked\"| PM\n    PM --\u003e|\"emitSignal(\u0026PresetInfo)\"| SIGNAL\n    SIGNAL --\u003e CALLBACK\n    CALLBACK --\u003e PROJECTM\n    CALLBACK --\u003e|\"emitSignal(name)\"| PMB_SIGNAL[\"ProjectMBridge::presetChanged\"]\n```\n\n**Connection established during init:**\n```cpp\npresets_.presetChanged.connect(\n    [this](const PresetInfo* p) { onPresetManagerChanged(p); });\n```\n[src/visualizer/ProjectMBridge.cpp:33-34]()\n\n**Handler implementation:**\n```cpp\nvoid ProjectMBridge::onPresetManagerChanged(const PresetInfo* preset) {\n    if (!preset || !projectM_)\n        return;\n    presetChanged.emitSignal(preset-\u003ename);\n}\n```\nThe actual preset loading happens asynchronously via `loadPreset()`. [src/visualizer/ProjectMBridge.cpp:164-168]()\n\n**Sources:** [src/visualizer/ProjectMBridge.cpp:33-34](), [src/visualizer/ProjectMBridge.cpp:164-168]()\n\n### Preset Navigation Modes\n\nProjectMBridge delegates all preset selection logic to PresetManager and respects the `presetLocked_` flag:\n\n| Method | Behavior | Respects Lock | Source |\n|--------|----------|---------------|--------|\n| `nextPreset()` | Advances to next preset (or random if shuffle enabled) | Yes | [src/visualizer/ProjectMBridge.cpp:134-141]() |\n| `previousPreset()` | Goes back in history or wraps around | Yes | [src/visualizer/ProjectMBridge.cpp:143-147]() |\n| `randomPreset()` | Selects random preset from active pool | Yes | [src/visualizer/ProjectMBridge.cpp:149-152]() |\n| `loadPreset(path)` | Directly loads a specific preset file | No | [src/visualizer/ProjectMBridge.cpp:127-132]() |\n\nWhen shuffle is enabled (`shuffleEnabled_` set during init), `nextPreset()` delegates to `PresetManager::selectRandom()` instead of sequential navigation. [src/visualizer/ProjectMBridge.cpp:137-140]()\n\n**Sources:** [src/visualizer/ProjectMBridge.cpp:134-152]()\n\n---\n\n## PresetManager Details\n\n`PresetManager` is a standalone component that scans, filters, and navigates a library of `.milk` preset files. It maintains state independently of projectM.\n\n### Preset Scanning\n\n```mermaid\ngraph TD\n    SCAN[\"scan(directory)\"]\n    LIST[\"listFiles()\u003cbr/\u003e(recursive .milk scan)\"]\n    PARSE[\"parsePresetInfo()\u003cbr/\u003e(extract author from name)\"]\n    STATE[\"loadState()\u003cbr/\u003e(favorites/blacklist)\"]\n    APPLY[\"Apply saved state\u003cbr/\u003eto PresetInfo objects\"]\n    SORT[\"Sort by name\"]\n    EMIT[\"listChanged signal\"]\n    \n    SCAN --\u003e LIST\n    LIST --\u003e PARSE\n    PARSE --\u003e STATE\n    STATE --\u003e APPLY\n    APPLY --\u003e SORT\n    SORT --\u003e EMIT\n```\n\nThe scanner uses `file::listFiles()` with `file::presetExtensions` to recursively find all `.milk` files. Each file becomes a `PresetInfo` struct:\n\n```cpp\nstruct PresetInfo {\n    fs::path path;\n    std::string name;      // Stem of filename\n    std::string author;    // Parsed from \"Author - Name\" pattern\n    std::string category;  // Relative folder path\n    bool favorite{false};\n    bool blacklisted{false};\n    u32 playCount{0};\n};\n```\n[src/visualizer/PresetManager.hpp:14-22]()\n\n**Sources:** [src/visualizer/PresetManager.cpp:12-71](), [src/visualizer/PresetManager.hpp:14-22]()\n\n### Selection Algorithms\n\nPresetManager implements multiple selection strategies:\n\n#### Sequential Navigation with History\n- `selectNext()` and `selectPrevious()` maintain a history stack (max 100 entries) [src/visualizer/PresetManager.cpp:252-324]()\n- When moving forward beyond history, wraps to next in list\n- Skips blacklisted presets and duplicates with same name\n- History allows non-destructive back/forward navigation\n\n#### Random Selection\n- `selectRandom()` uses `std::mt19937` RNG [src/visualizer/PresetManager.cpp:235-250]()\n- Only selects from `activePresets()` (excludes blacklisted)\n- Seeds from `std::random_device` [src/visualizer/PresetManager.hpp:106]()\n\n#### Name-Based Selection\n`selectByName()` implements a **three-tier matching strategy**:\n1. **Exact match** (case-sensitive) [src/visualizer/PresetManager.cpp:169-175]()\n2. **Partial match** (substring search) [src/visualizer/PresetManager.cpp:178-190]()\n3. **Case-insensitive partial match** [src/visualizer/PresetManager.cpp:193-214]()\n\nThis supports command-line args like `--preset \"Rovastar\"` matching \"Rovastar - Purple Neon Sphere\".\n\n**Pending preset mechanism:** If `selectByName()` is called before scanning completes, the name is stored in `pendingPresetName_` and applied after scan finishes. [src/visualizer/PresetManager.cpp:161-166]()\n\n**Sources:** [src/visualizer/PresetManager.cpp:125-324]()\n\n### State Persistence\n\nPresetManager saves favorites and blacklist to `preset_state.txt` in the config directory:\n\n**File format:**\n```\n[favorites]\npreset_name_1\npreset_name_2\n\n[blacklist]\npreset_name_3\n```\n\nThe state is **name-based** (not path-based) to remain valid across directory restructuring. State is loaded during scan and saved during shutdown.\n\n- `loadState()` called by `ProjectMBridge::init()` [src/visualizer/ProjectMBridge.cpp:38]()\n- `saveState()` called by `ProjectMBridge::shutdown()` [src/visualizer/ProjectMBridge.cpp:58]()\n\n**Sources:** [src/visualizer/PresetManager.cpp:414-464]()\n\n---\n\n## Configuration Parameters\n\nThe `ProjectMConfig` struct (defined in the visualizer config section) controls initialization:\n\n| Parameter | Type | Purpose | Default Location |\n|-----------|------|---------|------------------|\n| `width`, `height` | `u32` | Rendering resolution | Window size |\n| `fps` | `u32` | Target frame rate | 60 |\n| `beatSensitivity` | `f32` | Beat detection threshold | 1.0 |\n| `transitionDuration` | `f32` | Preset crossfade time (seconds) | 3.0 |\n| `meshX`, `meshY` | `u32` | Render mesh resolution | 48x32 |\n| `presetPath` | `fs::path` | Directory to scan for .milk files | `/usr/share/projectM/presets` |\n| `useDefaultPreset` | `bool` | Skip preset loading (use built-in) | `false` |\n| `forcePreset` | `string` | Force specific preset by name | Empty |\n| `shufflePresets` | `bool` | Random preset selection | `false` |\n\n**Sources:** [src/visualizer/ProjectMBridge.cpp:14-54]()\n\n---\n\n## Runtime Operations\n\n### Resize Handling\n\nWhen the window resizes, `ProjectMBridge::resize()` is called, which updates projectM's internal resolution state:\n\n```cpp\nvoid ProjectMBridge::resize(u32 width, u32 height) {\n    if (!projectM_ || (width == width_ \u0026\u0026 height == height_))\n        return;\n    width_ = width;\n    height_ = height;\n    projectm_set_window_size(projectM_, width_, height_);\n}\n```\n[src/visualizer/ProjectMBridge.cpp:101-107]()\n\nThe check prevents redundant updates. `resetViewport()` additionally calls `glViewport()` for immediate effect. [src/visualizer/ProjectMBridge.cpp:109-116]()\n\n**Sources:** [src/visualizer/ProjectMBridge.cpp:101-116]()\n\n### Dynamic Configuration\n\nRuntime parameters can be adjusted without reinitialization:\n\n- `setFPS(u32 fps)` - Updates target frame rate [src/visualizer/ProjectMBridge.cpp:118-121]()\n- `setBeatSensitivity(f32 s)` - Adjusts beat detection [src/visualizer/ProjectMBridge.cpp:122-125]()\n\n**Sources:** [src/visualizer/ProjectMBridge.cpp:118-125]()\n\n---\n\n## UI Integration Example\n\n`VisualizerPanel` demonstrates how UI components interact with `ProjectMBridge`:\n\n```mermaid\ngraph TB\n    PREV[\"Previous Button\"]\n    NEXT[\"Next Button\"]\n    LOCK[\"Lock Button\"]\n    LABEL[\"Preset Label\u003cbr/\u003e(MarqueeLabel)\"]\n    \n    PMB[\"ProjectMBridge\u003cbr/\u003e(via VisualizerWindow)\"]\n    SIGNAL[\"presetNameUpdated\u003cbr/\u003eQt signal\"]\n    \n    PREV --\u003e|\"clicked\"| PMB_PREV[\"previousPreset()\"]\n    NEXT --\u003e|\"clicked\"| PMB_NEXT[\"nextPreset()\"]\n    LOCK --\u003e|\"toggled\"| PMB_LOCK[\"lockPreset(bool)\"]\n    \n    PMB --\u003e|\"presetChanged signal\"| VW[\"VisualizerWindow\"]\n    VW --\u003e|\"emit Qt signal\"| SIGNAL\n    SIGNAL --\u003e LABEL\n```\n\n**Button connections:**\n```cpp\nconnect(nextPresetButton_, \u0026QPushButton::clicked, this, [this] {\n    visualizerWindow_-\u003eprojectM().nextPreset();\n});\n```\n[src/ui/VisualizerPanel.cpp:66-81]()\n\n**Preset name updates:**\nThe signal chain is: `ProjectMBridge::presetChanged`  `VisualizerWindow::presetNameUpdated`  `VisualizerPanel::updatePresetName()`  `MarqueeLabel::setText()` [src/ui/VisualizerPanel.cpp:128-145]()\n\n**Sources:** [src/ui/VisualizerPanel.cpp:49-145]()\n\n---\n\n## Error Handling\n\nProjectMBridge uses `Result\u003cvoid\u003e` for initialization:\n\n```cpp\nResult\u003cvoid\u003e ProjectMBridge::init(const ProjectMConfig\u0026 config) {\n    // ...\n    projectM_ = projectm_create();\n    if (!projectM_)\n        return Result\u003cvoid\u003e::err(\"Failed to create ProjectM instance\");\n    // ...\n    return Result\u003cvoid\u003e::ok();\n}\n```\n[src/visualizer/ProjectMBridge.cpp:14-54]()\n\nRuntime operations use **null checks** rather than returning Results:\n```cpp\nvoid ProjectMBridge::render() {\n    if (!projectM_)\n        return;\n    projectm_opengl_render_frame(projectM_);\n}\n```\n[src/visualizer/ProjectMBridge.cpp:64-68]()\n\nThis pattern assumes that after successful initialization, the `projectM_` handle remains valid until `shutdown()`.\n\n**Sources:** [src/visualizer/ProjectMBridge.cpp:14-68]()\n\n---\n\n## Thread Safety\n\nProjectMBridge is **not thread-safe**. All methods must be called from the same thread that owns the OpenGL context (typically the main/GUI thread). The projectM C API itself is not thread-safe, and OpenGL calls must occur on the context thread.\n\nAudio data feeding (`addPCMData()`) is called from the audio thread via signals/slots in Qt, which automatically marshals the call to the correct thread.\n\n**Sources:** [src/visualizer/ProjectMBridge.cpp:1-170]()"])</script><script>self.__next_f.push([1,"23:T4a11,"])</script><script>self.__next_f.push([1,"# Preset Management\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [src/ui/VisualizerPanel.cpp](src/ui/VisualizerPanel.cpp)\n- [src/visualizer/PresetManager.cpp](src/visualizer/PresetManager.cpp)\n- [src/visualizer/PresetManager.hpp](src/visualizer/PresetManager.hpp)\n- [src/visualizer/ProjectMBridge.cpp](src/visualizer/ProjectMBridge.cpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document describes the preset management system responsible for discovering, organizing, and selecting projectM visualization presets (`.milk` and `.prjm` files). The `PresetManager` class provides functionality for scanning preset directories, maintaining favorites and blacklists, navigating preset history, and persisting user preferences to disk.\n\nFor information about the projectM v4 integration that consumes presets, see [ProjectM Integration](#4.2). For details about the visualization window that displays presets, see [VisualizerWindow](#4.1).\n\n---\n\n## System Architecture\n\nThe preset management system consists of three primary components: the `PresetManager` class for business logic, the `PresetInfo` struct for metadata storage, and integration points with `ProjectMBridge` and UI widgets.\n\n**Diagram: Preset Management Architecture**\n\n```mermaid\ngraph TB\n    subgraph \"Data Model\"\n        PI[\"PresetInfo struct\u003cbr/\u003epath, name, author, category\u003cbr/\u003efavorite, blacklisted, playCount\"]\n    end\n    \n    subgraph \"Core Logic\"\n        PM[\"PresetManager\u003cbr/\u003esrc/visualizer/PresetManager.hpp\"]\n        SCAN[\"scan() / rescan()\"]\n        SELECT[\"selectByIndex()\u003cbr/\u003eselectByName()\u003cbr/\u003eselectByPath()\u003cbr/\u003eselectRandom()\"]\n        NAV[\"selectNext()\u003cbr/\u003eselectPrevious()\"]\n        FAV[\"setFavorite()\u003cbr/\u003esetBlacklisted()\"]\n        STATE[\"loadState()\u003cbr/\u003esaveState()\"]\n    end\n    \n    subgraph \"Persistence\"\n        STATE_FILE[\"preset_state.txt\u003cbr/\u003e[favorites] \u0026 [blacklist] sections\"]\n    end\n    \n    subgraph \"Integration Points\"\n        PMB[\"ProjectMBridge\u003cbr/\u003eowns PresetManager\"]\n        VIZ_PANEL[\"VisualizerPanel\u003cbr/\u003epreset navigation buttons\"]\n        PRESET_BROWSER[\"PresetBrowser\u003cbr/\u003epreset list UI\"]\n    end\n    \n    PM --\u003e PI\n    PM --\u003e SCAN\n    PM --\u003e SELECT\n    PM --\u003e NAV\n    PM --\u003e FAV\n    PM --\u003e STATE\n    \n    STATE \u003c--\u003e STATE_FILE\n    \n    PMB --\u003e PM\n    VIZ_PANEL -.-\u003e|calls via ProjectMBridge| PM\n    PRESET_BROWSER -.-\u003e|calls via VisualizerController| PM\n    \n    PM -.-\u003e|\"presetChanged signal\"| PMB\n    PM -.-\u003e|\"listChanged signal\"| PRESET_BROWSER\n```\n\n**Sources:** [src/visualizer/PresetManager.hpp:1-109](), [src/visualizer/PresetManager.cpp:1-467](), [src/visualizer/ProjectMBridge.cpp:1-171]()\n\n---\n\n## PresetInfo Data Structure\n\nThe `PresetInfo` struct encapsulates metadata for a single preset file. Each preset is represented by an instance of this struct within the `PresetManager`.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `path` | `fs::path` | Absolute filesystem path to the preset file |\n| `name` | `std::string` | Display name (extracted from filename stem) |\n| `author` | `std::string` | Author name (parsed from filename pattern \"Author - Name\") |\n| `category` | `std::string` | Category name (parent directory relative to scan root) |\n| `favorite` | `bool` | Whether the preset is marked as favorite |\n| `blacklisted` | `bool` | Whether the preset is blacklisted (excluded from selection) |\n| `playCount` | `u32` | Number of times the preset has been selected |\n\nThe `parsePresetInfo()` method attempts to extract author information from filenames matching the pattern `^(.+?)\\s*-\\s*(.+)$`. Categories are automatically assigned based on the preset file's parent directory relative to the scan root, with uncategorized files assigned to \"Uncategorized\".\n\n**Sources:** [src/visualizer/PresetManager.hpp:14-22](), [src/visualizer/PresetManager.cpp:400-412]()\n\n---\n\n## Preset Scanning and Discovery\n\n### Scanning Process\n\nThe `PresetManager::scan()` method recursively discovers preset files within a specified directory. The scanning process follows this workflow:\n\n**Diagram: Preset Scanning Workflow**\n\n```mermaid\nflowchart TD\n    START[\"scan(directory, recursive)\"]\n    CHECK_DIR{\"Directory exists?\"}\n    CLEAR[\"Clear presets_ vector\"]\n    LIST[\"file::listFiles()\u003cbr/\u003ewith preset extensions\"]\n    LOOP_START[\"For each preset file\"]\n    CREATE_INFO[\"Create PresetInfo\u003cbr/\u003eextract name, category\"]\n    PARSE[\"parsePresetInfo()\u003cbr/\u003eextract author\"]\n    APPLY_STATE[\"Apply favoriteNames_\u003cbr/\u003eand blacklistedNames_\"]\n    ADD[\"Add to presets_ vector\"]\n    LOOP_END{\"More files?\"}\n    SORT[\"Sort by name\"]\n    PENDING{\"pendingPresetName_\u003cbr/\u003eset?\"}\n    APPLY_PENDING[\"selectByName(pending)\"]\n    EMIT[\"Emit listChanged signal\"]\n    RETURN[\"Return Result::ok()\"]\n    ERROR[\"Return Result::err()\"]\n    \n    START --\u003e CHECK_DIR\n    CHECK_DIR --\u003e|No| ERROR\n    CHECK_DIR --\u003e|Yes| CLEAR\n    CLEAR --\u003e LIST\n    LIST --\u003e LOOP_START\n    LOOP_START --\u003e CREATE_INFO\n    CREATE_INFO --\u003e PARSE\n    PARSE --\u003e APPLY_STATE\n    APPLY_STATE --\u003e ADD\n    ADD --\u003e LOOP_END\n    LOOP_END --\u003e|Yes| LOOP_START\n    LOOP_END --\u003e|No| SORT\n    SORT --\u003e PENDING\n    PENDING --\u003e|Yes| APPLY_PENDING\n    PENDING --\u003e|No| EMIT\n    APPLY_PENDING --\u003e EMIT\n    EMIT --\u003e RETURN\n```\n\n**Sources:** [src/visualizer/PresetManager.cpp:12-71]()\n\n### File Discovery\n\nPreset files are discovered using `file::listFiles()` from the utility layer, which supports multiple preset extensions defined in `file::presetExtensions`. The scan can be performed recursively or non-recursively based on the `recursive` parameter.\n\n**Sources:** [src/visualizer/PresetManager.cpp:21]()\n\n### Category Assignment\n\nCategories are derived from the directory structure. For a preset at path `/presets/Ambient/Calm Waves.milk` with scan directory `/presets`, the category would be `Ambient`. Files directly in the scan directory receive the category `Uncategorized`.\n\n**Sources:** [src/visualizer/PresetManager.cpp:28-32]()\n\n### Integration with ProjectMBridge\n\nThe `ProjectMBridge` initializes the `PresetManager` during its own initialization:\n\n```cpp\n// From ProjectMBridge::init()\nif (!config.presetPath.empty() \u0026\u0026 fs::exists(config.presetPath)) {\n    presets_.scan(config.presetPath);\n    presets_.loadState(file::configDir() / \"preset_state.txt\");\n}\n```\n\nAfter scanning, if a forced preset name is specified via configuration, the manager attempts to select it. Otherwise, it selects a random preset (if shuffle is enabled) or the first preset in the sorted list.\n\n**Sources:** [src/visualizer/ProjectMBridge.cpp:36-51]()\n\n---\n\n## Preset Selection Mechanisms\n\nThe `PresetManager` provides multiple selection methods to accommodate different use cases:\n\n### Selection Methods\n\n| Method | Purpose | Behavior |\n|--------|---------|----------|\n| `selectByIndex(usize)` | Direct index selection | Selects preset at specified index if not blacklisted, updates history |\n| `selectByName(string)` | Name-based selection | Searches by exact match, then partial match, then case-insensitive match |\n| `selectByPath(fs::path)` | Path-based selection | Finds preset matching exact filesystem path |\n| `selectRandom()` | Random selection | Randomly selects from active (non-blacklisted) presets |\n| `selectNext()` | Forward navigation | Advances to next non-blacklisted preset, uses history if available |\n| `selectPrevious()` | Backward navigation | Returns to previous preset in history or cycles backward |\n\n**Diagram: Selection Method Flow**\n\n```mermaid\nflowchart TD\n    SELECT_INDEX[\"selectByIndex(index)\"]\n    CHECK_RANGE{\"index \u003c presets_.size()?\"}\n    CHECK_BLACKLIST{\"blacklisted?\"}\n    UPDATE_HIST[\"Update history_\u003cbr/\u003ehistoryPosition_++\"]\n    LIMIT_HIST{\"history_.size() \u003e 100?\"}\n    TRIM[\"Erase oldest entry\"]\n    SET_CURRENT[\"currentIndex_ = index\u003cbr/\u003eplayCount++\"]\n    EMIT[\"Emit presetChanged signal\"]\n    FAIL[\"Return false\"]\n    SUCCESS[\"Return true\"]\n    \n    SELECT_INDEX --\u003e CHECK_RANGE\n    CHECK_RANGE --\u003e|No| FAIL\n    CHECK_RANGE --\u003e|Yes| CHECK_BLACKLIST\n    CHECK_BLACKLIST --\u003e|Yes| FAIL\n    CHECK_BLACKLIST --\u003e|No| UPDATE_HIST\n    UPDATE_HIST --\u003e LIMIT_HIST\n    LIMIT_HIST --\u003e|Yes| TRIM\n    LIMIT_HIST --\u003e|No| SET_CURRENT\n    TRIM --\u003e SET_CURRENT\n    SET_CURRENT --\u003e EMIT\n    EMIT --\u003e SUCCESS\n```\n\n**Sources:** [src/visualizer/PresetManager.cpp:125-155]()\n\n### Name-Based Selection Strategy\n\nThe `selectByName()` method implements a fallback search strategy to maximize the chance of finding a preset:\n\n1. **Exact match**: Compare against `PresetInfo::name` exactly\n2. **Partial match**: Check if preset name contains the search string\n3. **Case-insensitive match**: Convert both strings to lowercase and check containment\n\nIf no presets are loaded when `selectByName()` is called, the name is stored in `pendingPresetName_` and applied automatically after the next `scan()` operation.\n\n**Sources:** [src/visualizer/PresetManager.cpp:157-218]()\n\n### Random Selection\n\nRandom selection uses `std::mt19937` with `std::uniform_int_distribution` to select from the active preset pool (excluding blacklisted presets). The random number generator is seeded from `std::random_device` at construction.\n\n**Sources:** [src/visualizer/PresetManager.hpp:106](), [src/visualizer/PresetManager.cpp:235-250]()\n\n---\n\n## History Navigation\n\nThe `PresetManager` maintains a navigation history to support browser-like forward/back behavior. History is implemented as a vector of indices with a position cursor.\n\n### History Data Structures\n\n```cpp\n// From PresetManager class\nstd::vector\u003cusize\u003e history_;      // Stack of selected preset indices\nusize historyPosition_{0};         // Current position in history\n```\n\n### History Management Rules\n\n1. **Adding to history**: When `selectByIndex()` is called and the selected index differs from the current history position, the new index is appended\n2. **Clearing forward history**: If the user selects a new preset while positioned in the middle of history, all forward entries are discarded\n3. **History limit**: The history is capped at 100 entries; the oldest entry is removed when this limit is exceeded\n4. **Navigation behavior**: \n   - `selectNext()` advances `historyPosition_` if forward history exists\n   - `selectPrevious()` decrements `historyPosition_` if backward history exists\n   - If no history is available, these methods fall back to linear iteration\n\n**Sources:** [src/visualizer/PresetManager.hpp:99-100](), [src/visualizer/PresetManager.cpp:131-147](), [src/visualizer/PresetManager.cpp:260-267](), [src/visualizer/PresetManager.cpp:297-304]()\n\n---\n\n## Favorites and Blacklist System\n\nThe preset management system supports user curation through favorites and blacklists. These features are implemented using string sets that store preset names rather than indices, ensuring persistence across rescans.\n\n### Data Structures\n\n```cpp\nstd::set\u003cstd::string\u003e favoriteNames_;     // Preset names marked as favorite\nstd::set\u003cstd::string\u003e blacklistedNames_;  // Preset names excluded from selection\n```\n\n### Modification Methods\n\n| Method | Description |\n|--------|-------------|\n| `setFavorite(index, bool)` | Marks preset as favorite or removes favorite status |\n| `setBlacklisted(index, bool)` | Marks preset as blacklisted or removes blacklist status |\n| `toggleFavorite(index)` | Toggles favorite status for preset at index |\n| `toggleBlacklisted(index)` | Toggles blacklist status for preset at index |\n\nAll modification methods emit the `listChanged` signal to notify observers (typically UI widgets) that the preset list has been updated.\n\n### Filtered Access Methods\n\n```cpp\nstd::vector\u003cconst PresetInfo*\u003e activePresets() const;    // Non-blacklisted only\nstd::vector\u003cconst PresetInfo*\u003e favoritePresets() const;  // Favorites that aren't blacklisted\nusize activeCount() const;                               // Count excluding blacklisted\n```\n\n**Sources:** [src/visualizer/PresetManager.hpp:102-103](), [src/visualizer/PresetManager.cpp:326-362](), [src/visualizer/PresetManager.cpp:85-109]()\n\n---\n\n## State Persistence\n\nUser preferences (favorites and blacklists) are persisted to `preset_state.txt` in the configuration directory. The file format is a simple INI-style format with two sections.\n\n### File Format\n\n```\n[favorites]\npreset_name_1\npreset_name_2\n\n[blacklist]\npreset_name_3\npreset_name_4\n```\n\n### Loading State\n\nThe `loadState()` method reads the state file and populates the `favoriteNames_` and `blacklistedNames_` sets. After loading, it iterates through all loaded presets and applies the saved state by setting the `favorite` and `blacklisted` fields.\n\n**Diagram: State Loading Process**\n\n```mermaid\nflowchart TD\n    LOAD[\"loadState(path)\"]\n    OPEN{\"File exists?\"}\n    READLINE[\"Read line by line\"]\n    CHECK_SECTION{\"Line content?\"}\n    SET_FAV[\"section = 'favorites'\"]\n    SET_BL[\"section = 'blacklist'\"]\n    ADD_FAV[\"favoriteNames_.insert(line)\"]\n    ADD_BL[\"blacklistedNames_.insert(line)\"]\n    APPLY[\"Apply to presets_ vector\u003cbr/\u003eset favorite/blacklisted flags\"]\n    DONE[\"Return Result::ok()\"]\n    \n    LOAD --\u003e OPEN\n    OPEN --\u003e|No| DONE\n    OPEN --\u003e|Yes| READLINE\n    READLINE --\u003e CHECK_SECTION\n    CHECK_SECTION --\u003e|\"[favorites]\"| SET_FAV\n    CHECK_SECTION --\u003e|\"[blacklist]\"| SET_BL\n    CHECK_SECTION --\u003e|favorite section| ADD_FAV\n    CHECK_SECTION --\u003e|blacklist section| ADD_BL\n    ADD_FAV --\u003e READLINE\n    ADD_BL --\u003e READLINE\n    SET_FAV --\u003e READLINE\n    SET_BL --\u003e READLINE\n    READLINE --\u003e|EOF| APPLY\n    APPLY --\u003e DONE\n```\n\n**Sources:** [src/visualizer/PresetManager.cpp:414-445]()\n\n### Saving State\n\nThe `saveState()` method writes the current `favoriteNames_` and `blacklistedNames_` sets to disk in the same INI-style format. This method is called automatically during `ProjectMBridge::shutdown()`.\n\n**Sources:** [src/visualizer/PresetManager.cpp:447-464](), [src/visualizer/ProjectMBridge.cpp:56-62]()\n\n### Integration with Configuration System\n\nThe state file path is constructed using the utility function `file::configDir()`, which returns the application's configuration directory (typically `~/.config/chadvis-projectm-qt/` on Linux). The filename is hardcoded as `preset_state.txt`.\n\n**Sources:** [src/visualizer/ProjectMBridge.cpp:38](), [src/visualizer/ProjectMBridge.cpp:58]()\n\n---\n\n## Search and Filtering\n\nThe `PresetManager` provides search and filtering capabilities to help users find specific presets.\n\n### Search Methods\n\n| Method | Parameters | Return Type | Description |\n|--------|-----------|-------------|-------------|\n| `search(query)` | `const std::string\u0026` | `vector\u003cconst PresetInfo*\u003e` | Case-insensitive substring search in preset names |\n| `byCategory(category)` | `const std::string\u0026` | `vector\u003cconst PresetInfo*\u003e` | Returns all non-blacklisted presets in specified category |\n| `categories()` | None | `vector\u003cstd::string\u003e` | Returns list of all unique categories |\n\nAll search methods return pointers to `PresetInfo` objects rather than copies, allowing efficient iteration and access without duplication.\n\n**Sources:** [src/visualizer/PresetManager.cpp:364-398](), [src/visualizer/PresetManager.cpp:111-117]()\n\n---\n\n## Signal-Based Communication\n\nThe `PresetManager` uses the application's custom signal system to notify observers of state changes.\n\n### Signals\n\n```cpp\nSignal\u003cconst PresetInfo*\u003e presetChanged;  // Emitted when selection changes\nSignal\u003c\u003e listChanged;                     // Emitted when list is modified\n```\n\n### presetChanged Signal\n\nEmitted by `selectByIndex()` when a preset is successfully selected. The signal carries a pointer to the selected `PresetInfo`. The `ProjectMBridge` connects to this signal to load the preset into projectM:\n\n```cpp\n// From ProjectMBridge::init()\npresets_.presetChanged.connect(\n    [this](const PresetInfo* p) { onPresetManagerChanged(p); });\n```\n\nThe handler calls `projectm_load_preset_file()` and emits its own `presetChanged` signal for UI consumption.\n\n**Sources:** [src/visualizer/PresetManager.cpp:151](), [src/visualizer/ProjectMBridge.cpp:33-34](), [src/visualizer/ProjectMBridge.cpp:164-168]()\n\n### listChanged Signal\n\nEmitted when the preset list is modified through:\n- `scan()` completing\n- `clear()` being called\n- `setFavorite()` or `setBlacklisted()` changing a preset's state\n\nUI widgets typically connect to this signal to refresh their display.\n\n**Sources:** [src/visualizer/PresetManager.cpp:68](), [src/visualizer/PresetManager.cpp:82](), [src/visualizer/PresetManager.cpp:336](), [src/visualizer/PresetManager.cpp:349]()\n\n---\n\n## UI Integration\n\n### VisualizerPanel Integration\n\nThe `VisualizerPanel` provides basic preset navigation controls that interact with the `PresetManager` through the `ProjectMBridge`:\n\n```cpp\n// Previous preset button\nconnect(prevPresetButton_, \u0026QPushButton::clicked, this, [this] {\n    visualizerWindow_-\u003eprojectM().previousPreset();\n});\n\n// Next preset button\nconnect(nextPresetButton_, \u0026QPushButton::clicked, this, [this] {\n    visualizerWindow_-\u003eprojectM().nextPreset();\n});\n```\n\nThe panel also displays the current preset name in a `MarqueeLabel`, updating via the `presetNameUpdated` signal from `VisualizerWindow`.\n\n**Sources:** [src/ui/VisualizerPanel.cpp:52-82](), [src/ui/VisualizerPanel.cpp:128-137]()\n\n### PresetBrowser Widget\n\nThe `PresetBrowser` widget (referenced in the table of contents but not included in provided files) likely provides a more comprehensive interface including:\n- Full preset list display\n- Category filtering\n- Search functionality\n- Favorite/blacklist management\n- Direct preset selection\n\nThis widget would connect to both `presetChanged` and `listChanged` signals to maintain synchronization with the `PresetManager` state.\n\n---\n\n## Pending Preset System\n\nThe pending preset system handles the edge case where preset selection is requested before the scan operation has completed. This is particularly useful for command-line arguments that specify a startup preset.\n\n### Workflow\n\n1. If `selectByName()` is called when `presets_.empty()`, the name is stored in `pendingPresetName_`\n2. After `scan()` completes, if `pendingPresetName_` is not empty, `selectByName()` is called again\n3. Whether successful or not, `pendingPresetName_` is cleared\n\n### API\n\n```cpp\nvoid setPendingPreset(const std::string\u0026 name);\nconst std::string\u0026 pendingPreset() const;\nvoid clearPendingPreset();\n```\n\n**Sources:** [src/visualizer/PresetManager.hpp:62-71](), [src/visualizer/PresetManager.cpp:56-66](), [src/visualizer/PresetManager.cpp:162-166]()\n\n---\n\n## Threading Considerations\n\nThe `PresetManager` is **not thread-safe**. It is designed to be accessed exclusively from the main UI thread. Signal emission and preset selection operations should not be called from worker threads. The `ProjectMBridge` (which owns the `PresetManager`) operates on the main thread, as does all UI interaction, ensuring thread safety through single-threaded access rather than synchronization primitives.\n\n**Sources:** [src/visualizer/PresetManager.hpp:1-109]()"])</script><script>self.__next_f.push([1,"24:T55f4,"])</script><script>self.__next_f.push([1,"# Recording System\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [src/core/Config.cpp](src/core/Config.cpp)\n- [src/recorder/VideoRecorder.cpp](src/recorder/VideoRecorder.cpp)\n- [src/visualizer/VisualizerWindow.cpp](src/visualizer/VisualizerWindow.cpp)\n- [src/visualizer/VisualizerWindow.hpp](src/visualizer/VisualizerWindow.hpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThe Recording System provides FFmpeg-based video recording capabilities, capturing both the rendered visualization frames and audio playback data. This system operates asynchronously to minimize performance impact on real-time rendering. It uses double-buffered Pixel Buffer Objects (PBOs) for zero-copy frame capture from OpenGL, queues frames in a background thread, and encodes them using FFmpeg's libavcodec/libavformat libraries.\n\nFor detailed information about the `VideoRecorder` class and FFmpeg pipeline, see [VideoRecorder](#5.1). For frame capture mechanics and PBO implementation, see [Frame Capture \u0026 PBOs](#5.2).\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:1-426](), [src/recorder/VideoRecorder.cpp:1-640]()\n\n---\n\n## System Architecture\n\nThe recording system consists of three primary components that work together to capture and encode audio-visual data:\n\n```mermaid\ngraph TB\n    subgraph \"Capture Sources\"\n        VW[\"VisualizerWindow\u003cbr/\u003e(OpenGL Rendering)\"]\n        AE[\"AudioEngine\u003cbr/\u003e(Audio Playback)\"]\n    end\n    \n    subgraph \"Recording System\"\n        VR[\"VideoRecorder\u003cbr/\u003e(Main Coordinator)\"]\n        FG[\"FrameGrabber\u003cbr/\u003e(Frame Queue)\"]\n        ET[\"encodingThread()\u003cbr/\u003e(Background Worker)\"]\n    end\n    \n    subgraph \"FFmpeg Pipeline\"\n        VS[\"Video Stream\u003cbr/\u003e(sws_scale + libx264/265)\"]\n        AS[\"Audio Stream\u003cbr/\u003e(swr_convert + AAC)\"]\n        MUX[\"Muxer\u003cbr/\u003e(avformat_write_frame)\"]\n    end\n    \n    subgraph \"OpenGL Components\"\n        PBO[\"PBOs[2]\u003cbr/\u003e(Double-buffered)\"]\n        RT[\"RenderTarget\u003cbr/\u003e(FBO)\"]\n    end\n    \n    subgraph \"Output\"\n        FILE[\"Output File\u003cbr/\u003e(MP4/MKV)\"]\n    end\n    \n    VW --\u003e|\"captureAsync()\"| PBO\n    PBO --\u003e|\"frameCaptured signal\"| VR\n    VR --\u003e|\"submitVideoFrame()\"| FG\n    AE --\u003e|\"submitAudioSamples()\"| VR\n    \n    FG --\u003e|\"getNextFrame()\"| ET\n    VR --\u003e|\"processAudioBuffer()\"| ET\n    \n    ET --\u003e|\"sws_scale()\"| VS\n    ET --\u003e|\"swr_convert()\"| AS\n    \n    VS --\u003e MUX\n    AS --\u003e MUX\n    MUX --\u003e FILE\n    \n    VW -.-\u003e|\"renders to\"| RT\n    RT -.-\u003e|\"read from\"| PBO\n```\n\n**Diagram: Recording System Component Architecture**\n\nThe system follows a producer-consumer pattern where `VisualizerWindow` and `AudioEngine` produce data, `FrameGrabber` queues it, and the encoding thread consumes and processes it asynchronously.\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:258-288](), [src/recorder/VideoRecorder.cpp:113-170](), [src/recorder/VideoRecorder.cpp:172-211]()\n\n---\n\n## Recording States and Control Flow\n\nThe recording system uses a state machine to manage the recording lifecycle:\n\n```mermaid\nstateDiagram-v2\n    [*] --\u003e Stopped\n    \n    Stopped --\u003e Starting: start()\n    Starting --\u003e Recording: FFmpeg init success\n    Starting --\u003e Error: FFmpeg init failed\n    \n    Recording --\u003e Stopping: stop()\n    Stopping --\u003e Stopped: cleanup complete\n    \n    Error --\u003e Stopped: user action\n    \n    note right of Starting\n        - Validate EncoderSettings\n        - Initialize FFmpeg contexts\n        - Create output file\n        - Start encoding thread\n    end note\n    \n    note right of Recording\n        - Accept video frames\n        - Accept audio samples\n        - Encode asynchronously\n        - Update stats\n    end note\n    \n    note right of Stopping\n        - Stop frame capture\n        - Flush encoders\n        - Write trailer\n        - Join encoding thread\n    end note\n```\n\n**Diagram: RecordingState State Machine**\n\n| State | Description | Valid Transitions |\n|-------|-------------|-------------------|\n| `Stopped` | Not recording, resources released |  `Starting` |\n| `Starting` | Initializing FFmpeg pipeline |  `Recording`, `Error` |\n| `Recording` | Actively capturing and encoding |  `Stopping` |\n| `Stopping` | Flushing and finalizing output |  `Stopped` |\n| `Error` | Initialization or encoding error |  `Stopped` |\n\n**Sources:** [src/recorder/VideoRecorder.cpp:18-111]()\n\n---\n\n## Frame Capture Pipeline\n\nFrame capture uses double-buffered Pixel Buffer Objects (PBOs) for efficient, zero-copy transfers from GPU to CPU memory:\n\n```mermaid\nsequenceDiagram\n    participant RT as RenderTarget (FBO)\n    participant PBO0 as PBO[0]\n    participant PBO1 as PBO[1]\n    participant CPU as CPU Memory\n    participant VR as VideoRecorder\n    \n    Note over RT,VR: Frame N\n    RT-\u003e\u003ePBO0: glReadPixels (async DMA)\n    \n    Note over RT,VR: Frame N+1\n    RT-\u003e\u003ePBO1: glReadPixels (async DMA)\n    PBO0-\u003e\u003eCPU: glMapBuffer (Frame N data)\n    CPU-\u003e\u003eVR: frameCaptured signal (move vector)\n    \n    Note over RT,VR: Frame N+2\n    RT-\u003e\u003ePBO0: glReadPixels (async DMA)\n    PBO1-\u003e\u003eCPU: glMapBuffer (Frame N+1 data)\n    CPU-\u003e\u003eVR: frameCaptured signal (move vector)\n```\n\n**Diagram: Double-Buffered PBO Frame Capture Flow**\n\nThe double-buffering strategy ensures that:\n1. **Frame N** is read into `PBO[pboIndex]` via `glReadPixels` (non-blocking)\n2. **Frame N-1** in `PBO[nextIndex]` is mapped to CPU memory (blocking)\n3. Mapped data is copied once and moved (zero-copy semantics) via Qt signal\n4. Indices swap for next frame\n\nThis approach eliminates pipeline stalls by overlapping DMA transfers with CPU processing.\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:239-288](), [src/visualizer/VisualizerWindow.hpp:99-107]()\n\n---\n\n## Frame Processing Flow\n\n```mermaid\nflowchart LR\n    subgraph \"VisualizerWindow (OpenGL Thread)\"\n        RENDER[\"renderFrame()\"]\n        OVERLAY[\"overlayTarget_\u003cbr/\u003e(with text)\"]\n        CAPTURE[\"captureAsync()\"]\n        PBO[\"PBOs[pboIndex_]\"]\n    end\n    \n    subgraph \"Signal/Slot Bridge\"\n        SIG[\"frameCaptured signal\u003cbr/\u003e(data, w, h, timestamp)\"]\n    end\n    \n    subgraph \"VideoRecorder (Main Thread)\"\n        SUBMIT[\"submitVideoFrame()\"]\n        FG[\"FrameGrabber\u003cbr/\u003equeue_\u003cbr/\u003e(lock-free)\"]\n    end\n    \n    subgraph \"Encoding Thread\"\n        GET[\"getNextFrame()\"]\n        PROCESS[\"processVideoFrame()\"]\n        SWS[\"sws_scale()\u003cbr/\u003e(RGBAYUV420P)\"]\n        ENCODE[\"encodeVideoFrame()\"]\n        WRITE[\"writePacket()\"]\n    end\n    \n    RENDER --\u003e OVERLAY\n    OVERLAY --\u003e CAPTURE\n    CAPTURE --\u003e PBO\n    PBO -.-\u003e|\"frame N-1 ready\"| SIG\n    SIG --\u003e SUBMIT\n    SUBMIT --\u003e|\"move vector\"| FG\n    \n    FG --\u003e GET\n    GET --\u003e PROCESS\n    PROCESS --\u003e SWS\n    SWS --\u003e ENCODE\n    ENCODE --\u003e WRITE\n```\n\n**Diagram: End-to-End Frame Processing Pipeline**\n\n**Key optimizations:**\n- **Zero-copy transfer:** Frame data is moved (not copied) from `VisualizerWindow` to `FrameGrabber` [src/visualizer/VisualizerWindow.cpp:276-282]()\n- **Lock-free queue:** `FrameGrabber` uses a concurrent queue for minimal contention\n- **Async encoding:** FFmpeg operations run in a dedicated thread [src/recorder/VideoRecorder.cpp:172-211]()\n- **Color space conversion:** `sws_scale` converts RGBA to YUV420P efficiently [src/recorder/VideoRecorder.cpp:226-232]()\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:133-237](), [src/recorder/VideoRecorder.cpp:113-148](), [src/recorder/VideoRecorder.cpp:213-239]()\n\n---\n\n## Audio Capture and Encoding\n\nAudio samples flow from `AudioEngine` to `VideoRecorder` and are buffered until enough data is available for encoding:\n\n```mermaid\nflowchart TB\n    subgraph \"AudioEngine\"\n        PCM[\"PCM Float Data\u003cbr/\u003e(f32 interleaved)\"]\n    end\n    \n    subgraph \"VideoRecorder (Main Thread)\"\n        SUBMIT_AUD[\"submitAudioSamples()\"]\n        BUF[\"audioBuffer_\u003cbr/\u003e(std::vector\u003cf32\u003e)\"]\n    end\n    \n    subgraph \"Encoding Thread\"\n        PROC[\"processAudioBuffer()\"]\n        CHECK{\"buffer.size() \u003e=\u003cbr/\u003eframeSize * channels?\"}\n        EXTRACT[\"Extract frameSize samples\"]\n        SWR[\"swr_convert()\u003cbr/\u003e(FLTcodec format)\"]\n        ENC_AUD[\"encodeAudioFrame()\"]\n        WRITE_AUD[\"writePacket()\"]\n    end\n    \n    PCM --\u003e|\"if recording\"| SUBMIT_AUD\n    SUBMIT_AUD --\u003e|\"mutex lock\"| BUF\n    \n    BUF --\u003e PROC\n    PROC --\u003e CHECK\n    CHECK --\u003e|\"Yes\"| EXTRACT\n    CHECK --\u003e|\"No\"| PROC\n    EXTRACT --\u003e SWR\n    SWR --\u003e ENC_AUD\n    ENC_AUD --\u003e WRITE_AUD\n```\n\n**Diagram: Audio Capture and Encoding Flow**\n\n**Audio processing details:**\n- Samples are accumulated in `audioBuffer_` until at least `audioCodecCtx_-\u003eframe_size` samples are available [src/recorder/VideoRecorder.cpp:253-257]()\n- `swr_convert()` handles sample format conversion (e.g., FLT to FLTP) and resampling [src/recorder/VideoRecorder.cpp:261-269]()\n- Frame timestamps (`pts`) are calculated based on accumulated sample count [src/recorder/VideoRecorder.cpp:271-272]()\n- Audio encoding is interleaved with video encoding in the same thread [src/recorder/VideoRecorder.cpp:184]()\n\n**Sources:** [src/recorder/VideoRecorder.cpp:150-170](), [src/recorder/VideoRecorder.cpp:241-279]()\n\n---\n\n## Encoding Thread Lifecycle\n\nThe encoding thread runs continuously while recording, processing both video and audio data:\n\n```mermaid\nflowchart TB\n    START[\"encodingThread() starts\"]\n    LOOP{\"shouldStop_ == false\"}\n    \n    GET_VID[\"getNextFrame(frame, 10ms)\"]\n    HAS_VID{\"hasVideo?\"}\n    PROC_VID[\"processVideoFrame(frame)\"]\n    \n    PROC_AUD[\"processAudioBuffer()\"]\n    \n    CHECK_STOP{\"shouldStop_ \u0026\u0026\u003cbr/\u003e!hasFrames?\"}\n    \n    UPDATE_STATS{\"time for stats update?\"}\n    CALC_STATS[\"Calculate avgFps, elapsed time\"]\n    EMIT_STATS[\"statsUpdated.emitSignal()\"]\n    \n    LOOP_BACK[\"Continue loop\"]\n    FINISH[\"Break loop\"]\n    FLUSH[\"Flush encoders\"]\n    END[\"Thread exits\"]\n    \n    START --\u003e LOOP\n    LOOP --\u003e|\"true\"| GET_VID\n    GET_VID --\u003e HAS_VID\n    HAS_VID --\u003e|\"true\"| PROC_VID\n    HAS_VID --\u003e|\"false\"| PROC_AUD\n    PROC_VID --\u003e PROC_AUD\n    \n    PROC_AUD --\u003e CHECK_STOP\n    CHECK_STOP --\u003e|\"true\"| FINISH\n    CHECK_STOP --\u003e|\"false\"| UPDATE_STATS\n    \n    UPDATE_STATS --\u003e|\"yes\"| CALC_STATS\n    UPDATE_STATS --\u003e|\"no\"| LOOP_BACK\n    CALC_STATS --\u003e EMIT_STATS\n    EMIT_STATS --\u003e LOOP_BACK\n    LOOP_BACK --\u003e LOOP\n    \n    LOOP --\u003e|\"false\"| FINISH\n    FINISH --\u003e FLUSH\n    FLUSH --\u003e END\n```\n\n**Diagram: Encoding Thread Control Flow**\n\nThe encoding thread:\n1. **Polls** for video frames with 10ms timeout [src/recorder/VideoRecorder.cpp:179]()\n2. **Processes** available video frames immediately [src/recorder/VideoRecorder.cpp:180-182]()\n3. **Processes** audio buffer on every iteration [src/recorder/VideoRecorder.cpp:184]()\n4. **Updates statistics** every second [src/recorder/VideoRecorder.cpp:190-207]()\n5. **Exits cleanly** when `shouldStop_` is set and all queued frames are processed [src/recorder/VideoRecorder.cpp:186-188]()\n\n**Sources:** [src/recorder/VideoRecorder.cpp:172-211]()\n\n---\n\n## FFmpeg Pipeline Initialization\n\nThe recording system initializes FFmpeg components in a specific order:\n\n| Component | Initialization Function | Purpose |\n|-----------|-------------------------|---------|\n| Output Context | `avformat_alloc_output_context2()` | Creates format context for MP4/MKV container |\n| Video Stream | `initVideoStream()` | Configures H.264/H.265 encoder with CRF settings |\n| Audio Stream | `initAudioStream()` | Configures AAC encoder with bitrate settings |\n| Scale Context | `sws_getContext()` | Sets up RGBAYUV420P color conversion |\n| Resample Context | `swr_alloc_set_opts2()` | Sets up floatplanar format conversion |\n| File I/O | `avio_open()` | Opens output file for writing |\n| Header | `avformat_write_header()` | Writes container header with stream metadata |\n\n**Initialization sequence** [src/recorder/VideoRecorder.cpp:281-326]():\n```cpp\n// 1. Create format context\navformat_alloc_output_context2(\u0026ctx, nullptr, nullptr, outputPath);\n\n// 2. Initialize video stream (codec, dimensions, framerate)\ninitVideoStream();  // Creates videoCodecCtx_, videoFrame_, swsCtx_\n\n// 3. Initialize audio stream (codec, sample rate, channels)\ninitAudioStream();  // Creates audioCodecCtx_, audioFrame_, swrCtx_\n\n// 4. Open output file\navio_open(\u0026formatCtx_-\u003epb, outputPath, AVIO_FLAG_WRITE);\n\n// 5. Write header to file\navformat_write_header(formatCtx_.get(), \u0026opts);\n```\n\n**Sources:** [src/recorder/VideoRecorder.cpp:281-326](), [src/recorder/VideoRecorder.cpp:328-423](), [src/recorder/VideoRecorder.cpp:425-519]()\n\n---\n\n## Video Codec Configuration\n\nVideo encoding settings are configured through `VideoEncoderConfig` and applied during stream initialization:\n\n```mermaid\ngraph LR\n    subgraph \"Config (TOML)\"\n        TOML[\"recording.video\u003cbr/\u003ecodec: libx264\u003cbr/\u003ecrf: 23\u003cbr/\u003epreset: ultrafast\u003cbr/\u003ewidth: 1280\u003cbr/\u003eheight: 720\u003cbr/\u003efps: 30\"]\n    end\n    \n    subgraph \"EncoderSettings\"\n        VEC[\"VideoEncoderConfig\u003cbr/\u003ewidth, height\u003cbr/\u003efps, crf\u003cbr/\u003ecodec, preset\"]\n    end\n    \n    subgraph \"FFmpeg Context\"\n        CODEC[\"AVCodecContext\u003cbr/\u003ewidth, height\u003cbr/\u003etime_base\u003cbr/\u003epix_fmt\u003cbr/\u003egop_size\"]\n        OPTS[\"AVDictionary\u003cbr/\u003epreset=ultrafast\u003cbr/\u003ecrf=23\u003cbr/\u003etune=zerolatency\"]\n    end\n    \n    TOML --\u003e VEC\n    VEC --\u003e CODEC\n    VEC --\u003e OPTS\n    CODEC --\u003e ENC[\"avcodec_open2()\"]\n    OPTS --\u003e ENC\n```\n\n**Diagram: Video Codec Configuration Flow**\n\n**Key configuration options** [src/recorder/VideoRecorder.cpp:346-378]():\n- **Pixel format:** Always YUV420P for H.264/H.265 compatibility\n- **GOP size:** `fps * 2` (e.g., 60 frames at 30fps)\n- **CRF (Constant Rate Factor):** 0-51, lower = better quality, default 23\n- **Preset:** Controls encoding speed vs compression (ultrafast, fast, medium, slow, veryslow)\n- **Tune:** Set to \"zerolatency\" for real-time encoding\n\n**Sources:** [src/recorder/VideoRecorder.cpp:328-423](), [src/core/Config.cpp:219-240]()\n\n---\n\n## Audio Codec Configuration\n\nAudio encoding uses `AudioEncoderConfig` with support for various sample rates and channel layouts:\n\n```mermaid\ngraph TB\n    subgraph \"Input Audio\"\n        IN[\"PCM Float\u003cbr/\u003e48000 Hz\u003cbr/\u003e2 channels\u003cbr/\u003eFLT format\"]\n    end\n    \n    subgraph \"Resampling Context (swrCtx_)\"\n        SWR[\"swr_convert()\u003cbr/\u003eFLT  FLTP\u003cbr/\u003e48000 Hz  codec rate\u003cbr/\u003eStereo  codec layout\"]\n    end\n    \n    subgraph \"Audio Codec Context\"\n        CTX[\"AVCodecContext\u003cbr/\u003esample_rate: 48000\u003cbr/\u003ebit_rate: 192000\u003cbr/\u003esample_fmt: FLTP\u003cbr/\u003ech_layout: stereo\"]\n    end\n    \n    subgraph \"Output\"\n        OUT[\"Encoded AAC\u003cbr/\u003ein MP4 container\"]\n    end\n    \n    IN --\u003e SWR\n    SWR --\u003e CTX\n    CTX --\u003e OUT\n```\n\n**Diagram: Audio Encoding Configuration**\n\n**Audio stream initialization** [src/recorder/VideoRecorder.cpp:444-489]():\n- **Codec:** AAC (default) or other formats supported by libavcodec\n- **Sample rate:** 48000 Hz (configurable)\n- **Bitrate:** 192 kbps (configurable, range: 64-640 kbps)\n- **Channels:** 2 (stereo), can support mono or more channels\n- **Sample format:** Automatically selected from codec's supported formats (typically FLTP)\n\nThe resampling context (`swrCtx_`) handles:\n1. Format conversion (interleaved float  planar float)\n2. Sample rate conversion (if needed)\n3. Channel layout remapping (if needed)\n\n**Sources:** [src/recorder/VideoRecorder.cpp:425-519](), [src/recorder/VideoRecorder.cpp:241-279]()\n\n---\n\n## Recording Statistics\n\n`VideoRecorder` tracks real-time statistics and emits updates via the `statsUpdated` signal:\n\n```mermaid\nclassDiagram\n    class RecordingStats {\n        +string currentFile\n        +u64 framesWritten\n        +u64 framesDropped\n        +u64 bytesWritten\n        +Duration elapsed\n        +f64 avgFps\n    }\n    \n    class VideoRecorder {\n        -RecordingStats stats_\n        +Signal statsUpdated\n        -void updateStats()\n    }\n    \n    VideoRecorder --\u003e RecordingStats : tracks\n    \n    note for RecordingStats \"Updated every second\\nin encoding thread\"\n```\n\n**Diagram: Recording Statistics Structure**\n\n| Field | Type | Description | Update Frequency |\n|-------|------|-------------|------------------|\n| `currentFile` | `string` | Output file path | On start |\n| `framesWritten` | `u64` | Successfully encoded frames | Per frame |\n| `framesDropped` | `u64` | Frames dropped due to queue overflow | Per second |\n| `bytesWritten` | `u64` | Total bytes written to file | Per packet |\n| `elapsed` | `Duration` | Recording duration in milliseconds | Per second |\n| `avgFps` | `f64` | Average encoding framerate | Per second |\n\nStatistics are calculated in the encoding thread [src/recorder/VideoRecorder.cpp:190-207]():\n```cpp\nstats_.elapsed = Duration(std::chrono::duration_cast\u003cstd::chrono::milliseconds\u003e(\n    now - std::chrono::steady_clock::time_point(std::chrono::microseconds(startTime_))\n).count());\n\nif (stats_.elapsed.count() \u003e 0) {\n    stats_.avgFps = static_cast\u003cf64\u003e(stats_.framesWritten) * 1000.0 / stats_.elapsed.count();\n}\n\nstats_.framesDropped = frameGrabber_.droppedFrames();\nstatsUpdated.emitSignal(stats_);\n```\n\n**Sources:** [src/recorder/VideoRecorder.cpp:190-207]()\n\n---\n\n## Configuration Structure\n\nRecording settings are organized hierarchically in the `Config` singleton:\n\n```mermaid\nclassDiagram\n    class RecordingConfig {\n        +bool enabled\n        +bool autoRecord\n        +fs::path outputDirectory\n        +string defaultFilename\n        +string container\n        +VideoEncoderConfig video\n        +AudioEncoderConfig audio\n    }\n    \n    class VideoEncoderConfig {\n        +string codec\n        +u32 crf\n        +string preset\n        +string pixelFormat\n        +u32 width\n        +u32 height\n        +u32 fps\n        +u32 gopSize\n        +u32 bFrames\n    }\n    \n    class AudioEncoderConfig {\n        +string codec\n        +u32 bitrate\n        +u32 sampleRate\n        +u32 channels\n    }\n    \n    RecordingConfig *-- VideoEncoderConfig\n    RecordingConfig *-- AudioEncoderConfig\n```\n\n**Diagram: Recording Configuration Structure**\n\n**Default configuration values** (from `config.toml`):\n\n**Video settings:**\n- `codec`: `\"libx264\"` (H.264)\n- `crf`: `23` (balanced quality/size)\n- `preset`: `\"ultrafast\"` (fastest encoding for real-time)\n- `pixel_format`: `\"yuv420p\"` (universal compatibility)\n- `width`: `1280` (must be even number)\n- `height`: `720` (must be even number)\n- `fps`: `30`\n\n**Audio settings:**\n- `codec`: `\"aac\"`\n- `bitrate`: `192` (kbps)\n- `sample_rate`: `48000` (Hz)\n- `channels`: `2` (stereo)\n\n**Output settings:**\n- `output_directory`: `\"~/Videos/ChadVis\"`\n- `default_filename`: `\"chadvis-projectm-qt_{date}_{time}\"`\n- `container`: `\"mp4\"` (supports mkv, webm, etc.)\n\n**Sources:** [src/core/Config.cpp:206-248](), [src/core/Config.cpp:363-383]()\n\n---\n\n## Integration with VisualizerWindow\n\n`VisualizerWindow` prepares for recording by resizing render targets and setting up PBOs:\n\n```mermaid\nsequenceDiagram\n    participant UI as RecordingControls\n    participant VW as VisualizerWindow\n    participant VR as VideoRecorder\n    participant ET as Encoding Thread\n    \n    UI-\u003e\u003eVW: setRecordingSize(w, h)\n    Note over VW: Store recordWidth_, recordHeight_\n    \n    UI-\u003e\u003eVR: start(outputPath)\n    VR-\u003e\u003eVR: initFFmpeg()\n    VR-\u003e\u003eVR: Start encoding thread\n    VR--\u003e\u003eUI: Recording state signal\n    \n    UI-\u003e\u003eVW: startRecording()\n    activate VW\n    VW-\u003e\u003eVW: recording_ = true\n    VW-\u003e\u003eVW: renderTarget_.resize(recordWidth_, recordHeight_)\n    VW-\u003e\u003eVW: overlayTarget_.resize(recordWidth_, recordHeight_)\n    VW-\u003e\u003eVW: projectM_.resize(recordWidth_, recordHeight_)\n    VW-\u003e\u003eVW: setupPBOs()\n    deactivate VW\n    \n    loop Every frame\n        VW-\u003e\u003eVW: renderFrame()\n        VW-\u003e\u003eVW: captureAsync()\n        VW-\u003e\u003eVR: frameCaptured signal\n        VR-\u003e\u003eET: Queue frame\n    end\n    \n    UI-\u003e\u003eVW: stopRecording()\n    VW-\u003e\u003eVW: recording_ = false\n    VW-\u003e\u003eVW: destroyPBOs()\n    \n    UI-\u003e\u003eVR: stop()\n    VR-\u003e\u003eET: shouldStop_ = true\n    ET-\u003e\u003eVR: Thread exits\n    VR-\u003e\u003eVR: cleanupFFmpeg()\n```\n\n**Diagram: Recording Start/Stop Sequence**\n\n**Key steps in recording preparation** [src/visualizer/VisualizerWindow.cpp:316-334]():\n\n1. **Set recording resolution:** `setRecordingSize()` stores target dimensions\n2. **Resize render targets:** FBOs are resized to match recording resolution\n3. **Resize projectM:** Ensures visualization renders at correct size\n4. **Setup PBOs:** Allocates two PBOs sized for recording resolution\n5. **Enable capture:** `recording_` flag activates frame capture path\n6. **Stop recording:** Destroys PBOs and cleans up resources\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:311-334](), [src/visualizer/VisualizerWindow.cpp:133-237]()\n\n---\n\n## Error Handling\n\nThe recording system uses `Result\u003cT\u003e` types for error propagation:\n\n```mermaid\nflowchart TD\n    START[\"start(settings)\"]\n    VALIDATE{\"settings.validate()\"}\n    INIT_FF{\"initFFmpeg()\"}\n    INIT_VID{\"initVideoStream()\"}\n    INIT_AUD{\"initAudioStream()\"}\n    \n    START --\u003e VALIDATE\n    VALIDATE --\u003e|\"Error\"| ERR1[\"Return Result::err()\"]\n    VALIDATE --\u003e|\"OK\"| INIT_FF\n    \n    INIT_FF --\u003e|\"OK\"| SUCCESS[\"state_ = Recording\u003cbr/\u003eReturn Result::ok()\"]\n    INIT_FF --\u003e|\"Error\"| CLEANUP1[\"cleanupFFmpeg()\"]\n    CLEANUP1 --\u003e ERR2[\"state_ = Error\u003cbr/\u003eReturn Result::err()\"]\n    \n    INIT_VID --\u003e|\"Error\"| ERR3[\"Return Result::err()\"]\n    INIT_AUD --\u003e|\"Error\"| ERR4[\"Return Result::err()\"]\n```\n\n**Diagram: Recording Error Handling Flow**\n\n**Common error scenarios:**\n\n| Error Type | Cause | Recovery |\n|------------|-------|----------|\n| Codec not found | Invalid codec name in config | Fall back to default (libx264/aac) |\n| File I/O error | Permission denied, disk full | User notification via `error` signal |\n| Encoding error | Invalid frame data, codec issue | Drop frame, log warning, continue |\n| Init failure | Missing FFmpeg libraries | Set `state_ = Error`, cleanup resources |\n\n**Error reporting** uses signals [src/recorder/VideoRecorder.cpp:543-558]():\n- `error.emitSignal(errorMessage)` - Emitted for critical errors\n- `LOG_WARN()` - Used for non-fatal issues (dropped frames, packet errors)\n- State transitions to `RecordingState::Error` on initialization failures\n\n**Sources:** [src/recorder/VideoRecorder.cpp:18-111](), [src/recorder/VideoRecorder.cpp:539-637]()"])</script><script>self.__next_f.push([1,"25:T4faf,"])</script><script>self.__next_f.push([1,"# VideoRecorder\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [src/core/Config.cpp](src/core/Config.cpp)\n- [src/recorder/VideoRecorder.cpp](src/recorder/VideoRecorder.cpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThe `VideoRecorder` class implements FFmpeg-based video recording for the chadvis-projectm-qt visualizer. It captures rendered visualization frames and audio playback, encoding them into video files (MP4/MKV) with configurable codecs and quality settings. The recorder operates asynchronously on a dedicated encoding thread to avoid blocking the main rendering loop.\n\nThis page documents the `VideoRecorder` class, its FFmpeg pipeline initialization, codec configuration, asynchronous encoding architecture, and integration with the configuration system. For details about frame capture using Pixel Buffer Objects, see [Frame Capture \u0026 PBOs](#5.2).\n\n**Sources:** [src/recorder/VideoRecorder.cpp:1-639]()\n\n---\n\n## Class Architecture\n\nThe `VideoRecorder` class manages the complete recording pipeline from frame submission to file output. It uses FFmpeg libraries (libavcodec, libavformat, libswscale, libswresample) for encoding and muxing.\n\n### Component Diagram\n\n```mermaid\ngraph TB\n    subgraph \"VideoRecorder Class\"\n        VR[\"VideoRecorder\"]\n        \n        subgraph \"State Management\"\n            STATE[\"state_\u003cbr/\u003eRecordingState\"]\n            STATS[\"stats_\u003cbr/\u003eRecordingStats\"]\n            SETTINGS[\"settings_\u003cbr/\u003eEncoderSettings\"]\n        end\n        \n        subgraph \"FFmpeg Context (ffmpegMutex_)\"\n            FORMAT_CTX[\"formatCtx_\u003cbr/\u003eAVFormatContext*\"]\n            VIDEO_CTX[\"videoCodecCtx_\u003cbr/\u003eAVCodecContext*\"]\n            AUDIO_CTX[\"audioCodecCtx_\u003cbr/\u003eAVCodecContext*\"]\n            VIDEO_STREAM[\"videoStream_\u003cbr/\u003eAVStream*\"]\n            AUDIO_STREAM[\"audioStream_\u003cbr/\u003eAVStream*\"]\n            PACKET[\"packet_\u003cbr/\u003eAVPacket*\"]\n        end\n        \n        subgraph \"Conversion Contexts\"\n            SWS_CTX[\"swsCtx_\u003cbr/\u003eSwsContext*\u003cbr/\u003e(RGBA  YUV420P)\"]\n            SWR_CTX[\"swrCtx_\u003cbr/\u003eSwrContext*\u003cbr/\u003e(f32  codec format)\"]\n            VIDEO_FRAME[\"videoFrame_\u003cbr/\u003eAVFrame*\"]\n            AUDIO_FRAME[\"audioFrame_\u003cbr/\u003eAVFrame*\"]\n        end\n        \n        subgraph \"Frame Queue (audioMutex_)\"\n            FRAME_GRABBER[\"frameGrabber_\u003cbr/\u003eFrameGrabber\"]\n            AUDIO_BUF[\"audioBuffer_\u003cbr/\u003evector\u003cf32\u003e\"]\n        end\n        \n        subgraph \"Encoding Thread\"\n            THREAD[\"encodingThread_\u003cbr/\u003estd::thread\"]\n            SHOULD_STOP[\"shouldStop_\u003cbr/\u003eatomic\u003cbool\u003e\"]\n        end\n    end\n    \n    VR --\u003e STATE\n    VR --\u003e STATS\n    VR --\u003e SETTINGS\n    VR --\u003e FORMAT_CTX\n    VR --\u003e VIDEO_CTX\n    VR --\u003e AUDIO_CTX\n    VR --\u003e VIDEO_STREAM\n    VR --\u003e AUDIO_STREAM\n    VR --\u003e PACKET\n    VR --\u003e SWS_CTX\n    VR --\u003e SWR_CTX\n    VR --\u003e VIDEO_FRAME\n    VR --\u003e AUDIO_FRAME\n    VR --\u003e FRAME_GRABBER\n    VR --\u003e AUDIO_BUF\n    VR --\u003e THREAD\n    VR --\u003e SHOULD_STOP\n    \n    FORMAT_CTX -.-\u003e VIDEO_STREAM\n    FORMAT_CTX -.-\u003e AUDIO_STREAM\n    VIDEO_CTX -.-\u003e VIDEO_FRAME\n    AUDIO_CTX -.-\u003e AUDIO_FRAME\n```\n\n**Sources:** [src/recorder/VideoRecorder.cpp:1-639]()\n\n---\n\n## State Machine and Lifecycle\n\nThe recorder operates as a state machine with five states managed by the `RecordingState` enum.\n\n### Recording State Transitions\n\n```mermaid\nstateDiagram-v2\n    [*] --\u003e Stopped\n    \n    Stopped --\u003e Starting: start()\n    Starting --\u003e Recording: initFFmpeg() success\n    Starting --\u003e Error: initFFmpeg() failure\n    \n    Recording --\u003e Stopping: stop()\n    Stopping --\u003e Stopped: cleanup complete\n    \n    Error --\u003e Stopped: reset\n    \n    note right of Starting\n        - Validate settings\n        - Initialize FFmpeg contexts\n        - Create output file\n        - Start encoding thread\n    end note\n    \n    note right of Recording\n        - submitVideoFrame() active\n        - submitAudioSamples() active\n        - Encoding thread processing\n    end note\n    \n    note right of Stopping\n        - Signal thread to stop\n        - Join encoding thread\n        - flushEncoders()\n        - av_write_trailer()\n    end note\n```\n\n### Lifecycle Methods\n\n| Method | State Transition | Key Operations |\n|--------|------------------|----------------|\n| `start(EncoderSettings)` | Stopped  Starting  Recording | [VideoRecorder.cpp:18-65]() |\n| `stop()` | Recording  Stopping  Stopped | [VideoRecorder.cpp:73-111]() |\n| `cleanupFFmpeg()` | Any  Stopped | [VideoRecorder.cpp:521-537]() |\n\n**Sources:** [src/recorder/VideoRecorder.cpp:18-111](), [src/recorder/VideoRecorder.cpp:521-537]()\n\n---\n\n## FFmpeg Pipeline Initialization\n\nThe initialization process creates FFmpeg contexts in a specific order to ensure proper muxing.\n\n### Initialization Sequence\n\n```mermaid\nsequenceDiagram\n    participant Client\n    participant VR as VideoRecorder\n    participant FFmpeg as FFmpeg API\n    participant FileSystem\n    \n    Client-\u003e\u003eVR: start(EncoderSettings)\n    VR-\u003e\u003eVR: validate settings\n    VR-\u003e\u003eFileSystem: ensureDir(outputPath)\n    \n    VR-\u003e\u003eFFmpeg: avformat_alloc_output_context2()\n    FFmpeg--\u003e\u003eVR: formatCtx_\n    \n    VR-\u003e\u003eVR: initVideoStream()\n    VR-\u003e\u003eFFmpeg: avcodec_find_encoder_by_name()\n    VR-\u003e\u003eFFmpeg: avformat_new_stream()\n    VR-\u003e\u003eFFmpeg: avcodec_alloc_context3()\n    VR-\u003e\u003eFFmpeg: avcodec_open2(opts: preset, crf, tune)\n    VR-\u003e\u003eFFmpeg: sws_getContext(RGBAYUV420P)\n    \n    VR-\u003e\u003eVR: initAudioStream()\n    VR-\u003e\u003eFFmpeg: avcodec_find_encoder_by_name()\n    VR-\u003e\u003eFFmpeg: avformat_new_stream()\n    VR-\u003e\u003eFFmpeg: avcodec_alloc_context3()\n    VR-\u003e\u003eFFmpeg: avcodec_open2()\n    VR-\u003e\u003eFFmpeg: swr_alloc_set_opts2(f32codec format)\n    \n    VR-\u003e\u003eFFmpeg: avio_open(outputPath, WRITE)\n    VR-\u003e\u003eFFmpeg: avformat_write_header()\n    \n    VR-\u003e\u003eVR: Start encodingThread_\n    VR--\u003e\u003eClient: Result\u003cvoid\u003e::ok()\n```\n\n### Video Stream Initialization\n\nThe `initVideoStream()` method configures the video encoder with codec-specific options.\n\n**Key Configuration Steps:**\n\n1. **Codec Selection** [VideoRecorder.cpp:329-334]()\n   - Uses `settings_.video.codecName()` (e.g., \"libx264\", \"libx265\")\n   - Falls back to error if codec not found\n\n2. **Codec Context Setup** [VideoRecorder.cpp:346-357]()\n   ```\n   videoCodecCtx_-\u003ewidth = settings_.video.width\n   videoCodecCtx_-\u003eheight = settings_.video.height\n   videoCodecCtx_-\u003etime_base = {1, fps}\n   videoCodecCtx_-\u003epix_fmt = AV_PIX_FMT_YUV420P\n   videoCodecCtx_-\u003egop_size = fps * 2 (default)\n   videoCodecCtx_-\u003emax_b_frames = settings_.video.bFrames\n   ```\n\n3. **H.264/H.265 Options** [VideoRecorder.cpp:362-369]()\n   - `preset`: ultrafast, veryfast, etc. (encoding speed vs compression)\n   - `crf`: 0-51 (quality, lower = better, 23 is default)\n   - `tune`: zerolatency (for real-time encoding)\n\n4. **SwScale Context** [VideoRecorder.cpp:401-414]()\n   - Converts RGBA (from OpenGL) to YUV420P (for H.264)\n   - Uses `SWS_BILINEAR` scaling algorithm\n\n**Sources:** [src/recorder/VideoRecorder.cpp:328-423]()\n\n### Audio Stream Initialization\n\nThe `initAudioStream()` method configures the audio encoder with channel layout and sample format conversion.\n\n**Key Configuration Steps:**\n\n1. **Codec Selection** [VideoRecorder.cpp:426-432]()\n   - Uses `settings_.audio.codecName()` (e.g., \"aac\", \"libmp3lame\")\n   - Logs warning and continues without audio if codec not found\n\n2. **Codec Context Setup** [VideoRecorder.cpp:444-454]()\n   ```\n   audioCodecCtx_-\u003esample_rate = settings_.audio.sampleRate (44100 Hz)\n   audioCodecCtx_-\u003ebit_rate = settings_.audio.bitrate * 1000\n   audioCodecCtx_-\u003esample_fmt = codec-\u003esample_fmts[0] (usually AV_SAMPLE_FMT_FLTP)\n   av_channel_layout_default(\u0026layout, settings_.audio.channels)\n   ```\n\n3. **SwResample Context** [VideoRecorder.cpp:491-511]()\n   - Converts float32 PCM (from AudioEngine) to codec format (e.g., FLTP for AAC)\n   - Handles sample rate conversion if needed\n   - Configured with `swr_alloc_set_opts2()` and initialized with `swr_init()`\n\n**Sources:** [src/recorder/VideoRecorder.cpp:425-519]()\n\n---\n\n## Encoding Thread Architecture\n\nThe encoding thread runs asynchronously to avoid blocking the render loop. It processes video frames and audio samples, encodes them, and writes packets to the output file.\n\n### Thread Execution Flow\n\n```mermaid\nflowchart TD\n    START[\"encodingThread() starts\"]\n    \n    WAIT[\"Wait for next frame\u003cbr/\u003eframeGrabber_.getNextFrame(timeout=10ms)\"]\n    \n    HAS_VIDEO{\"hasVideo?\"}\n    PROCESS_VIDEO[\"processVideoFrame(frame)\u003cbr/\u003e- sws_scale(RGBAYUV420P)\u003cbr/\u003e- encodeVideoFrame()\u003cbr/\u003e- writePacket()\"]\n    \n    PROCESS_AUDIO[\"processAudioBuffer()\u003cbr/\u003e- swr_convert(f32codec fmt)\u003cbr/\u003e- encodeAudioFrame()\u003cbr/\u003e- writePacket()\"]\n    \n    CHECK_STOP{\"shouldStop_ \u0026\u0026\u003cbr/\u003eno frames?\"}\n    \n    UPDATE_STATS[\"Update stats every 1s\u003cbr/\u003e- elapsed time\u003cbr/\u003e- avgFps\u003cbr/\u003e- framesDropped\u003cbr/\u003eemit statsUpdated\"]\n    \n    END[\"Thread exits\u003cbr/\u003eflushEncoders() called by stop()\"]\n    \n    START --\u003e WAIT\n    WAIT --\u003e HAS_VIDEO\n    HAS_VIDEO --\u003e|yes| PROCESS_VIDEO\n    HAS_VIDEO --\u003e|no| PROCESS_AUDIO\n    PROCESS_VIDEO --\u003e PROCESS_AUDIO\n    PROCESS_AUDIO --\u003e CHECK_STOP\n    CHECK_STOP --\u003e|yes| END\n    CHECK_STOP --\u003e|no| UPDATE_STATS\n    UPDATE_STATS --\u003e WAIT\n```\n\n**Thread Safety:**\n- `ffmpegMutex_` protects all FFmpeg context access during encoding\n- `audioMutex_` protects `audioBuffer_` during `submitAudioSamples()` and `processAudioBuffer()`\n- `shouldStop_` is an atomic flag for thread coordination\n\n**Sources:** [src/recorder/VideoRecorder.cpp:172-211]()\n\n---\n\n## Video Frame Processing\n\nVideo frames are submitted from the render thread and processed asynchronously by the encoding thread.\n\n### Frame Submission Path\n\n```mermaid\ngraph LR\n    VW[\"VisualizerWindow\u003cbr/\u003e(render thread)\"]\n    SUBMIT[\"submitVideoFrame()\u003cbr/\u003e(2 overloads)\"]\n    GRABBED[\"GrabbedFrame\u003cbr/\u003estruct\"]\n    QUEUE[\"FrameGrabber\u003cbr/\u003equeue\"]\n    ENCODING[\"encodingThread_\u003cbr/\u003e(background)\"]\n    \n    VW --\u003e|\"data, width, height, timestamp\"| SUBMIT\n    SUBMIT --\u003e|\"construct GrabbedFrame\"| GRABBED\n    GRABBED --\u003e|\"std::move()\"| QUEUE\n    QUEUE --\u003e|\"getNextFrame()\"| ENCODING\n```\n\n### Frame Processing Implementation\n\n**Submission Methods** [VideoRecorder.cpp:113-148]():\n\n| Method | Signature | Data Handling |\n|--------|-----------|---------------|\n| `submitVideoFrame(std::vector\u003cu8\u003e\u0026\u0026, ...)` | Move semantics | Zero-copy transfer |\n| `submitVideoFrame(const u8*, ...)` | Pointer + size | Copies data into vector |\n\n**Processing Pipeline** [VideoRecorder.cpp:213-239]():\n\n1. **Retrieve Frame** from `FrameGrabber` queue\n2. **Color Conversion** using `sws_scale()`:\n   ```\n   Source: RGBA (4 bytes/pixel, from OpenGL)\n   Destination: YUV420P (1.5 bytes/pixel, for H.264)\n   Algorithm: SWS_BILINEAR\n   ```\n3. **Set PTS** (Presentation Timestamp):\n   ```cpp\n   videoFrame_-\u003epts = videoFrameCount_++;\n   ```\n4. **Encode Frame** via `encodeVideoFrame()`\n5. **Update Stats**: `++stats_.framesWritten`\n\n**Sources:** [src/recorder/VideoRecorder.cpp:113-148](), [src/recorder/VideoRecorder.cpp:213-239]()\n\n---\n\n## Audio Sample Processing\n\nAudio samples are buffered and processed in frame-sized chunks required by the codec.\n\n### Audio Processing Flow\n\n```mermaid\nflowchart TD\n    AE[\"AudioEngine\u003cbr/\u003e(audio callback thread)\"]\n    \n    SUBMIT[\"submitAudioSamples()\u003cbr/\u003e(f32* data, samples, channels, sampleRate)\"]\n    \n    BUFFER[\"audioBuffer_\u003cbr/\u003evector\u003cf32\u003e\u003cbr/\u003e(protected by audioMutex_)\"]\n    \n    CHECK{\"buffer.size() \u003e=\u003cbr/\u003eframeSize * channels?\"}\n    \n    EXTRACT[\"Extract frameSize*channels samples\u003cbr/\u003eerase from buffer front\"]\n    \n    CONVERT[\"swr_convert()\u003cbr/\u003e(f32  codec sample_fmt)\"]\n    \n    ENCODE[\"encodeAudioFrame()\u003cbr/\u003eaudioFrame_-\u003epts = audioFrameCount_\u003cbr/\u003eaudioFrameCount_ += frameSize\"]\n    \n    WRITE[\"writePacket(audioStream_)\"]\n    \n    AE --\u003e|\"lock audioMutex_\"| SUBMIT\n    SUBMIT --\u003e|\"append samples\"| BUFFER\n    \n    BUFFER --\u003e CHECK\n    CHECK --\u003e|yes| EXTRACT\n    CHECK --\u003e|no| RETURN[\"Return (wait for more)\"]\n    \n    EXTRACT --\u003e CONVERT\n    CONVERT --\u003e ENCODE\n    ENCODE --\u003e WRITE\n    WRITE --\u003e CHECK\n```\n\n### Implementation Details\n\n**Audio Buffering** [VideoRecorder.cpp:150-170]():\n- Samples arrive asynchronously from `AudioEngine`\n- Stored as float32 PCM in `audioBuffer_`\n- Thread-safe via `audioMutex_`\n\n**Frame-based Processing** [VideoRecorder.cpp:241-279]():\n- Most codecs (e.g., AAC) require fixed-size frames\n- `audioCodecCtx_-\u003eframe_size` determines frame size (typically 1024 samples for AAC)\n- Loop continues until insufficient samples remain\n\n**Sample Format Conversion**:\n```cpp\nswr_convert(swrCtx_.get(),\n            audioFrame_-\u003edata,      // destination (codec format, e.g., FLTP)\n            frameSize,\n            srcData,                // source (float32 PCM)\n            frameSize);\n```\n\n**Sources:** [src/recorder/VideoRecorder.cpp:150-170](), [src/recorder/VideoRecorder.cpp:241-279]()\n\n---\n\n## Configuration Integration\n\nRecording settings are loaded from the TOML configuration file and mapped to `EncoderSettings`.\n\n### Configuration Structure\n\n```mermaid\nclassDiagram\n    class RecordingConfig {\n        +bool enabled\n        +bool autoRecord\n        +fs::path outputDirectory\n        +string defaultFilename\n        +string container\n        +VideoEncoderConfig video\n        +AudioEncoderConfig audio\n    }\n    \n    class VideoEncoderConfig {\n        +VideoCodec codec\n        +u32 width\n        +u32 height\n        +u32 fps\n        +u32 crf\n        +string preset\n        +string pixelFormat\n        +u32 gopSize\n        +u32 bFrames\n        +string codecName()\n        +string presetName()\n    }\n    \n    class AudioEncoderConfig {\n        +AudioCodec codec\n        +u32 sampleRate\n        +u32 channels\n        +u32 bitrate\n        +string codecName()\n    }\n    \n    class EncoderSettings {\n        +fs::path outputPath\n        +VideoEncoderConfig video\n        +AudioEncoderConfig audio\n        +static fromConfig() EncoderSettings\n        +validate() Result~void~\n    }\n    \n    RecordingConfig *-- VideoEncoderConfig\n    RecordingConfig *-- AudioEncoderConfig\n    EncoderSettings *-- VideoEncoderConfig\n    EncoderSettings *-- AudioEncoderConfig\n```\n\n### TOML Configuration Format\n\nThe configuration is loaded by `parseRecording()` in the `Config` class.\n\n**Example Configuration** [Config.cpp:206-248]():\n```toml\n[recording]\nenabled = true\nauto_record = false\noutput_directory = \"~/Videos/ChadVis\"\ndefault_filename = \"chadvis-projectm-qt_{date}_{time}\"\ncontainer = \"mp4\"\n\n[recording.video]\ncodec = \"libx264\"\ncrf = 23\npreset = \"ultrafast\"\npixel_format = \"yuv420p\"\nwidth = 1280\nheight = 720\nfps = 30\n\n[recording.audio]\ncodec = \"aac\"\nbitrate = 192\n```\n\n### Configuration Validation\n\nThe `EncoderSettings::validate()` method ensures settings are within acceptable ranges:\n\n- **Video dimensions**: Must be even numbers (H.264 requirement)\n- **FPS**: Clamped to 10-120 range\n- **CRF**: Clamped to 0-51 (H.264/H.265)\n- **Bitrate**: Clamped to 64-640 kbps\n- **Output path**: Must have write permissions\n\n**Sources:** [src/core/Config.cpp:206-248]()\n\n---\n\n## Encoding and Packet Writing\n\nThe encoding process follows FFmpeg's asynchronous encoding API, introduced in FFmpeg 3.x.\n\n### Encoding Flow Diagram\n\n```mermaid\nsequenceDiagram\n    participant Thread as Encoding Thread\n    participant Codec as AVCodecContext\n    participant Format as AVFormatContext\n    participant File as Output File\n    \n    Thread-\u003e\u003eCodec: avcodec_send_frame(frame)\n    \n    loop While packets available\n        Thread-\u003e\u003eCodec: avcodec_receive_packet(packet)\n        Codec--\u003e\u003eThread: packet or EAGAIN\n        \n        alt Got packet\n            Thread-\u003e\u003eThread: av_packet_rescale_ts()\u003cbr/\u003e(codec timebase  stream timebase)\n            Thread-\u003e\u003eThread: set packet-\u003estream_index\n            Thread-\u003e\u003eFormat: av_interleaved_write_frame(packet)\n            Format-\u003e\u003eFile: Write muxed packet\n            Thread-\u003e\u003eThread: stats_.bytesWritten += packet-\u003esize\n        else EAGAIN or EOF\n            Note over Thread,Codec: Break loop, need more frames\n        end\n    end\n```\n\n### Encode Methods\n\n**Video Encoding** [VideoRecorder.cpp:539-567]():\n```cpp\nbool encodeVideoFrame(AVFrame* frame) {\n    avcodec_send_frame(videoCodecCtx_.get(), frame);\n    \n    while (ret \u003e= 0) {\n        ret = avcodec_receive_packet(videoCodecCtx_.get(), packet_.get());\n        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)\n            break;\n        \n        writePacket(packet_.get(), videoStream_);\n    }\n    return true;\n}\n```\n\n**Audio Encoding** [VideoRecorder.cpp:569-597]():\n- Identical structure to video encoding\n- Uses `audioCodecCtx_` and `audioStream_`\n\n**Packet Writing** [VideoRecorder.cpp:599-615]():\n- Rescales packet timestamps from codec timebase to stream timebase\n- Writes interleaved packets (maintains A/V sync)\n- Updates `stats_.bytesWritten`\n\n### Encoder Flushing\n\nWhen recording stops, remaining frames must be flushed from codec buffers.\n\n**Flush Implementation** [VideoRecorder.cpp:617-637]():\n```cpp\nvoid flushEncoders() {\n    // Send NULL frame to signal end of stream\n    avcodec_send_frame(videoCodecCtx_.get(), nullptr);\n    \n    // Receive all remaining packets\n    while (avcodec_receive_packet(videoCodecCtx_.get(), packet_.get()) \u003e= 0) {\n        writePacket(packet_.get(), videoStream_);\n    }\n    \n    // Repeat for audio\n    avcodec_send_frame(audioCodecCtx_.get(), nullptr);\n    while (avcodec_receive_packet(audioCodecCtx_.get(), packet_.get()) \u003e= 0) {\n        writePacket(packet_.get(), audioStream_);\n    }\n}\n```\n\n**Sources:** [src/recorder/VideoRecorder.cpp:539-637]()\n\n---\n\n## Error Handling and Statistics\n\nThe recorder provides robust error handling and real-time statistics via signal emission.\n\n### Signal Emission System\n\n| Signal | Type | Emitted When |\n|--------|------|--------------|\n| `stateChanged` | `Signal\u003cRecordingState\u003e` | State transitions |\n| `statsUpdated` | `Signal\u003cRecordingStats\u003e` | Every second during recording |\n| `error` | `Signal\u003cstd::string\u003e` | Encoding errors, write failures |\n\n### RecordingStats Structure\n\n```cpp\nstruct RecordingStats {\n    u64 framesWritten;      // Total frames encoded\n    u64 framesDropped;      // Frames dropped by FrameGrabber\n    u64 bytesWritten;       // Total file size in bytes\n    Duration elapsed;       // Recording duration\n    f64 avgFps;            // Average encoding FPS\n    std::string currentFile; // Output file path\n};\n```\n\n**Stats Update Logic** [VideoRecorder.cpp:190-207]():\n- Updated every 1 second in encoding thread\n- `avgFps` calculated as: `framesWritten * 1000 / elapsed.count()`\n- `framesDropped` retrieved from `FrameGrabber`\n\n### Error Handling Patterns\n\n**Initialization Errors** [VideoRecorder.cpp:18-65]():\n```cpp\nif (auto result = initFFmpeg(); !result) {\n    cleanupFFmpeg();\n    state_ = RecordingState::Error;\n    stateChanged.emitSignal(state_);\n    return result;  // Return Result\u003cvoid\u003e::err()\n}\n```\n\n**Encoding Errors** [VideoRecorder.cpp:541-558]():\n```cpp\nint ret = avcodec_send_frame(videoCodecCtx_.get(), frame);\nif (ret \u003c 0) {\n    std::string errMsg = \"Error sending video frame: \" + ffmpegError(ret);\n    LOG_WARN(\"{}\", errMsg);\n    error.emitSignal(errMsg);\n    return false;\n}\n```\n\n**Cleanup on Stop** [VideoRecorder.cpp:73-111]():\n- Sets `state_ = RecordingState::Stopping`\n- Signals thread to stop via `shouldStop_ = true`\n- Waits for thread join\n- Flushes encoders and writes trailer\n- Calls `cleanupFFmpeg()` to release resources\n\n**Sources:** [src/recorder/VideoRecorder.cpp:18-111](), [src/recorder/VideoRecorder.cpp:172-211](), [src/recorder/VideoRecorder.cpp:539-637]()\n\n---\n\n## Integration with Application\n\nThe `VideoRecorder` is owned by the `Application` singleton and controlled through the `RecordingController`.\n\n### Ownership and Access Pattern\n\n```mermaid\ngraph TB\n    APP[\"Application\u003cbr/\u003e(singleton)\"]\n    VR[\"VideoRecorder\u003cbr/\u003e(owned)\"]\n    RC[\"RecordingController\u003cbr/\u003e(non-owning ptr)\"]\n    RW[\"RecordingControls\u003cbr/\u003e(UI widget)\"]\n    VW[\"VisualizerWindow\u003cbr/\u003e(non-owning ptr)\"]\n    AE[\"AudioEngine\u003cbr/\u003e(non-owning ptr)\"]\n    \n    APP --\u003e|owns| VR\n    APP --\u003e|provides ptr| RC\n    RC --\u003e|controls| VR\n    RC --\u003e|connects signals| RW\n    \n    VW --\u003e|\"submitVideoFrame()\"| VR\n    AE --\u003e|\"submitAudioSamples()\"| VR\n    \n    VR -.-\u003e|\"stateChanged signal\"| RC\n    VR -.-\u003e|\"statsUpdated signal\"| RC\n    VR -.-\u003e|\"error signal\"| RC\n```\n\n**Sources:** Based on architectural patterns from Diagram 1 and Diagram 3 in the high-level system overview."])</script><script>self.__next_f.push([1,"26:T3bfc,"])</script><script>self.__next_f.push([1,"# Frame Capture \u0026 PBOs\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [src/core/Config.cpp](src/core/Config.cpp)\n- [src/recorder/VideoRecorder.cpp](src/recorder/VideoRecorder.cpp)\n- [src/visualizer/VisualizerWindow.cpp](src/visualizer/VisualizerWindow.cpp)\n- [src/visualizer/VisualizerWindow.hpp](src/visualizer/VisualizerWindow.hpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose \u0026 Scope\n\nThis page documents the asynchronous frame capture mechanism used in the recording system, specifically the implementation of double-buffered Pixel Buffer Objects (PBOs) for zero-copy GPU-to-CPU frame transfer. This covers the OpenGL capture pipeline in `VisualizerWindow`, frame data handling, and integration with the encoding thread.\n\nFor information about the overall recording architecture and FFmpeg encoding pipeline, see [VideoRecorder](#5.1). For visualization rendering details, see [VisualizerWindow](#4.1).\n\n**Sources:** [src/visualizer/VisualizerWindow.hpp:1-125](), [src/visualizer/VisualizerWindow.cpp:1-426]()\n\n---\n\n## Overview\n\nThe frame capture system uses OpenGL Pixel Buffer Objects (PBOs) to achieve asynchronous, non-blocking transfer of rendered frames from GPU memory to CPU memory. This approach is critical for maintaining high frame rates during recording by eliminating GPU-CPU synchronization stalls.\n\n### Key Design Principles\n\n| Principle | Implementation | Benefit |\n|-----------|----------------|---------|\n| **Double Buffering** | Two PBOs alternate roles each frame | GPU writes to one PBO while CPU reads from the other |\n| **Asynchronous Transfer** | `glReadPixels` with PBO writes immediately, `glMapBuffer` reads later | No GPU pipeline stalls |\n| **Zero-Copy Semantics** | Move semantics for frame data (`std::move`) | Eliminates memory copies in signal emission |\n| **Frame Queue** | `FrameGrabber` manages bounded queue | Decouples rendering thread from encoding thread |\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:239-288]()\n\n---\n\n## Double-Buffered PBO Architecture\n\nThe system maintains two PBOs that alternate between **write** and **read** states each frame:\n\n```mermaid\ngraph LR\n    subgraph \"Frame N\"\n        GPU_N[\"GPU renders to FBO\"]\n        PBO_A_N[\"PBO[0] (write)\u003cbr/\u003eglReadPixels target\"]\n        PBO_B_N[\"PBO[1] (read)\u003cbr/\u003eglMapBuffer source\"]\n        CPU_N[\"CPU processes\u003cbr/\u003eframe N-1\"]\n    end\n    \n    subgraph \"Frame N+1\"\n        GPU_N1[\"GPU renders to FBO\"]\n        PBO_A_N1[\"PBO[0] (read)\u003cbr/\u003eglMapBuffer source\"]\n        PBO_B_N1[\"PBO[1] (write)\u003cbr/\u003eglReadPixels target\"]\n        CPU_N1[\"CPU processes\u003cbr/\u003eframe N\"]\n    end\n    \n    GPU_N --\u003e PBO_A_N\n    PBO_B_N --\u003e CPU_N\n    \n    GPU_N1 --\u003e PBO_B_N1\n    PBO_A_N1 --\u003e CPU_N1\n    \n    PBO_A_N -.-\u003e|\"swap index\"| PBO_A_N1\n    PBO_B_N -.-\u003e|\"swap index\"| PBO_B_N1\n```\n\n**PBO State Machine:**\n\n```mermaid\nstateDiagram-v2\n    [*] --\u003e Uninitialized\n    Uninitialized --\u003e Allocated: setupPBOs()\n    Allocated --\u003e PBO_A_Write: First frame\n    \n    state \"Double Buffer Cycle\" as cycle {\n        PBO_A_Write --\u003e PBO_B_Read: captureAsync()\n        PBO_B_Read --\u003e PBO_B_Write: next frame\n        PBO_B_Write --\u003e PBO_A_Read: captureAsync()\n        PBO_A_Read --\u003e PBO_A_Write: next frame\n    }\n    \n    cycle --\u003e Destroyed: destroyPBOs()\n    Destroyed --\u003e [*]\n```\n\n### Member Variables\n\nThe PBO state is tracked by three member variables in `VisualizerWindow`:\n\n```cpp\nGLuint pbos_[2]{0, 0};        // OpenGL buffer objects\nu32 pboIndex_{0};              // Current write index (0 or 1)\nbool pboAvailable_{false};     // True after first frame captured\n```\n\n**Sources:** [src/visualizer/VisualizerWindow.hpp:103-106]()\n\n---\n\n## Frame Capture Pipeline\n\nThe complete pipeline from rendering to encoded video involves multiple stages across threads:\n\n```mermaid\nsequenceDiagram\n    participant RT as \"Render Thread\u003cbr/\u003e(VisualizerWindow)\"\n    participant GL as \"OpenGL Context\"\n    participant PBO as \"PBO[pboIndex]\"\n    participant SIG as \"Qt Signal\"\n    participant FG as \"FrameGrabber\u003cbr/\u003e(Queue)\"\n    participant ET as \"Encoding Thread\u003cbr/\u003e(VideoRecorder)\"\n    \n    RT-\u003e\u003eGL: renderFrame()\n    GL-\u003e\u003ePBO: glReadPixels(PBO[i], NULL)\n    Note over PBO: Async GPUPBO transfer starts\n    \n    RT-\u003e\u003ePBO: glMapBuffer(PBO[1-i], READ_ONLY)\n    PBO-\u003e\u003eRT: u8* ptr (previous frame)\n    RT-\u003e\u003eRT: std::vector\u003cu8\u003e buffer(ptr, ptr+size)\n    RT-\u003e\u003ePBO: glUnmapBuffer()\n    \n    RT-\u003e\u003eSIG: emit frameCaptured(std::move(buffer), ...)\n    SIG-\u003e\u003eFG: pushFrame(GrabbedFrame)\n    \n    Note over RT: pboIndex = (pboIndex + 1) % 2\n    Note over RT: pboAvailable = true\n    \n    loop Encoding Thread\n        FG-\u003e\u003eET: getNextFrame(frame, timeout_ms)\n        ET-\u003e\u003eET: sws_scale(RGBAYUV420P)\n        ET-\u003e\u003eET: avcodec_send_frame()\n    end\n```\n\n### Rendering Path with Recording\n\nWhen recording is active, the rendering path includes overlay composition and frame capture:\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:186-207]()\n\n```mermaid\ngraph TB\n    START[\"renderFrame() called\"]\n    \n    CHECK_REC{\"recording_ == true?\"}\n    START --\u003e CHECK_REC\n    \n    CHECK_REC --\u003e|No| SCREEN[\"Render directly to screen\"]\n    \n    CHECK_REC --\u003e|Yes| OVERLAY_CHECK{\"overlayEngine_\u003cbr/\u003eexists?\"}\n    \n    OVERLAY_CHECK --\u003e|Yes| OVERLAY_PATH[\"1. renderTarget_.bind()\u003cbr/\u003e2. projectM_.renderToTarget()\u003cbr/\u003e3. overlayTarget_.bind()\u003cbr/\u003e4. renderTarget_.blitTo(overlayTarget_)\u003cbr/\u003e5. overlayEngine_-\u003erender()\"]\n    \n    OVERLAY_CHECK --\u003e|No| DIRECT_PATH[\"1. renderTarget_.bind()\u003cbr/\u003e2. projectM_.renderToTarget()\"]\n    \n    OVERLAY_PATH --\u003e CAPTURE[\"captureAsync()\"]\n    DIRECT_PATH --\u003e CAPTURE\n    \n    CAPTURE --\u003e SIGNAL[\"emit frameCaptured()\"]\n    SIGNAL --\u003e UNBIND[\"overlayTarget_.unbind()\"]\n    \n    UNBIND --\u003e BLIT[\"renderTarget_.blitToScreen()\"]\n    SCREEN --\u003e END[\"Frame complete\"]\n    BLIT --\u003e END\n```\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:168-237]()\n\n---\n\n## PBO Lifecycle\n\n### Setup Phase\n\nPBOs are created when recording starts. Each PBO is allocated with size equal to `recordWidth_ * recordHeight_ * 4` (RGBA, 1 byte per channel):\n\n```cpp\nvoid VisualizerWindow::setupPBOs() {\n    this-\u003edestroyPBOs();\n    glGenBuffers(2, pbos_);\n    u32 size = recordWidth_ * recordHeight_ * 4;\n    for (int i = 0; i \u003c 2; ++i) {\n        glBindBuffer(GL_PIXEL_PACK_BUFFER, pbos_[i]);\n        glBufferData(GL_PIXEL_PACK_BUFFER, size, nullptr, GL_STREAM_READ);\n    }\n    glBindBuffer(GL_PIXEL_PACK_BUFFER, 0);\n    pboIndex_ = 0;\n    pboAvailable_ = false;\n}\n```\n\n**Usage Hint:** `GL_STREAM_READ` indicates the buffer will be written by the GPU (via `glReadPixels`) and read once by the CPU (via `glMapBuffer`).\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:239-250]()\n\n### Capture Phase\n\nThe `captureAsync()` method implements the core double-buffering logic:\n\n**Algorithm:**\n1. **Write to current PBO:** Call `glReadPixels` with `pbos_[pboIndex_]` bound as `GL_PIXEL_PACK_BUFFER`. The pixel pointer is `nullptr` because data writes to the bound PBO, not CPU memory.\n2. **Read from previous PBO:** If `pboAvailable_` (i.e., not first frame), bind `pbos_[nextIndex]` and call `glMapBuffer` to get a CPU-accessible pointer.\n3. **Copy to vector:** Copy data from mapped pointer to `std::vector\u003cu8\u003e`, which owns the memory.\n4. **Emit signal:** Emit `frameCaptured` signal with moved vector (zero-copy).\n5. **Swap indices:** Update `pboIndex_` to `nextIndex`.\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:258-288]()\n\n```mermaid\nflowchart TD\n    START[\"captureAsync() called\"]\n    \n    CALC[\"nextIndex = (pboIndex_ + 1) % 2\u003cbr/\u003esize = recordWidth_ * recordHeight_ * 4\"]\n    START --\u003e CALC\n    \n    BIND_WRITE[\"glBindBuffer(GL_PIXEL_PACK_BUFFER, pbos_[pboIndex_])\"]\n    CALC --\u003e BIND_WRITE\n    \n    READ_PIX[\"glReadPixels(0, 0, w, h, GL_RGBA, GL_UNSIGNED_BYTE, NULL)\"]\n    BIND_WRITE --\u003e READ_PIX\n    \n    NOTE1[\"Note: GPU writes to pbos_[pboIndex_] asynchronously\"]\n    READ_PIX --\u003e NOTE1\n    \n    AVAIL{\"pboAvailable_?\"}\n    NOTE1 --\u003e AVAIL\n    \n    AVAIL --\u003e|No| SKIP[\"Skip read (first frame)\"]\n    \n    AVAIL --\u003e|Yes| BIND_READ[\"glBindBuffer(GL_PIXEL_PACK_BUFFER, pbos_[nextIndex])\"]\n    \n    BIND_READ --\u003e MAP[\"u8* ptr = glMapBuffer(GL_READ_ONLY)\"]\n    \n    MAP --\u003e CHECK_PTR{\"ptr != NULL?\"}\n    \n    CHECK_PTR --\u003e|No| SKIP\n    \n    CHECK_PTR --\u003e|Yes| COPY[\"std::vector\u003cu8\u003e buffer(ptr, ptr + size)\"]\n    \n    COPY --\u003e UNMAP[\"glUnmapBuffer()\"]\n    \n    UNMAP --\u003e EMIT[\"emit frameCaptured(std::move(buffer), w, h, timestamp)\"]\n    \n    EMIT --\u003e UNBIND[\"glBindBuffer(GL_PIXEL_PACK_BUFFER, 0)\"]\n    SKIP --\u003e UNBIND\n    \n    UNBIND --\u003e SWAP[\"pboIndex_ = nextIndex\u003cbr/\u003epboAvailable_ = true\"]\n    \n    SWAP --\u003e END[\"Return\"]\n```\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:258-288]()\n\n### Destruction Phase\n\nPBOs are destroyed when recording stops:\n\n```cpp\nvoid VisualizerWindow::destroyPBOs() {\n    if (pbos_[0])\n        glDeleteBuffers(2, pbos_);\n    pbos_[0] = pbos_[1] = 0;\n}\n```\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:252-256]()\n\n---\n\n## Integration with VideoRecorder\n\nCaptured frames flow from `VisualizerWindow` to `VideoRecorder` via Qt signals and the `FrameGrabber` queue:\n\n```mermaid\ngraph TB\n    subgraph \"VisualizerWindow (Render Thread)\"\n        CAPTURE[\"captureAsync()\"]\n        SIGNAL[\"frameCaptured signal\"]\n        CAPTURE --\u003e SIGNAL\n    end\n    \n    subgraph \"VideoRecorder (Main Thread)\"\n        SUBMIT[\"submitVideoFrame()\u003cbr/\u003estd::move semantics\"]\n        FRAME_STRUCT[\"GrabbedFrame struct\u003cbr/\u003e{data, width, height, timestamp}\"]\n        SUBMIT --\u003e FRAME_STRUCT\n    end\n    \n    subgraph \"FrameGrabber (Thread-Safe Queue)\"\n        QUEUE[\"std::deque\u003cGrabbedFrame\u003e\"]\n        PUSH[\"pushFrame(std::move)\"]\n        POP[\"getNextFrame(timeout_ms)\"]\n        FRAME_STRUCT --\u003e PUSH\n        PUSH --\u003e QUEUE\n        QUEUE --\u003e POP\n    end\n    \n    subgraph \"Encoding Thread\"\n        GET[\"getNextFrame() returns true\"]\n        SCALE[\"sws_scale(RGBAYUV420P)\"]\n        ENCODE[\"avcodec_send_frame()\"]\n        GET --\u003e SCALE\n        SCALE --\u003e ENCODE\n    end\n    \n    SIGNAL -.-\u003e|\"Qt signal\"| SUBMIT\n    POP --\u003e GET\n    \n    style CAPTURE fill:#f9f9f9\n    style SIGNAL fill:#f9f9f9\n    style SUBMIT fill:#e8f4f8\n    style FRAME_STRUCT fill:#e8f4f8\n    style QUEUE fill:#fff4e6\n    style GET fill:#e8f8e8\n```\n\n### Frame Data Structure\n\nThe `GrabbedFrame` struct (defined in `FrameGrabber.hpp`) holds captured frame data:\n\n```cpp\nstruct GrabbedFrame {\n    std::vector\u003cu8\u003e data;    // Pixel data (RGBA)\n    u32 width;               // Frame width\n    u32 height;              // Frame height  \n    i64 timestamp;           // Capture timestamp (microseconds)\n};\n```\n\n### Signal-Slot Connection\n\nThe connection is established when recording starts:\n\n```cpp\n// In VideoRecorder or controller setup:\nconnect(visualizerWindow, \u0026VisualizerWindow::frameCaptured,\n        videoRecorder, \u0026VideoRecorder::submitVideoFrame);\n```\n\nThe `submitVideoFrame` method uses move semantics to avoid copying the frame data:\n\n**Sources:** [src/recorder/VideoRecorder.cpp:113-128]()\n\n---\n\n## Recording Start/Stop Workflow\n\n### Starting Recording\n\nWhen recording starts, the system performs these steps:\n\n```mermaid\nsequenceDiagram\n    participant VR as \"VideoRecorder\"\n    participant VW as \"VisualizerWindow\"\n    participant GL as \"OpenGL Context\"\n    \n    VR-\u003e\u003eVW: startRecording()\n    \n    VW-\u003e\u003eVW: recording_ = true\n    VW-\u003e\u003eGL: makeCurrent()\n    \n    VW-\u003e\u003eVW: renderTarget_.resize(recordWidth_, recordHeight_)\n    VW-\u003e\u003eVW: overlayTarget_.resize(recordWidth_, recordHeight_)\n    VW-\u003e\u003eVW: projectM_.resize(recordWidth_, recordHeight_)\n    \n    VW-\u003e\u003eVW: setupPBOs()\n    Note over VW: Creates pbos_[2], allocates GPU buffers\n    \n    VW-\u003e\u003eGL: doneCurrent()\n    \n    Note over VW: Next renderFrame() will call captureAsync()\n```\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:316-324]()\n\n### Stopping Recording\n\nWhen recording stops:\n\n```mermaid\nsequenceDiagram\n    participant VR as \"VideoRecorder\"\n    participant VW as \"VisualizerWindow\"\n    participant GL as \"OpenGL Context\"\n    \n    VR-\u003e\u003eVW: stopRecording()\n    \n    VW-\u003e\u003eVW: recording_ = false\n    VW-\u003e\u003eGL: makeCurrent()\n    \n    VW-\u003e\u003eVW: destroyPBOs()\n    Note over VW: Deletes pbos_[2], frees GPU memory\n    \n    VW-\u003e\u003eGL: doneCurrent()\n    \n    Note over VW: Next renderFrame() skips captureAsync()\n    Note over VW: FBOs resize to window dimensions\n```\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:327-333]()\n\n---\n\n## Performance Considerations\n\n### Zero-Copy Semantics\n\nThe frame capture pipeline minimizes memory copies:\n\n| Transfer Stage | Method | Copy? |\n|----------------|--------|-------|\n| GPU  PBO | `glReadPixels` with bound PBO | **No** (DMA transfer) |\n| PBO  CPU vector | `std::vector` constructor from pointer | **Yes** (required for ownership) |\n| Vector  Signal | `std::move(buffer)` | **No** (move semantics) |\n| Signal  FrameGrabber | `pushFrame(std::move(frame))` | **No** (move semantics) |\n| FrameGrabber  Encoding thread | `getNextFrame()` | **No** (returns reference) |\n\n**Total copies per frame:** 1 (PBO to vector, unavoidable)\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:273-277](), [src/recorder/VideoRecorder.cpp:120-127]()\n\n### Asynchronous Overlap\n\nThe double-buffering enables overlap between GPU and CPU operations:\n\n```\nFrame N:   [GPU renders] [GPUPBO_A transfer]\n                                              [CPU reads PBO_B] [CPU process]\n                                              \nFrame N+1:                [GPU renders] [GPUPBO_B transfer]\n                                                               [CPU reads PBO_A] [CPU process]\n```\n\nWithout PBOs, the pipeline would stall:\n```\nFrame N:   [GPU renders] [WAIT for GPU] [CPU reads pixels] [CPU process]\nFrame N+1:                                                  [GPU renders] [WAIT]...\n```\n\n### Frame Queue Backpressure\n\nThe `FrameGrabber` implements a bounded queue with configurable capacity. When the encoding thread falls behind, `pushFrame()` will drop frames rather than block the render thread:\n\n**Default behavior:** If queue is full, oldest frame is dropped and `droppedFrames_` counter increments.\n\n**Sources:** Referenced in diagram from [src/recorder/VideoRecorder.cpp:51-52](), queue implementation in `FrameGrabber`\n\n---\n\n## Configuration\n\nRecording resolution is set via the `RecordingConfig` section in `config.toml`:\n\n```toml\n[recording.video]\nwidth = 1920          # Must be even (H.264 requirement)\nheight = 1080         # Must be even\nfps = 30\n```\n\nThe system enforces even dimensions during config loading:\n\n**Sources:** [src/core/Config.cpp:228-236]()\n\nPBO buffer size is automatically calculated as `width * height * 4` bytes (RGBA format with 1 byte per channel).\n\n---\n\n## Summary\n\nThe PBO-based frame capture system provides:\n\n- **Asynchronous GPU-to-CPU transfer** via double-buffered PBOs\n- **Zero-copy signal emission** via move semantics\n- **Thread-safe frame queue** decoupling rendering from encoding\n- **Automatic frame dropping** when encoding falls behind\n- **Minimal pipeline stalls** through overlapped GPU/CPU operations\n\nThis architecture enables high-quality, high-framerate recording without impacting real-time visualization performance.\n\n**Sources:** [src/visualizer/VisualizerWindow.cpp:239-288](), [src/visualizer/VisualizerWindow.hpp:99-106](), [src/recorder/VideoRecorder.cpp:113-128]()"])</script><script>self.__next_f.push([1,"27:T3dd6,"])</script><script>self.__next_f.push([1,"# Overlay System\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [src/core/Config.cpp](src/core/Config.cpp)\n- [src/overlay/OverlayRenderer.hpp](src/overlay/OverlayRenderer.hpp)\n- [src/recorder/VideoRecorder.cpp](src/recorder/VideoRecorder.cpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThe Overlay System provides text rendering capabilities that composite over projectM visualizations. It manages overlay elements (text labels, metadata, lyrics) and renders them using OpenGL with support for animations, positioning, and beat-reactive effects. The system consists of two primary components: `OverlayEngine` for high-level element management and `OverlayRenderer` for low-level OpenGL drawing operations.\n\nFor information about the visualization rendering pipeline that overlays are composited onto, see [Visualization System](#4). For UI controls to edit overlay configurations, see [Settings Dialog](#7.3).\n\n**Sources:** Diagram 1 (High-Level System Architecture), Diagram 2 (Audio-Visual-Recording Pipeline)\n\n## System Architecture\n\nThe Overlay System follows a two-layer design separating business logic from rendering implementation:\n\n```mermaid\ngraph TB\n    subgraph \"Configuration Layer\"\n        CONFIG[\"Config Singleton\"]\n        OEC[\"vector\u0026lt;OverlayElementConfig\u0026gt;\"]\n    end\n    \n    subgraph \"Overlay System\"\n        OE[\"OverlayEngine\u003cbr/\u003eElement Management\"]\n        OR[\"OverlayRenderer\u003cbr/\u003eOpenGL Drawing\"]\n    end\n    \n    subgraph \"Rendering Context\"\n        VW[\"VisualizerWindow\u003cbr/\u003eOpenGL Context\"]\n        PM[\"ProjectMBridge\u003cbr/\u003eprojectM Rendering\"]\n    end\n    \n    subgraph \"Data Sources\"\n        AE[\"AudioEngine\u003cbr/\u003eMetadata\"]\n        SC[\"SunoController\u003cbr/\u003eLyrics\"]\n    end\n    \n    subgraph \"Output\"\n        SCREEN[\"Display\"]\n        VR[\"VideoRecorder\u003cbr/\u003eFrame Capture\"]\n    end\n    \n    CONFIG --\u003e|\"parseOverlay()\"| OEC\n    OEC --\u003e|\"load elements\"| OE\n    \n    AE -.-\u003e|\"metadata signals\"| OE\n    SC -.-\u003e|\"lyrics data\"| OE\n    \n    OE --\u003e|\"renderToImage()\"| OR\n    OR --\u003e|\"upload() / draw()\"| VW\n    \n    PM --\u003e|\"base visualization\"| VW\n    VW --\u003e|\"composite overlay\"| SCREEN\n    VW -.-\u003e|\"capture frames\"| VR\n    \n    OR --\u003e|\"QOpenGLShaderProgram\"| GL[\"OpenGL API\"]\n    OR --\u003e|\"QOpenGLTexture\"| GL\n```\n\n**Architecture Diagram: Overlay System Component Structure**\n\nThe `OverlayEngine` owns the business logic for managing overlay elements, handling animations, and responding to audio/metadata events. The `OverlayRenderer` encapsulates all OpenGL state (shaders, VAOs, VBOs, textures) and provides a clean interface for uploading CPU-rendered images and drawing them as textured quads.\n\n**Sources:** [src/overlay/OverlayRenderer.hpp:1-44](), Diagram 1 (Overall System Architecture), Diagram 2 (Audio-Visual-Recording Pipeline)\n\n## Overlay Element Configuration\n\nOverlay elements are configured via TOML and stored as `OverlayElementConfig` objects. The `Config` singleton manages a vector of these configurations, which are loaded at startup and can be modified at runtime.\n\n### Configuration Structure\n\n| Property | Type | Purpose | Default |\n|----------|------|---------|---------|\n| `id` | `string` | Unique identifier for the element | `\"element\"` |\n| `text` | `string` | Text content or template (e.g., `\"{title}\"`) | `\"\"` |\n| `position` | `Vec2` | Normalized screen coordinates (0.0-1.0) | `{0.0, 0.0}` |\n| `fontSize` | `u32` | Font size in points | `32` |\n| `color` | `Color` | Text color (hex or named) | `#FFFFFF` |\n| `opacity` | `f32` | Alpha transparency (0.0-1.0) | `1.0` |\n| `animation` | `string` | Animation type (`\"none\"`, `\"fade\"`, `\"slide\"`, `\"pulse\"`) | `\"none\"` |\n| `animationSpeed` | `f32` | Animation speed multiplier | `1.0` |\n| `anchor` | `string` | Text alignment (`\"left\"`, `\"center\"`, `\"right\"`) | `\"left\"` |\n| `visible` | `bool` | Element visibility | `true` |\n\n### TOML Example\n\n```toml\n[[overlay.elements]]\nid = \"title\"\ntext = \"{title}\"\nposition = { x = 0.05, y = 0.95 }\nfont_size = 48\ncolor = \"#00FF88\"\nopacity = 0.9\nanimation = \"fade\"\nanchor = \"left\"\nvisible = true\n\n[[overlay.elements]]\nid = \"artist\"\ntext = \"{artist}\"\nposition = { x = 0.05, y = 0.90 }\nfont_size = 32\ncolor = \"#FFFFFF\"\nopacity = 0.8\n```\n\n**Sources:** [src/core/Config.cpp:250-286](), [src/core/Config.cpp:385-404]()\n\n## Configuration Parsing and Serialization\n\nThe `Config` class provides methods for loading and persisting overlay configurations:\n\n```mermaid\ngraph LR\n    TOML[\"config.toml\u003cbr/\u003eTOML File\"]\n    \n    subgraph \"Config Class Methods\"\n        PARSE[\"parseOverlay()\u003cbr/\u003eTOML  Objects\"]\n        SERIAL[\"serialize()\u003cbr/\u003eObjects  TOML\"]\n        ADD[\"addOverlayElement()\"]\n        REMOVE[\"removeOverlayElement()\"]\n        FIND[\"findOverlayElement()\"]\n    end\n    \n    VEC[\"vector\u0026lt;OverlayElementConfig\u0026gt;\u003cbr/\u003eoverlayElements_\"]\n    \n    TOML --\u003e|\"load()\"| PARSE\n    PARSE --\u003e VEC\n    VEC --\u003e SERIAL\n    SERIAL --\u003e|\"save()\"| TOML\n    \n    ADD --\u003e|\"push_back + markDirty()\"| VEC\n    REMOVE --\u003e|\"erase_if + markDirty()\"| VEC\n    FIND --\u003e|\"return ptr\"| VEC\n```\n\n**Diagram: Configuration Management Flow**\n\n### Parsing Logic\n\nThe `parseOverlay()` method iterates through the `[[overlay.elements]]` array in the TOML configuration:\n\n1. Clears the existing `overlayElements_` vector\n2. Iterates through each element in the TOML array\n3. Extracts primitive properties using the templated `get()` helper\n4. Parses the `position` table into a `Vec2` using `parseVec2()`\n5. Converts color strings to `Color` objects via `Color::fromHex()`\n6. Appends the constructed `OverlayElementConfig` to the vector\n\n**Sources:** [src/core/Config.cpp:250-286]()\n\n### Serialization Logic\n\nThe `serialize()` method constructs the TOML representation:\n\n1. Creates a `toml::array` to hold element tables\n2. For each element in `overlayElements_`, builds a `toml::table` with:\n   - All scalar properties\n   - A nested position table with `x` and `y` fields\n   - Color converted to hex string via `Color::toHex()`\n3. Inserts the array into the root table under `overlay.elements`\n\n**Sources:** [src/core/Config.cpp:385-404]()\n\n### Runtime Modification\n\nThe `Config` class provides thread-safe methods for runtime modifications:\n\n- **`addOverlayElement(OverlayElementConfig elem)`**: Appends a new element to the vector and marks the configuration as dirty\n- **`removeOverlayElement(const std::string\u0026 id)`**: Removes elements matching the given ID using `std::erase_if` and marks dirty\n- **`findOverlayElement(const std::string\u0026 id)`**: Returns a non-owning pointer to the element with the matching ID, or `nullptr`\n\nAll modification methods acquire a `std::lock_guard` on the internal `mutex_` for thread safety, and call `markDirty()` to ensure changes are persisted on the next save.\n\n**Sources:** [src/core/Config.cpp:438-458]()\n\n## OverlayRenderer Implementation\n\nThe `OverlayRenderer` class manages all OpenGL state required for rendering overlay textures as fullscreen or positioned quads.\n\n```mermaid\ngraph TB\n    subgraph \"OverlayRenderer Class\"\n        INIT[\"init()\u003cbr/\u003eSetup GL Resources\"]\n        UPLOAD[\"upload(QImage)\u003cbr/\u003eCPU  GPU Transfer\"]\n        DRAW[\"draw()\u003cbr/\u003eRender Quad\"]\n    end\n    \n    subgraph \"OpenGL Resources\"\n        SHADER[\"QOpenGLShaderProgram\u003cbr/\u003eVertex + Fragment Shaders\"]\n        VAO[\"QOpenGLVertexArrayObject\u003cbr/\u003eVertex State\"]\n        VBO[\"QOpenGLBuffer\u003cbr/\u003eQuad Vertices\"]\n        TEX[\"QOpenGLTexture\u003cbr/\u003eOverlay Image\"]\n    end\n    \n    subgraph \"Shader Pipeline\"\n        VS[\"Vertex Shader\u003cbr/\u003ePosition Transform\"]\n        FS[\"Fragment Shader\u003cbr/\u003eTexture Sampling + Alpha\"]\n    end\n    \n    INIT --\u003e|\"create\"| SHADER\n    INIT --\u003e|\"create\"| VAO\n    INIT --\u003e|\"create\"| VBO\n    INIT --\u003e|\"compile\"| VS\n    INIT --\u003e|\"compile\"| FS\n    \n    UPLOAD --\u003e|\"allocate/update\"| TEX\n    \n    DRAW --\u003e|\"bind\"| SHADER\n    DRAW --\u003e|\"bind\"| VAO\n    DRAW --\u003e|\"bind\"| TEX\n    DRAW --\u003e|\"glDrawArrays\"| GPU[\"GPU Rasterization\"]\n    \n    VS --\u003e FS\n    FS --\u003e GPU\n```\n\n**Diagram: OverlayRenderer OpenGL Resource Management**\n\n### Initialization Sequence\n\nThe `init()` method must be called with an active OpenGL context:\n\n1. **Shader Compilation**: Creates and compiles vertex and fragment shaders for textured quad rendering\n2. **VAO Setup**: Allocates a Vertex Array Object to store vertex attribute configuration\n3. **VBO Setup**: Allocates a Vertex Buffer Object and uploads fullscreen quad geometry (typically NDC coordinates for a quad covering the viewport)\n4. **Texture Preparation**: Prepares the texture object (actual allocation happens during `upload()`)\n5. **State Caching**: Sets `initialized_ = true` to prevent re-initialization\n\n**Sources:** [src/overlay/OverlayRenderer.hpp:22-24]()\n\n### Texture Upload Pipeline\n\nThe `upload(const QImage\u0026 image)` method transfers CPU-rendered overlay images to GPU memory:\n\n1. Converts the `QImage` to a GL-compatible format (typically RGBA8)\n2. Allocates or reallocates the `QOpenGLTexture` if dimensions have changed\n3. Uploads pixel data using `QOpenGLTexture::setData()`\n4. Sets texture parameters (filtering, wrapping) for smooth rendering\n\nThis method is called by the `OverlayEngine` after CPU-side text rendering is complete.\n\n**Sources:** [src/overlay/OverlayRenderer.hpp:25-26]()\n\n### Drawing Operation\n\nThe `draw()` method renders the uploaded texture:\n\n1. **Shader Binding**: Activates the overlay shader program\n2. **Uniform Setup**: Sets any necessary uniforms (e.g., opacity modulation)\n3. **Texture Binding**: Binds the overlay texture to a sampler unit\n4. **VAO Binding**: Activates the vertex array containing quad geometry\n5. **Draw Call**: Issues `glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)` or equivalent\n6. **State Cleanup**: Unbinds resources to avoid state leakage\n\nThe renderer uses alpha blending to composite the overlay over the projectM visualization, typically with `glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)`.\n\n**Sources:** [src/overlay/OverlayRenderer.hpp:28-29]()\n\n## Integration with Visualization Pipeline\n\nThe Overlay System integrates at the final stage of the rendering pipeline, after projectM has rendered the base visualization:\n\n```mermaid\nsequenceDiagram\n    participant PM as ProjectMBridge\n    participant VW as VisualizerWindow\n    participant OE as OverlayEngine\n    participant OR as OverlayRenderer\n    participant GL as OpenGL Context\n    \n    Note over VW: Frame Render Loop\n    \n    PM-\u003e\u003eGL: Render visualization to FBO\n    VW-\u003e\u003ePM: renderFrame()\n    \n    VW-\u003e\u003eOE: Request overlay rendering\n    OE-\u003e\u003eOE: Process animations\u003cbr/\u003eUpdate element states\n    OE-\u003e\u003eOE: Render text to QImage\u003cbr/\u003e(QPainter operations)\n    OE-\u003e\u003eOR: upload(QImage)\n    OR-\u003e\u003eGL: Upload texture data\n    \n    VW-\u003e\u003eOR: draw()\n    OR-\u003e\u003eGL: Bind shader/VAO/texture\n    OR-\u003e\u003eGL: glDrawArrays()\n    GL--\u003e\u003eVW: Composited frame\n    \n    VW-\u003e\u003eVW: swapBuffers() or\u003cbr/\u003ecapture to PBO\n```\n\n**Diagram: Overlay Rendering Sequence in Frame Loop**\n\nThe `VisualizerWindow` orchestrates the rendering:\n\n1. ProjectM renders the base visualization to the default framebuffer or an FBO\n2. The `OverlayEngine` is invoked to generate the current overlay state\n3. Text elements are rasterized to a `QImage` using `QPainter` (CPU-side)\n4. The `OverlayRenderer` uploads this image as a texture\n5. The renderer draws a textured quad with alpha blending enabled\n6. The final composited frame is either displayed or captured for recording\n\n**Sources:** Diagram 2 (Audio-Visual-Recording Pipeline), [src/overlay/OverlayRenderer.hpp:1-44]()\n\n## Data Source Integration\n\nThe Overlay System receives dynamic content from multiple sources:\n\n```mermaid\ngraph LR\n    subgraph \"Data Sources\"\n        AE[\"AudioEngine\"]\n        PL[\"Playlist\"]\n        SC[\"SunoController\"]\n        BEAT[\"BeatDetector\u003cbr/\u003e(in ProjectMBridge)\"]\n    end\n    \n    subgraph \"OverlayEngine\"\n        META[\"Metadata Templates\u003cbr/\u003e{title}, {artist}, {album}\"]\n        LYR[\"Lyrics Synchronization\"]\n        ANIM[\"Animation State Machine\"]\n        BEAT_REACT[\"Beat-Reactive Effects\"]\n    end\n    \n    subgraph \"Rendering\"\n        QIMAGE[\"QImage\u003cbr/\u003eCPU Rasterization\"]\n        OR[\"OverlayRenderer\u003cbr/\u003eGPU Upload\"]\n    end\n    \n    AE --\u003e|\"trackChanged signal\"| META\n    PL --\u003e|\"current track info\"| META\n    SC --\u003e|\"aligned lyrics\"| LYR\n    BEAT --\u003e|\"beat events\"| BEAT_REACT\n    \n    META --\u003e QIMAGE\n    LYR --\u003e QIMAGE\n    ANIM --\u003e QIMAGE\n    BEAT_REACT --\u003e QIMAGE\n    \n    QIMAGE --\u003e OR\n```\n\n**Diagram: Overlay Data Flow from Multiple Sources**\n\n### Metadata Substitution\n\nThe `OverlayEngine` performs template variable substitution in overlay element text:\n\n- `{title}`  Current track title\n- `{artist}`  Track artist\n- `{album}`  Album name\n- `{duration}`  Track length\n- `{position}`  Current playback position\n\nThese values are populated from the `AudioEngine` via signals like `trackChanged` or by querying the current `Playlist` state.\n\n**Sources:** Diagram 1 (Overall System Architecture), Diagram 4 (Suno Integration Architecture)\n\n### Lyrics Display\n\nWhen a Suno AI track with aligned lyrics is playing:\n\n1. The `SunoController` fetches aligned lyrics via `SunoClient::fetchAlignedLyrics()`\n2. Lyrics are passed to the `OverlayEngine` with timestamp information\n3. The engine synchronizes lyric line display with playback position\n4. Optionally applies fade-in/fade-out animations for lyric transitions\n\n**Sources:** Diagram 4 (Suno Integration Architecture)\n\n### Beat-Reactive Effects\n\nThe Overlay System can respond to beat detection events from projectM:\n\n- **Pulse Animation**: Scales text or increases opacity on beat\n- **Color Shift**: Temporarily adjusts text color based on beat intensity\n- **Shake Effect**: Applies small random displacement on strong beats\n\nThese effects are configurable per overlay element and respect the `animation` and `animationSpeed` configuration fields.\n\n**Sources:** Table of Contents (page 6.1 description)\n\n## Recording Integration\n\nWhen video recording is active, the composited overlay is included in the captured frames:\n\n1. The `VisualizerWindow` renders the complete scene (visualization + overlay)\n2. If recording is enabled, the window captures the framebuffer via PBOs\n3. The `FrameGrabber` queues the frame data\n4. The `VideoRecorder` encoding thread processes frames with overlays intact\n\nThis ensures that recorded videos include all overlay elements exactly as displayed.\n\n**Sources:** [src/recorder/VideoRecorder.cpp:113-128](), Diagram 2 (Audio-Visual-Recording Pipeline)\n\n## Performance Considerations\n\n### CPU-Side Rendering\n\nText rasterization using `QPainter` is performed on the CPU. To minimize overhead:\n\n- Only re-render overlay elements when their content or state changes\n- Cache rendered glyphs when possible\n- Use dirty flags to avoid redundant rasterization\n\n### GPU Upload Optimization\n\nThe `OverlayRenderer` optimizes texture uploads:\n\n- Reuses the same `QOpenGLTexture` object when dimensions are unchanged\n- Uses `QOpenGLTexture::setData()` for direct pixel transfer\n- Avoids unnecessary texture allocations by checking current size\n\n### Rendering Cost\n\nOverlay rendering adds minimal GPU cost:\n\n- Single fullscreen quad with alpha blending (typically \u003c0.1ms per frame)\n- Shader is trivial (vertex passthrough + texture sampling)\n- No geometry processing or complex fragment operations\n\n**Sources:** [src/overlay/OverlayRenderer.hpp:25-29]()\n\n## Thread Safety\n\nThe Overlay System operates within the render thread context:\n\n- Configuration access is protected by `Config::mutex_` for thread-safe reads/writes\n- The `OverlayEngine` is designed to be invoked from the render thread only\n- The `OverlayRenderer` maintains no shared state and assumes single-threaded OpenGL access\n- Configuration modifications from UI threads are synchronized via the `Config` singleton\n\n**Sources:** [src/core/Config.cpp:438-458]()"])</script><script>self.__next_f.push([1,"28:T480f,"])</script><script>self.__next_f.push([1,"# OverlayEngine \u0026 Elements\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [src/core/Config.cpp](src/core/Config.cpp)\n- [src/recorder/VideoRecorder.cpp](src/recorder/VideoRecorder.cpp)\n- [src/ui/MainWindow.cpp](src/ui/MainWindow.cpp)\n- [src/ui/MainWindow.hpp](src/ui/MainWindow.hpp)\n\n\u003c/details\u003e\n\n\n\nThis document describes the `OverlayEngine` class and the `OverlayElementConfig` structure, which together manage text overlay elements displayed on top of the visualization output. The overlay system provides dynamic text rendering for metadata display, lyrics, and animated text effects that can respond to audio beats.\n\nFor information about the OpenGL rendering implementation of overlays, see [OverlayRenderer](#6.2). For the UI widget used to edit overlay configurations, see the OverlayEditor component discussed in [MainWindow \u0026 Layout](#7.1).\n\n---\n\n## System Architecture\n\nThe overlay system consists of two primary components: `OverlayEngine` handles element management, animations, and business logic, while `OverlayRenderer` (documented separately) handles the OpenGL drawing. The engine is owned by the `Application` singleton and accessed by various UI and visualization components.\n\n```mermaid\ngraph TB\n    subgraph \"Core Application\"\n        APP[\"Application\u003cbr/\u003eSingleton\"]\n        CONFIG[\"Config\u003cbr/\u003eoverlayElements_\"]\n    end\n    \n    subgraph \"Overlay System\"\n        ENGINE[\"OverlayEngine\u003cbr/\u003eElement Management\u003cbr/\u003eAnimation Logic\"]\n        RENDERER[\"OverlayRenderer\u003cbr/\u003eOpenGL Drawing\"]\n        CONFIG_OBJ[\"OverlayElementConfig\u003cbr/\u003ePer-Element Settings\"]\n    end\n    \n    subgraph \"Data Sources\"\n        AUDIO[\"AudioEngine\u003cbr/\u003eTrack Metadata\"]\n        SUNO[\"SunoController\u003cbr/\u003eAligned Lyrics\"]\n        SPECTRUM[\"AudioSpectrum\u003cbr/\u003eBeat Detection\"]\n    end\n    \n    subgraph \"UI Components\"\n        MAINWIN[\"MainWindow\u003cbr/\u003eUpdate Loop\"]\n        VIZPANEL[\"VisualizerPanel\u003cbr/\u003eRendering Context\"]\n        EDITOR[\"OverlayEditor\u003cbr/\u003eElement Configuration\"]\n    end\n    \n    APP --\u003e|\"owns\"| ENGINE\n    CONFIG --\u003e|\"loads/saves\"| CONFIG_OBJ\n    ENGINE --\u003e|\"uses\"| RENDERER\n    ENGINE --\u003e|\"manages vector of\"| CONFIG_OBJ\n    \n    AUDIO --\u003e|\"trackChanged signal\u003cbr/\u003eupdateMetadata()\"| ENGINE\n    AUDIO --\u003e|\"positionChanged signal\u003cbr/\u003eupdatePlaybackTime()\"| ENGINE\n    SUNO --\u003e|\"pass lyrics\"| ENGINE\n    SPECTRUM --\u003e|\"beatDetected\u003cbr/\u003eonBeat()\"| ENGINE\n    \n    MAINWIN --\u003e|\"update(dt)\"| ENGINE\n    MAINWIN --\u003e|\"onBeat(intensity)\"| ENGINE\n    VIZPANEL --\u003e|\"provides context\"| ENGINE\n    EDITOR --\u003e|\"modifies config\"| CONFIG_OBJ\n    \n    style ENGINE fill:#fff4e1,stroke:#333,stroke-width:2px\n    style CONFIG_OBJ fill:#e1ffe1\n```\n\n**Sources:** [src/ui/MainWindow.cpp:43-44](), [src/ui/MainWindow.cpp:255-273](), [src/ui/MainWindow.cpp:281-286]()\n\n---\n\n## OverlayElementConfig Structure\n\nEach overlay element is configured via an `OverlayElementConfig` struct, which defines its visual properties, position, and animation behavior. These configurations are stored in the global `Config` singleton and persisted to the TOML configuration file.\n\n### Configuration Fields\n\n| Field | Type | Purpose | Default |\n|-------|------|---------|---------|\n| `id` | `std::string` | Unique identifier for the element | `\"element\"` |\n| `text` | `std::string` | Static text or template string (e.g., `\"{artist} - {title}\"`) | `\"\"` |\n| `position` | `Vec2` | Normalized screen coordinates (0.0-1.0) | `{0.0, 0.0}` |\n| `fontSize` | `u32` | Font size in points | `32` |\n| `color` | `Color` | Text color (parsed from hex string) | `#FFFFFF` |\n| `opacity` | `f32` | Alpha transparency (0.0-1.0) | `1.0` |\n| `animation` | `std::string` | Animation type: `\"none\"`, `\"fade\"`, `\"slide\"`, etc. | `\"none\"` |\n| `animationSpeed` | `f32` | Animation speed multiplier | `1.0` |\n| `anchor` | `std::string` | Text alignment: `\"left\"`, `\"center\"`, `\"right\"` | `\"left\"` |\n| `visible` | `bool` | Whether the element is currently displayed | `true` |\n\n### TOML Configuration Format\n\nOverlay elements are defined in the `config.toml` file under the `[[overlay.elements]]` array:\n\n```toml\n[overlay]\nenabled = true\n\n[[overlay.elements]]\nid = \"track_info\"\ntext = \"{artist} - {title}\"\nposition = { x = 0.05, y = 0.95 }\nfont_size = 32\ncolor = \"#FFFFFF\"\nopacity = 0.9\nanimation = \"fade\"\nanimation_speed = 1.0\nanchor = \"left\"\nvisible = true\n\n[[overlay.elements]]\nid = \"current_time\"\ntext = \"{current_time} / {total_time}\"\nposition = { x = 0.95, y = 0.95 }\nfont_size = 24\ncolor = \"#00FF88\"\nopacity = 0.8\nanimation = \"none\"\nanchor = \"right\"\nvisible = true\n```\n\n**Sources:** [src/core/Config.cpp:250-286](), [src/core/Config.cpp:386-404]()\n\n---\n\n## OverlayEngine Class\n\nThe `OverlayEngine` class manages the lifecycle of overlay elements, processes template strings with metadata substitution, updates animations, and handles beat-reactive effects. It is instantiated and owned by the `Application` singleton.\n\n### Key Responsibilities\n\n```mermaid\ngraph LR\n    subgraph \"OverlayEngine Responsibilities\"\n        MGT[\"Element Management\u003cbr/\u003eadd/remove/find\"]\n        ANIM[\"Animation Processing\u003cbr/\u003efade, slide, pulse\"]\n        META[\"Metadata Substitution\u003cbr/\u003e{artist}, {title}, etc.\"]\n        BEAT[\"Beat Reaction\u003cbr/\u003eintensity-based scaling\"]\n        TIME[\"Playback Time Tracking\u003cbr/\u003ecurrent/total duration\"]\n    end\n    \n    MGT --\u003e|\"operates on\"| ELEMS[\"vector\u003cOverlayElementConfig\u003e\"]\n    ANIM --\u003e|\"updates\"| PROPS[\"opacity, position\"]\n    META --\u003e|\"replaces\"| TOKENS[\"text templates\"]\n    BEAT --\u003e|\"triggers\"| EFFECTS[\"visual effects\"]\n    TIME --\u003e|\"formats\"| DISPLAY[\"time strings\"]\n    \n    ELEMS -.-\u003e|\"rendered by\"| RENDERER[\"OverlayRenderer\"]\n```\n\n**Sources:** [src/ui/MainWindow.cpp:258-273](), [src/ui/MainWindow.cpp:281-286]()\n\n### Element Management Interface\n\nThe `Config` singleton provides methods for managing overlay elements that the `OverlayEngine` uses:\n\n- **`Config::addOverlayElement(OverlayElementConfig elem)`**: Adds a new element to the configuration\n- **`Config::removeOverlayElement(const std::string\u0026 id)`**: Removes an element by its unique ID\n- **`Config::findOverlayElement(const std::string\u0026 id)`**: Returns a pointer to an element for modification\n- **`Config::overlayElements()`**: Returns the vector of all configured elements\n\nAll methods are thread-safe, using a mutex internally, and mark the configuration as dirty for persistence.\n\n**Sources:** [src/core/Config.cpp:438-458]()\n\n---\n\n## Element Lifecycle\n\nOverlay elements follow a well-defined lifecycle from configuration loading through runtime updates to final persistence:\n\n```mermaid\nstateDiagram-v2\n    [*] --\u003e Loading: Application Start\n    Loading --\u003e Parsed: parseOverlay()\n    Parsed --\u003e Active: OverlayEngine Created\n    \n    Active --\u003e Modified: User Edits in OverlayEditor\n    Modified --\u003e Active: overlayChanged signal\n    \n    Active --\u003e Updated: update(dt) called each frame\n    Updated --\u003e Active: Animations processed\n    \n    Active --\u003e BeatReactive: onBeat() triggered\n    BeatReactive --\u003e Active: Intensity effect applied\n    \n    Active --\u003e MetadataRefresh: updateMetadata() called\n    MetadataRefresh --\u003e Active: Text templates expanded\n    \n    Active --\u003e Saving: closeEvent / explicit save\n    Saving --\u003e Persisted: serialize() to TOML\n    Persisted --\u003e [*]\n    \n    note right of Loading\n        Config::parseOverlay()\n        Reads [[overlay.elements]]\n    end note\n    \n    note right of Updated\n        MainWindow update timer\n        16ms interval (60fps)\n    end note\n    \n    note right of Persisted\n        Config::save()\n        Atomic file write\n    end note\n```\n\n**Sources:** [src/core/Config.cpp:250-286](), [src/ui/MainWindow.cpp:271-273](), [src/ui/MainWindow.cpp:276-286](), [src/ui/MainWindow.cpp:439]()\n\n---\n\n## Update Loop Integration\n\nThe `OverlayEngine` is integrated into the main application update loop, which runs at approximately 60fps (16ms intervals). The `MainWindow` class orchestrates the updates and passes relevant state information.\n\n### Update Flow\n\n```mermaid\nsequenceDiagram\n    participant Timer as \"QTimer (16ms)\"\n    participant MainWindow\n    participant OverlayEngine\n    participant AudioEngine\n    participant AudioAnalyzer\n    \n    Timer-\u003e\u003eMainWindow: timeout signal\n    MainWindow-\u003e\u003eOverlayEngine: update(0.016f)\n    Note over OverlayEngine: Process animations\u003cbr/\u003eUpdate internal state\n    \n    MainWindow-\u003e\u003eAudioEngine: currentSpectrum()\n    AudioEngine-\u003e\u003eAudioAnalyzer: get latest spectrum\n    AudioAnalyzer--\u003e\u003eMainWindow: AudioSpectrum struct\n    \n    alt Beat Detected\n        MainWindow-\u003e\u003eOverlayEngine: onBeat(intensity)\n        Note over OverlayEngine: Apply beat-reactive\u003cbr/\u003eeffects to elements\n    end\n```\n\n### Update Method Invocation\n\nThe update loop is established in `MainWindow::setupUpdateTimer()`:\n\n```cpp\n// MainWindow connects a QTimer to call onUpdateLoop every 16ms\nconnect(\u0026updateTimer_, \u0026QTimer::timeout, this, \u0026MainWindow::onUpdateLoop);\nupdateTimer_.start(16);\n\n// onUpdateLoop processes overlay updates and beat detection\nvoid MainWindow::onUpdateLoop() {\n    overlayEngine_-\u003eupdate(0.016f);  // Fixed timestep\n    const auto\u0026 spectrum = audioEngine_-\u003ecurrentSpectrum();\n    if (spectrum.beatDetected)\n        overlayEngine_-\u003eonBeat(spectrum.beatIntensity);\n}\n```\n\n**Sources:** [src/ui/MainWindow.cpp:276-286]()\n\n---\n\n## Metadata and Template Substitution\n\nThe `OverlayEngine` supports dynamic text rendering by substituting template tokens in the `text` field of overlay elements. When `updateMetadata()` is called with new track information, the engine replaces tokens with actual values.\n\n### Supported Template Tokens\n\nCommon template tokens that can be used in overlay element text fields:\n\n| Token | Description | Example Value |\n|-------|-------------|---------------|\n| `{artist}` | Track artist name | `\"Pink Floyd\"` |\n| `{title}` | Track title | `\"Comfortably Numb\"` |\n| `{album}` | Album name | `\"The Wall\"` |\n| `{year}` | Release year | `\"1979\"` |\n| `{genre}` | Music genre | `\"Progressive Rock\"` |\n| `{current_time}` | Current playback position | `\"2:35\"` |\n| `{total_time}` | Total track duration | `\"6:23\"` |\n\n### Metadata Update Flow\n\n```mermaid\nsequenceDiagram\n    participant AudioEngine\n    participant MainWindow\n    participant OverlayEngine\n    participant Config\n    \n    AudioEngine-\u003e\u003eAudioEngine: Track changes\n    AudioEngine-\u003e\u003eMainWindow: trackChanged signal\n    \n    MainWindow-\u003e\u003eAudioEngine: playlist().currentItem()\n    AudioEngine--\u003e\u003eMainWindow: PlaylistItem with metadata\n    \n    MainWindow-\u003e\u003eOverlayEngine: updateMetadata(metadata)\n    \n    OverlayEngine-\u003e\u003eConfig: overlayElements()\n    Config--\u003e\u003eOverlayEngine: vector\u003cOverlayElementConfig\u003e\n    \n    loop For each element\n        OverlayEngine-\u003e\u003eOverlayEngine: Replace tokens in text field\n        Note over OverlayEngine: \"{artist} - {title}\"\u003cbr/\u003ebecomes\u003cbr/\u003e\"Pink Floyd - Comfortably Numb\"\n    end\n```\n\n### Playback Time Updates\n\nTime-based tokens are updated continuously via `updatePlaybackTime()`:\n\n```cpp\n// Called on every position change from AudioEngine\naudioEngine_-\u003epositionChanged.connect([this](Duration pos) {\n    QMetaObject::invokeMethod(this, [this, pos] {\n        overlayEngine_-\u003eupdatePlaybackTime(\n            static_cast\u003cf32\u003e(pos.count()) / 1000.0f\n        );\n    });\n});\n```\n\n**Sources:** [src/ui/MainWindow.cpp:255-269]()\n\n---\n\n## Beat-Reactive Effects\n\nThe overlay system can respond to audio beats detected by the `AudioAnalyzer`. When a beat is detected, the `OverlayEngine::onBeat()` method is called with an intensity value, allowing overlay elements to react visually.\n\n### Beat Detection Integration\n\n```mermaid\ngraph TB\n    subgraph \"Audio Analysis Pipeline\"\n        PCM[\"PCM Audio Data\"]\n        FFT[\"FFT Analysis\"]\n        DETECTOR[\"Beat Detector\u003cbr/\u003eEnergy-based\"]\n    end\n    \n    subgraph \"Beat Information\"\n        SPECTRUM[\"AudioSpectrum Struct\"]\n        FLAG[\"beatDetected: bool\"]\n        INTENSITY[\"beatIntensity: f32\"]\n    end\n    \n    subgraph \"Overlay Response\"\n        ENGINE[\"OverlayEngine\"]\n        EFFECTS[\"Beat Effects\"]\n        SCALE[\"Scale/Pulse Animation\"]\n        FLASH[\"Color Flash\"]\n        INTENSITY_MOD[\"Opacity Modulation\"]\n    end\n    \n    PCM --\u003e FFT\n    FFT --\u003e DETECTOR\n    DETECTOR --\u003e SPECTRUM\n    SPECTRUM --\u003e FLAG\n    SPECTRUM --\u003e INTENSITY\n    \n    FLAG --\u003e|\"if true\"| ENGINE\n    INTENSITY --\u003e ENGINE\n    ENGINE --\u003e EFFECTS\n    EFFECTS --\u003e SCALE\n    EFFECTS --\u003e FLASH\n    EFFECTS --\u003e INTENSITY_MOD\n    \n    style ENGINE fill:#fff4e1,stroke:#333,stroke-width:2px\n```\n\n### Beat Reaction Implementation\n\nThe `MainWindow` checks for beat detection in the update loop and forwards the intensity to the overlay engine:\n\n```cpp\nvoid MainWindow::onUpdateLoop() {\n    overlayEngine_-\u003eupdate(0.016f);\n    const auto\u0026 spectrum = audioEngine_-\u003ecurrentSpectrum();\n    if (spectrum.beatDetected)\n        overlayEngine_-\u003eonBeat(spectrum.beatIntensity);\n}\n```\n\nThe beat intensity value (typically 0.0-1.0, but can exceed 1.0 for strong beats) can be used to:\n- Scale elements temporarily (pulse effect)\n- Increase opacity momentarily (flash effect)\n- Modify colors (intensity-based tinting)\n- Trigger one-shot animations\n\n**Sources:** [src/ui/MainWindow.cpp:281-286]()\n\n---\n\n## Animation System\n\nOverlay elements support various animation types configured via the `animation` field in `OverlayElementConfig`. Animations are processed during the `update()` call and modify element properties over time.\n\n### Animation Types\n\n| Animation | Description | Modified Properties |\n|-----------|-------------|-------------------|\n| `\"none\"` | No animation, static display | None |\n| `\"fade\"` | Gradual opacity changes | `opacity` |\n| `\"slide\"` | Position interpolation | `position.x`, `position.y` |\n| `\"pulse\"` | Size/opacity oscillation | `fontSize`, `opacity` |\n| `\"beat_reactive\"` | Reacts to beat events | Multiple (beat-driven) |\n\n### Animation Speed Control\n\nThe `animationSpeed` field acts as a multiplier for animation timing:\n- `1.0` = normal speed\n- `2.0` = twice as fast\n- `0.5` = half speed\n\nThis allows fine-tuning of animation timing without changing the animation implementation.\n\n**Sources:** [src/core/Config.cpp:275-277]()\n\n---\n\n## Configuration Persistence\n\nOverlay element configurations are persisted through the global `Config` singleton's TOML serialization system. Changes made through the `OverlayEditor` trigger saves, and the configuration is also saved when the application closes.\n\n### Save Trigger Flow\n\n```mermaid\ngraph LR\n    subgraph \"Edit Triggers\"\n        EDITOR[\"OverlayEditor\u003cbr/\u003eUser modifies element\"]\n        CLOSE[\"MainWindow\u003cbr/\u003ecloseEvent()\"]\n    end\n    \n    subgraph \"Persistence Layer\"\n        SIGNAL[\"overlayChanged signal\"]\n        SAVE_CALL[\"config().saveToAppConfig()\"]\n        CONFIG[\"Config::save()\"]\n    end\n    \n    subgraph \"File System\"\n        TEMP[\"config.toml.tmp\"]\n        FINAL[\"config.toml\"]\n    end\n    \n    EDITOR --\u003e|\"emits\"| SIGNAL\n    SIGNAL --\u003e SAVE_CALL\n    CLOSE --\u003e CONFIG\n    SAVE_CALL --\u003e CONFIG\n    \n    CONFIG --\u003e|\"atomic write\"| TEMP\n    TEMP --\u003e|\"fs::rename\"| FINAL\n    \n    style CONFIG fill:#e1ffe1,stroke:#333,stroke-width:2px\n```\n\n### Atomic Save Mechanism\n\nThe configuration system uses atomic writes to prevent corruption:\n\n1. Serialize configuration to TOML format\n2. Write to temporary file (`config.toml.tmp`)\n3. Atomically rename to final path (`config.toml`)\n\nThis ensures that the configuration file is never left in a partially-written state.\n\n**Sources:** [src/ui/MainWindow.cpp:271-273](), [src/ui/MainWindow.cpp:439](), [src/core/Config.cpp:143-171]()\n\n---\n\n## Integration with Recording System\n\nWhen video recording is active, overlay elements are composited into the final output. The `OverlayRenderer` draws overlays after the projectM visualization is rendered, before frame capture occurs.\n\n### Recording Pipeline Position\n\n```mermaid\nflowchart LR\n    subgraph \"Render Pipeline\"\n        PM[\"ProjectM\u003cbr/\u003eVisualization\u003cbr/\u003eRender to FBO\"]\n        OE[\"OverlayEngine\u003cbr/\u003eElement State\"]\n        OR[\"OverlayRenderer\u003cbr/\u003eOpenGL Composite\"]\n        FB[\"Framebuffer\u003cbr/\u003eFinal Composite\"]\n    end\n    \n    subgraph \"Capture Path\"\n        PBO[\"Pixel Buffer Objects\u003cbr/\u003eAsync Read\"]\n        VR[\"VideoRecorder\u003cbr/\u003eFFmpeg Encoding\"]\n        FILE[\"Output MP4/MKV\"]\n    end\n    \n    PM --\u003e OE\n    OE --\u003e OR\n    OR --\u003e FB\n    \n    FB --\u003e|\"if recording\"| PBO\n    PBO --\u003e VR\n    VR --\u003e FILE\n    \n    style OE fill:#fff4e1,stroke:#333,stroke-width:2px\n```\n\nThe overlays are rendered in the same OpenGL context as the visualization, ensuring they are captured by the PBO-based frame grabbing system without additional overhead.\n\n**Sources:** [src/recorder/VideoRecorder.cpp:113-128](), [src/recorder/VideoRecorder.cpp:213-239]()\n\n---\n\n## Code Entity Reference\n\n### Key Classes and Files\n\n| Entity | Location | Purpose |\n|--------|----------|---------|\n| `OverlayEngine` | `src/overlay/OverlayEngine.hpp/cpp` | Core engine for overlay management |\n| `OverlayElementConfig` | `src/core/Config.hpp` | Configuration structure for elements |\n| `Config::overlayElements_` | `src/core/Config.hpp` | Storage for element configs |\n| `Config::parseOverlay()` | [src/core/Config.cpp:250-286]() | TOML parsing for overlay section |\n| `Config::addOverlayElement()` | [src/core/Config.cpp:438-442]() | Add element to config |\n| `Config::removeOverlayElement()` | [src/core/Config.cpp:444-449]() | Remove element by ID |\n| `Config::findOverlayElement()` | [src/core/Config.cpp:451-458]() | Find element by ID |\n| `MainWindow::setupConnections()` | [src/ui/MainWindow.cpp:248-274]() | Wire up overlay signals |\n| `MainWindow::onUpdateLoop()` | [src/ui/MainWindow.cpp:281-286]() | Update overlay state |\n\n### Signal Connections\n\nThe overlay engine integrates via several signal connections established in `MainWindow`:\n\n```cpp\n// Track metadata changes\naudioEngine_-\u003etrackChanged.connect([this] {\n    if (const auto* item = audioEngine_-\u003eplaylist().currentItem()) {\n        overlayEngine_-\u003eupdateMetadata(item-\u003emetadata);\n    }\n});\n\n// Playback position updates\naudioEngine_-\u003epositionChanged.connect([this](Duration pos) {\n    overlayEngine_-\u003eupdatePlaybackTime(\n        static_cast\u003cf32\u003e(pos.count()) / 1000.0f\n    );\n});\n\n// Configuration changes from editor\nconnect(overlayEditor_, \u0026OverlayEditor::overlayChanged, this, [this] {\n    overlayEngine_-\u003econfig().saveToAppConfig();\n});\n```\n\n**Sources:** [src/ui/MainWindow.cpp:255-273]()"])</script><script>self.__next_f.push([1,"29:T3681,"])</script><script>self.__next_f.push([1,"# OverlayRenderer\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [.gitignore](.gitignore)\n- [build.zsh](build.zsh)\n- [src/overlay/OverlayRenderer.cpp](src/overlay/OverlayRenderer.cpp)\n- [src/overlay/OverlayRenderer.hpp](src/overlay/OverlayRenderer.hpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\n`OverlayRenderer` is the low-level OpenGL rendering component of the Overlay System responsible for drawing text overlays on top of projectM visualizations. It handles shader compilation, vertex buffer management, texture uploading, and alpha-blended rendering of CPU-generated images to the screen. This class is intentionally separated from overlay element logic to isolate OpenGL-specific code.\n\nFor information about overlay element management, animations, and metadata display, see [OverlayEngine \u0026 Elements](#6.1). For the broader visualization rendering pipeline, see [VisualizerWindow](#4.1).\n\n**Sources:** [src/overlay/OverlayRenderer.hpp:1-44](), [src/overlay/OverlayRenderer.cpp:1-6]()\n\n---\n\n## Architecture Overview\n\n`OverlayRenderer` operates as a stateful OpenGL context component within the visualization rendering pipeline. It receives `QImage` objects containing pre-rendered text from `OverlayEngine` and composites them over the projectM output using alpha blending.\n\n### System Integration\n\n```mermaid\ngraph LR\n    subgraph \"Overlay System\"\n        OE[\"OverlayEngine\u003cbr/\u003e(element management)\"]\n        OR[\"OverlayRenderer\u003cbr/\u003e(OpenGL rendering)\"]\n    end\n    \n    subgraph \"Visualization Pipeline\"\n        VW[\"VisualizerWindow\u003cbr/\u003e(QWindow + context)\"]\n        PMB[\"ProjectMBridge\u003cbr/\u003e(projectM v4)\"]\n        FBO[\"RenderTarget FBO\"]\n    end\n    \n    OE --\u003e|\"QImage with text\"| OR\n    PMB --\u003e|\"render to\"| FBO\n    VW --\u003e|\"owns/calls\"| OR\n    VW --\u003e|\"owns/calls\"| PMB\n    FBO --\u003e|\"base layer\"| VW\n    OR --\u003e|\"composite over\"| VW\n    \n    style OR fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Diagram: OverlayRenderer in Rendering Pipeline**\n\n**Sources:** [src/overlay/OverlayRenderer.hpp:1-44](), Diagram 1 from system architecture\n\n---\n\n## Class Structure and Members\n\nThe `OverlayRenderer` class encapsulates all OpenGL resources needed for overlay rendering. It uses Qt's OpenGL wrapper classes to manage lifecycle and ensure proper cleanup.\n\n### Member Variables\n\n| Member | Type | Purpose |\n|--------|------|---------|\n| `program_` | `std::unique_ptr\u003cQOpenGLShaderProgram\u003e` | Compiled shader program linking vertex and fragment shaders |\n| `vbo_` | `QOpenGLBuffer` | Vertex Buffer Object storing quad geometry (positions + UVs) |\n| `vao_` | `QOpenGLVertexArrayObject` | Vertex Array Object capturing vertex attribute configuration |\n| `texture_` | `std::unique_ptr\u003cQOpenGLTexture\u003e` | 2D texture holding the uploaded overlay image |\n| `initialized_` | `bool` | Flag preventing redundant initialization |\n\n**Sources:** [src/overlay/OverlayRenderer.hpp:36-42]()\n\n### Public Interface\n\n```mermaid\nclassDiagram\n    class OverlayRenderer {\n        +OverlayRenderer()\n        +~OverlayRenderer()\n        +void init()\n        +void upload(const QImage\u0026 image)\n        +void draw()\n        +bool isInitialized() const\n        -unique_ptr~QOpenGLShaderProgram~ program_\n        -QOpenGLBuffer vbo_\n        -QOpenGLVertexArrayObject vao_\n        -unique_ptr~QOpenGLTexture~ texture_\n        -bool initialized_\n    }\n    \n    class QImage {\n        \u003c\u003cQt Class\u003e\u003e\n    }\n    \n    OverlayRenderer ..\u003e QImage : accepts\n```\n\n**Diagram: OverlayRenderer Class Structure**\n\n**Sources:** [src/overlay/OverlayRenderer.hpp:17-44]()\n\n---\n\n## OpenGL Resource Initialization\n\nThe `init()` method performs one-time setup of all OpenGL resources. It must be called with an active OpenGL context (ensured by `VisualizerWindow`). The method is idempotentrepeated calls are safely ignored via the `initialized_` flag.\n\n### Initialization Sequence\n\n```mermaid\nsequenceDiagram\n    participant Client as \"VisualizerWindow\"\n    participant OR as \"OverlayRenderer::init()\"\n    participant GL as \"OpenGL Context\"\n    \n    Client-\u003e\u003eOR: init()\n    activate OR\n    \n    OR-\u003e\u003eOR: Check initialized_ flag\n    \n    Note over OR: Shader Compilation\n    OR-\u003e\u003eGL: Compile vertex shader\n    OR-\u003e\u003eGL: Compile fragment shader\n    OR-\u003e\u003eGL: Link shader program\n    \n    Note over OR: Vertex Data Setup\n    OR-\u003e\u003eGL: Create VAO\n    OR-\u003e\u003eGL: Create VBO\n    OR-\u003e\u003eGL: Upload quad vertices (6 vertices)\n    OR-\u003e\u003eGL: Configure attribute pointers\n    \n    Note over OR: Texture Preparation\n    OR-\u003e\u003eGL: Create QOpenGLTexture\n    OR-\u003e\u003eGL: Set filtering (Linear)\n    OR-\u003e\u003eGL: Set wrap mode (ClampToEdge)\n    \n    OR-\u003e\u003eOR: Set initialized_ = true\n    deactivate OR\n```\n\n**Diagram: OpenGL Initialization Flow**\n\n**Sources:** [src/overlay/OverlayRenderer.cpp:9-94]()\n\n### Fullscreen Quad Geometry\n\nThe renderer uses a fullscreen quad composed of two triangles covering normalized device coordinates (NDC) from `[-1, 1]`:\n\n| Vertex | Position (x, y) | TexCoord (u, v) | Triangle |\n|--------|-----------------|-----------------|----------|\n| 0 | (-1.0, 1.0) | (0.0, 0.0) | 1 (top-left) |\n| 1 | (-1.0, -1.0) | (0.0, 1.0) | 1 (bottom-left) |\n| 2 | (1.0, -1.0) | (1.0, 1.0) | 1 (bottom-right) |\n| 3 | (-1.0, 1.0) | (0.0, 0.0) | 2 (top-left) |\n| 4 | (1.0, -1.0) | (1.0, 1.0) | 2 (bottom-right) |\n| 5 | (1.0, 1.0) | (1.0, 0.0) | 2 (top-right) |\n\nThis geometry is stored in the VBO with interleaved attributes: `[x, y, u, v]` per vertex. The VAO captures the attribute layout, binding location 0 to position and location 1 to texture coordinates.\n\n**Sources:** [src/overlay/OverlayRenderer.cpp:56-84]()\n\n---\n\n## Shader Pipeline\n\n`OverlayRenderer` uses a minimal shader pipeline designed for efficient texture sampling and alpha blending. Both shaders are written in GLSL 3.30 core profile.\n\n### Vertex Shader\n\nThe vertex shader performs a simple passthrough operation, mapping NDC positions directly to `gl_Position` and forwarding texture coordinates to the fragment shader:\n\n```glsl\n#version 330 core\nlayout (location = 0) in vec2 position;\nlayout (location = 1) in vec2 texCoord;\nout vec2 TexCoord;\nvoid main() {\n    gl_Position = vec4(position, 0.0, 1.0);\n    TexCoord = texCoord;\n}\n```\n\n**Sources:** [src/overlay/OverlayRenderer.cpp:19-28]()\n\n### Fragment Shader\n\nThe fragment shader samples the overlay texture and discards fully transparent pixels to avoid unnecessary blending operations:\n\n```glsl\n#version 330 core\nin vec2 TexCoord;\nout vec4 color;\nuniform sampler2D overlayTexture;\nvoid main() {\n    vec4 texColor = texture(overlayTexture, TexCoord);\n    if (texColor.a == 0.0) discard;\n    color = texColor;\n}\n```\n\nThe `discard` statement optimizes performance by avoiding blending for transparent regions, which is especially important when overlays only cover portions of the screen.\n\n**Sources:** [src/overlay/OverlayRenderer.cpp:30-40]()\n\n### Shader Compilation Error Handling\n\nShader compilation errors are logged via the `Logger` system. The `init()` method checks each compilation and linking step, emitting error messages with shader logs if failures occur:\n\n**Sources:** [src/overlay/OverlayRenderer.cpp:42-54]()\n\n---\n\n## Texture Upload Process\n\nThe `upload()` method transfers a CPU-side `QImage` to GPU memory. This is called whenever `OverlayEngine` produces a new frame with updated text.\n\n### Upload Flow\n\n```mermaid\nflowchart TD\n    A[\"upload(QImage)\"] --\u003e B{\"initialized_?\"}\n    B --\u003e|No| C[\"init()\"]\n    C --\u003e D[\"Check texture exists\"]\n    B --\u003e|Yes| D\n    D --\u003e E{\"texture_-\u003eisCreated()?\"}\n    E --\u003e|Yes| F[\"texture_-\u003edestroy()\"]\n    F --\u003e G[\"texture_-\u003ecreate()\"]\n    E --\u003e|No| G\n    G --\u003e H[\"texture_-\u003esetData(image)\"]\n    H --\u003e I[\"Upload complete\"]\n    \n    style H fill:#f0f0f0\n```\n\n**Diagram: Texture Upload Process**\n\nThe implementation recreates the texture on every upload to ensure proper sizing and format matching. While this could be optimized to check for size changes, the current approach prioritizes simplicity and correctness.\n\n**Sources:** [src/overlay/OverlayRenderer.cpp:96-108]()\n\n---\n\n## Rendering Execution\n\nThe `draw()` method executes the actual OpenGL rendering commands. It is called by `VisualizerWindow` after projectM has rendered its visualization, ensuring overlays appear on top.\n\n### Draw Sequence\n\n```mermaid\nsequenceDiagram\n    participant VW as \"VisualizerWindow\"\n    participant OR as \"OverlayRenderer::draw()\"\n    participant GL as \"OpenGL State\"\n    \n    VW-\u003e\u003eOR: draw()\n    activate OR\n    \n    OR-\u003e\u003eGL: glEnable(GL_BLEND)\n    OR-\u003e\u003eGL: glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)\n    \n    OR-\u003e\u003eGL: program_-\u003ebind()\n    OR-\u003e\u003eGL: glActiveTexture(GL_TEXTURE0)\n    OR-\u003e\u003eGL: texture_-\u003ebind()\n    OR-\u003e\u003eGL: setUniformValue(\"overlayTexture\", 0)\n    \n    OR-\u003e\u003eGL: vao_.bind()\n    OR-\u003e\u003eGL: glDrawArrays(GL_TRIANGLES, 0, 6)\n    OR-\u003e\u003eGL: vao_.release()\n    \n    OR-\u003e\u003eGL: texture_-\u003erelease()\n    OR-\u003e\u003eGL: program_-\u003erelease()\n    OR-\u003e\u003eGL: glDisable(GL_BLEND)\n    \n    deactivate OR\n```\n\n**Diagram: Draw Call Execution**\n\n**Sources:** [src/overlay/OverlayRenderer.cpp:110-134]()\n\n### Alpha Blending Configuration\n\nThe renderer uses standard alpha blending with the blend function:\n\n```\nfinalColor = srcColor * srcAlpha + dstColor * (1 - srcAlpha)\n```\n\nThis is configured via `glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)` and enables proper compositing of semi-transparent text over the visualization. Blending is explicitly enabled at the start of `draw()` and disabled at the end to avoid affecting other rendering operations.\n\n**Sources:** [src/overlay/OverlayRenderer.cpp:114-115, 133]()\n\n---\n\n## State Management\n\n`OverlayRenderer` follows a strict state management pattern to ensure OpenGL context safety:\n\n### Initialization Guard\n\nThe `initialized_` flag prevents redundant initialization. The `upload()` method calls `init()` automatically if needed, ensuring lazy initialization:\n\n**Sources:** [src/overlay/OverlayRenderer.cpp:10-11, 97-98]()\n\n### Context Assumptions\n\nThe class assumes:\n1. An active OpenGL context exists (provided by `VisualizerWindow`)\n2. GLEW has been initialized before first use (comment at [src/overlay/OverlayRenderer.cpp:13]())\n3. The context remains current throughout object lifetime\n\n### Resource Cleanup\n\nQt's RAII wrappers (`QOpenGLBuffer`, `QOpenGLVertexArrayObject`) and `std::unique_ptr` ensure automatic cleanup when the `OverlayRenderer` is destroyed. Explicit `destroy()` calls are only needed when recreating textures.\n\n**Sources:** [src/overlay/OverlayRenderer.hpp:36-42](), [src/overlay/OverlayRenderer.cpp:6-7]()\n\n---\n\n## Integration with OverlayEngine\n\nWhile `OverlayRenderer` handles OpenGL details, `OverlayEngine` manages the higher-level concerns of text layout, animations, and metadata formatting. The collaboration pattern is:\n\n```mermaid\ngraph TB\n    subgraph \"Frame Rendering Cycle\"\n        A[\"OverlayEngine::render()\"] --\u003e B[\"Create QImage\"]\n        B --\u003e C[\"QPainter text drawing\"]\n        C --\u003e D[\"OverlayRenderer::upload(image)\"]\n        D --\u003e E[\"Texture uploaded to GPU\"]\n    end\n    \n    subgraph \"Display Cycle\"\n        F[\"VisualizerWindow::render()\"] --\u003e G[\"ProjectMBridge::render()\"]\n        G --\u003e H[\"Base visualization FBO\"]\n        H --\u003e I[\"OverlayRenderer::draw()\"]\n        I --\u003e J[\"Composited to screen\"]\n    end\n    \n    E -.-\u003e|\"texture ready\"| I\n    \n    style D fill:#f0f0f0\n    style I fill:#f0f0f0\n```\n\n**Diagram: OverlayEngine and OverlayRenderer Collaboration**\n\nThis separation allows `OverlayEngine` to use Qt's high-level `QPainter` API for text rendering while `OverlayRenderer` focuses purely on efficient GPU texture compositing.\n\n**Sources:** [src/overlay/OverlayRenderer.hpp:2-3](), Diagram 2 from system architecture\n\n---\n\n## Performance Characteristics\n\n### Optimization Strategies\n\n| Technique | Implementation | Benefit |\n|-----------|----------------|---------|\n| **Lazy Initialization** | `init()` called on first use | Avoids setup if overlays disabled |\n| **Fullscreen Quad** | 6 vertices, no index buffer | Minimal geometry overhead |\n| **Alpha Discard** | `discard` in fragment shader | Skips blending for transparent pixels |\n| **ClampToEdge** | Texture wrap mode | Prevents edge artifacts |\n| **Linear Filtering** | Texture min/mag filter | Smooth text scaling |\n\n**Sources:** [src/overlay/OverlayRenderer.cpp:9-94, 110-134]()\n\n### Potential Bottlenecks\n\n1. **Texture Recreation**: `upload()` destroys and recreates the texture on every call. This could be optimized to only recreate when dimensions change.\n2. **CPUGPU Transfer**: Texture upload bandwidth depends on image size and format. Typically not a bottleneck for text overlays.\n3. **Overdraw**: Fullscreen quad is always drawn, even if overlay is small. Future optimization could use scissor testing.\n\n**Sources:** [src/overlay/OverlayRenderer.cpp:96-108]()\n\n---\n\n## Dependencies\n\n`OverlayRenderer` depends on the following Qt OpenGL modules:\n\n- `QOpenGLShaderProgram` - Shader compilation and program linking\n- `QOpenGLBuffer` - Vertex buffer object wrapper\n- `QOpenGLVertexArrayObject` - VAO wrapper for attribute state\n- `QOpenGLTexture` - Texture object wrapper\n- `QImage` - CPU-side image format for upload\n\nThe implementation requires OpenGL 3.3 core profile or later for VAO support.\n\n**Sources:** [src/overlay/OverlayRenderer.hpp:5-11]()\n\n---\n\n## Error Handling\n\nErrors are handled at two levels:\n\n### Initialization Errors\n\nShader compilation and linking errors are logged via `LOG_ERROR()` but do not throw exceptions. The application continues running with potentially broken overlays. Failure indicators:\n- Empty `program_` pointer\n- Shader compilation log messages in console\n\n**Sources:** [src/overlay/OverlayRenderer.cpp:42-54]()\n\n### Runtime Safety\n\nThe `draw()` method guards against uninitialized state:\n```cpp\nif (!initialized_ || !program_)\n    return;\n```\n\nThis prevents crashes if `init()` failed or was never called.\n\n**Sources:** [src/overlay/OverlayRenderer.cpp:111-112]()"])</script><script>self.__next_f.push([1,"2a:T5833,"])</script><script>self.__next_f.push([1,"# User Interface\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md)\n- [src/ui/MainWindow.cpp](src/ui/MainWindow.cpp)\n- [src/ui/MainWindow.hpp](src/ui/MainWindow.hpp)\n- [src/ui/controllers/AudioController.cpp](src/ui/controllers/AudioController.cpp)\n- [src/ui/controllers/RecordingController.cpp](src/ui/controllers/RecordingController.cpp)\n- [src/ui/controllers/VisualizerController.cpp](src/ui/controllers/VisualizerController.cpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document describes the Qt-based user interface layer of chadvis-projectm-qt, including the main window structure, controller pattern implementation, widget components, and signal routing architecture. The UI layer provides the graphical interface for all user interactions with the audio playback, visualization, recording, and Suno AI features.\n\nFor information about the underlying audio playback system, see [Audio System](#3). For visualization rendering details, see [Visualization System](#4). For recording functionality, see [Recording System](#5). For Suno AI integration specifics, see [Suno AI Integration](#8). For configuration management, see [Application \u0026 Config](#2.1).\n\n---\n\n## Architecture Overview\n\nThe user interface follows a **controller pattern** that separates presentation (widgets) from business logic (controllers) and data (engines). Controllers act as mediators between UI widgets and core engines, holding non-owning pointers to engines owned by the `Application` singleton.\n\n```mermaid\ngraph TB\n    subgraph \"MainWindow Layout\"\n        MW[\"MainWindow\u003cbr/\u003e(QMainWindow)\"]\n        CENTRAL[\"VisualizerPanel\u003cbr/\u003e(Central Widget)\"]\n        PLAYER_DOCK[\"Player Dock\u003cbr/\u003e(Bottom, Fixed)\"]\n        TOOLS_DOCK[\"Tools Dock\u003cbr/\u003e(Right, Toggleable)\"]\n        MENU[\"Menu Bar\"]\n    end\n    \n    subgraph \"Controller Layer\"\n        AC[\"AudioController\"]\n        RC[\"RecordingController\"]\n        VC[\"VisualizerController\"]\n        SC[\"SunoController\"]\n    end\n    \n    subgraph \"Widget Components\"\n        PLAYER[\"PlayerControls\"]\n        PLAYLIST[\"PlaylistView\"]\n        PRESETS[\"PresetBrowser\"]\n        RECORDING[\"RecordingControls\"]\n        OVERLAY_ED[\"OverlayEditor\"]\n        SUNO_BR[\"SunoBrowser\"]\n    end\n    \n    subgraph \"Core Engines\"\n        AE[\"AudioEngine*\"]\n        VR[\"VideoRecorder*\"]\n        PMB[\"ProjectMBridge*\"]\n        OE[\"OverlayEngine*\"]\n    end\n    \n    MW --\u003e|contains| CENTRAL\n    MW --\u003e|contains| PLAYER_DOCK\n    MW --\u003e|contains| TOOLS_DOCK\n    MW --\u003e|contains| MENU\n    \n    PLAYER_DOCK --\u003e|hosts| PLAYER\n    TOOLS_DOCK --\u003e|tabs| PLAYLIST\n    TOOLS_DOCK --\u003e|tabs| PRESETS\n    TOOLS_DOCK --\u003e|tabs| RECORDING\n    TOOLS_DOCK --\u003e|tabs| OVERLAY_ED\n    TOOLS_DOCK --\u003e|tabs| SUNO_BR\n    \n    AC --\u003e|\"setupUI()\"| PLAYER\n    AC --\u003e|\"setupUI()\"| PLAYLIST\n    RC --\u003e|\"setupUI()\"| RECORDING\n    VC --\u003e|\"setupUI()\"| PRESETS\n    SC --\u003e|\"setupUI()\"| SUNO_BR\n    \n    AC -.-\u003e|non-owning ptr| AE\n    RC -.-\u003e|non-owning ptr| VR\n    VC -.-\u003e|non-owning ptr| PMB\n    SC -.-\u003e|references| AE\n    SC -.-\u003e|references| OE\n    \n    PLAYER --\u003e|\"signals\"| AC\n    PLAYLIST --\u003e|\"signals\"| AC\n    RECORDING --\u003e|\"signals\"| RC\n    PRESETS --\u003e|\"signals\"| VC\n```\n\n**Diagram: UI Architecture and Component Relationships**\n\nSources: [src/ui/MainWindow.hpp:36-115](), [src/ui/MainWindow.cpp:36-126](), [docs/ARCHITECTURE.md:26-32]()\n\n---\n\n## MainWindow Structure\n\nThe `MainWindow` class ([src/ui/MainWindow.hpp:36-115]()) serves as the top-level orchestrator for the entire UI. It is a `QMainWindow` subclass that manages layout, docks, menus, and controller initialization.\n\n### Initialization Sequence\n\nThe constructor follows this initialization order:\n\n1. **Engine Retrieval**: Obtains non-owning pointers to engines from `Application` singleton ([src/ui/MainWindow.cpp:42-51]())\n2. **Controller Construction**: Creates controller instances with engine pointers ([src/ui/MainWindow.cpp:55-65]())\n3. **UI Setup**: Creates and arranges widget hierarchy ([src/ui/MainWindow.cpp:61]())\n4. **Menu Bar Creation**: Configures application menus ([src/ui/MainWindow.cpp:62]())\n5. **Signal Connection**: Establishes all signal/slot connections ([src/ui/MainWindow.cpp:67]())\n6. **Update Timer**: Starts 16ms timer for overlay updates ([src/ui/MainWindow.cpp:68]())\n\n```mermaid\nsequenceDiagram\n    participant APP as Application\n    participant MW as MainWindow\n    participant CTRL as Controllers\n    participant UI as Widgets\n    \n    MW-\u003e\u003eAPP: \"audioEngine()\"\n    APP--\u003e\u003eMW: \"AudioEngine*\"\n    MW-\u003e\u003eAPP: \"overlayEngine()\"\n    APP--\u003e\u003eMW: \"OverlayEngine*\"\n    MW-\u003e\u003eAPP: \"videoRecorder()\"\n    APP--\u003e\u003eMW: \"VideoRecorder*\"\n    \n    MW-\u003e\u003eCTRL: \"new AudioController(engine)\"\n    MW-\u003e\u003eCTRL: \"new RecordingController(recorder)\"\n    MW-\u003e\u003eCTRL: \"new SunoController(engines)\"\n    \n    MW-\u003e\u003eMW: \"setupUI()\"\n    MW-\u003e\u003eUI: \"create widgets\"\n    MW-\u003e\u003eCTRL: \"setupUI(widgets)\"\n    \n    MW-\u003e\u003eMW: \"setupMenuBar()\"\n    MW-\u003e\u003eMW: \"setupConnections()\"\n    MW-\u003e\u003eCTRL: \"connectSignals()\"\n```\n\n**Diagram: MainWindow Initialization Sequence**\n\nSources: [src/ui/MainWindow.cpp:36-71]()\n\n### Layout Components\n\n| Component | Type | Location | Features |\n|-----------|------|----------|----------|\n| **Central Widget** | `VisualizerPanel` | Center | Hosts `VisualizerWindow` with OpenGL context |\n| **Player Dock** | `QDockWidget` | Bottom | Fixed position, no drag handles |\n| **Tools Dock** | `QDockWidget` | Right | Toggleable via View menu, contains tabbed interface |\n| **Status Bar** | `QStatusBar` | Bottom | Displays messages and recording status |\n| **Menu Bar** | `QMenuBar` | Top | File, Playback, View, Visualizer, Recording, Tools, Help |\n\nThe player dock is configured with `NoDockWidgetFeatures` and an empty title bar widget to create a seamless, fixed control panel ([src/ui/MainWindow.cpp:95-99]()):\n\n```cpp\nauto* controlsDock = new QDockWidget(\"Player\", this);\ncontrolsDock-\u003esetWidget(playerControls_);\ncontrolsDock-\u003esetFeatures(QDockWidget::NoDockWidgetFeatures);\ncontrolsDock-\u003esetTitleBarWidget(new QWidget());\n```\n\nThe tools dock hosts a `QTabWidget` containing five tabs: Playlist, Presets, Recording, Overlay, and Suno ([src/ui/MainWindow.cpp:103-121]()). Visibility is controlled by the View menu and persisted in the configuration.\n\nSources: [src/ui/MainWindow.cpp:89-126]()\n\n### Menu Bar Structure\n\n```mermaid\ngraph LR\n    MENUBAR[\"Menu Bar\"]\n    \n    FILE[\"File Menu\"]\n    PLAYBACK[\"Playback Menu\"]\n    VIEW[\"View Menu\"]\n    VIZ[\"Visualizer Menu\"]\n    RECORD[\"Recording Menu\"]\n    TOOLS[\"Tools Menu\"]\n    HELP[\"Help Menu\"]\n    \n    MENUBAR --\u003e FILE\n    MENUBAR --\u003e PLAYBACK\n    MENUBAR --\u003e VIEW\n    MENUBAR --\u003e VIZ\n    MENUBAR --\u003e RECORD\n    MENUBAR --\u003e TOOLS\n    MENUBAR --\u003e HELP\n    \n    FILE --\u003e OPEN_FILES[\"Open Files... (Ctrl+O)\"]\n    FILE --\u003e OPEN_FOLDER[\"Open Folder... (Ctrl+Shift+O)\"]\n    FILE --\u003e SAVE_PL[\"Save Playlist...\"]\n    FILE --\u003e LOAD_PL[\"Load Playlist...\"]\n    FILE --\u003e EXIT[\"Exit (Ctrl+Q)\"]\n    \n    PLAYBACK --\u003e PLAY_PAUSE[\"Play/Pause (Space)\"]\n    PLAYBACK --\u003e STOP[\"Stop (S)\"]\n    PLAYBACK --\u003e NEXT[\"Next (N)\"]\n    PLAYBACK --\u003e PREV[\"Previous (P)\"]\n    \n    VIEW --\u003e FULLSCREEN[\"Fullscreen (F11)\"]\n    VIEW --\u003e SHOW_TOOLS[\"Show Tools (Toggle)\"]\n    \n    VIZ --\u003e NEXT_PRESET[\"Next Preset (Right)\"]\n    VIZ --\u003e PREV_PRESET[\"Previous Preset (Left)\"]\n    VIZ --\u003e RAND_PRESET[\"Random Preset (R)\"]\n    VIZ --\u003e LOCK_PRESET[\"Lock Preset (Toggle)\"]\n    VIZ --\u003e SHUFFLE[\"Shuffle Presets (Toggle)\"]\n    VIZ --\u003e AUTO_ROTATE[\"Auto-Rotate Presets (Toggle)\"]\n    \n    RECORD --\u003e START_REC[\"Start Recording (Ctrl+R)\"]\n    RECORD --\u003e STOP_REC[\"Stop Recording\"]\n    \n    TOOLS --\u003e SETTINGS[\"Settings... (Ctrl+,)\"]\n    \n    HELP --\u003e ABOUT[\"About ChadVis\"]\n```\n\n**Diagram: Menu Bar Organization and Keyboard Shortcuts**\n\nSources: [src/ui/MainWindow.cpp:128-246]()\n\n---\n\n## Controller Pattern\n\nControllers implement a **mediator pattern** that decouples UI widgets from core engines. Each controller:\n\n1. Holds **non-owning pointers** to engines (owned by `Application`)\n2. Provides `setupUI()` methods to configure widget references\n3. Implements `connectSignals()` to establish signal/slot connections\n4. Routes user actions to engine methods\n5. Updates widgets in response to engine state changes\n\n### Controller Class Hierarchy\n\n```mermaid\nclassDiagram\n    class QObject {\n        \u003c\u003cQt Base Class\u003e\u003e\n    }\n    \n    class AudioController {\n        -AudioEngine* engine_\n        -MainWindow* window_\n        -PlayerControls* controls_\n        -PlaylistView* view_\n        +setupUI(controls, view)\n        +connectSignals()\n    }\n    \n    class RecordingController {\n        -VideoRecorder* recorder_\n        -MainWindow* window_\n        -RecordingControls* controls_\n        +setupUI(controls)\n        +connectSignals()\n    }\n    \n    class VisualizerController {\n        -ProjectMBridge* bridge_\n        -MainWindow* window_\n        -VisualizerPanel* panel_\n        -PresetBrowser* browser_\n        +setupUI(panel, browser)\n        +connectSignals()\n    }\n    \n    class SunoController {\n        -AudioEngine* audioEngine_\n        -OverlayEngine* overlayEngine_\n        -SunoClient* client_\n        -SunoDatabase* database_\n        +setupUI(browser)\n        +fetchLibrary()\n        +downloadClip()\n    }\n    \n    QObject \u003c|-- AudioController\n    QObject \u003c|-- RecordingController\n    QObject \u003c|-- VisualizerController\n    QObject \u003c|-- SunoController\n```\n\n**Diagram: Controller Class Structure**\n\nSources: [src/ui/MainWindow.hpp:96-100](), [src/ui/controllers/AudioController.cpp:12-14](), [src/ui/controllers/RecordingController.cpp:15-18](), [src/ui/controllers/VisualizerController.cpp:12-15]()\n\n### AudioController\n\nThe `AudioController` ([src/ui/controllers/AudioController.cpp:12-93]()) manages the audio playback UI components:\n\n**Key Responsibilities:**\n- Binds `PlayerControls` and `PlaylistView` to `AudioEngine`\n- Routes playback commands (play, pause, stop, seek, volume)\n- Handles playlist navigation and file drops\n- Forwards PCM data to visualizer for rendering\n\n**Signal Connections:**\n\n| Widget Signal | Engine Action |\n|---------------|---------------|\n| `PlayerControls::playClicked` | `AudioEngine::play()` |\n| `PlayerControls::pauseClicked` | `AudioEngine::pause()` |\n| `PlayerControls::stopClicked` | `AudioEngine::stop()` |\n| `PlayerControls::nextClicked` | `Playlist::next()` |\n| `PlayerControls::previousClicked` | `Playlist::previous()` |\n| `PlayerControls::seekRequested` | `AudioEngine::seek()` |\n| `PlayerControls::volumeChanged` | `AudioEngine::setVolume()` |\n| `PlaylistView::trackDoubleClicked` | `Playlist::jumpTo()` |\n| `PlaylistView::filesDropped` | `MainWindow::addToPlaylist()` |\n\nThe controller also forwards PCM audio data from `AudioEngine` to the visualizer ([src/ui/controllers/AudioController.cpp:82-90]()):\n\n```cpp\nengine_-\u003epcmReceived.connect([this](const std::vector\u003cf32\u003e\u0026 pcm,\n                                    u32 frames,\n                                    u32 channels,\n                                    u32 sampleRate) {\n    if (!pcm.empty() \u0026\u0026 frames \u003e 0) {\n        window_-\u003evisualizerPanel()-\u003evisualizer()-\u003efeedAudio(\n                pcm.data(), frames, channels, sampleRate);\n    }\n});\n```\n\nSources: [src/ui/controllers/AudioController.cpp:1-93]()\n\n### RecordingController\n\nThe `RecordingController` ([src/ui/controllers/RecordingController.cpp:15-85]()) coordinates video recording operations:\n\n**Key Responsibilities:**\n- Connects `RecordingControls` to `VideoRecorder`\n- Forwards captured frames from `VisualizerWindow` to encoder\n- Submits audio samples from `AudioEngine` to encoder\n- Implements auto-stop on track change\n- Implements auto-record feature when configured\n\n**Critical Connections:**\n\nThe controller uses `Qt::DirectConnection` for frame submission to avoid queueing delays ([src/ui/controllers/RecordingController.cpp:35-45]()):\n\n```cpp\nconnect(visualizer,\n        \u0026VisualizerWindow::frameCaptured,\n        this,\n        [this](std::vector\u003cu8\u003e data, u32 w, u32 h, i64 ts) {\n            if (recorder_-\u003eisRecording()) {\n                recorder_-\u003esubmitVideoFrame(std::move(data), w, h, ts);\n            }\n        },\n        Qt::DirectConnection);\n```\n\n**Auto-Stop/Auto-Record Logic:**\n\n| Trigger | Action |\n|---------|--------|\n| `AudioEngine::trackChanged` | Stop recording, optionally start new recording after 500ms delay |\n| `AudioEngine::stateChanged` ( Stopped) | Stop recording immediately |\n\nSources: [src/ui/controllers/RecordingController.cpp:1-85]()\n\n### VisualizerController\n\nThe `VisualizerController` ([src/ui/controllers/VisualizerController.cpp:12-41]()) manages visualization settings and preset selection:\n\n**Key Responsibilities:**\n- Connects `PresetBrowser` to `PresetManager`\n- Handles preset lock toggle from `VisualizerPanel`\n- Listens to `ProjectMBridge` preset change notifications\n\nThis controller is the simplest, as most visualizer interaction is handled directly by keyboard input in `VisualizerWindow`.\n\nSources: [src/ui/controllers/VisualizerController.cpp:1-41]()\n\n### SunoController\n\nThe `SunoController` is documented in detail in [Suno AI Integration](#8). It orchestrates API communication, database persistence, and integration with audio/overlay engines.\n\n---\n\n## Widget Components\n\nWidgets are Qt-based UI components that handle user input and display. They emit signals that controllers translate into engine actions.\n\n### Widget Overview Table\n\n| Widget Class | Location | Purpose | Key Signals |\n|--------------|----------|---------|-------------|\n| **PlayerControls** | Bottom Dock | Playback control panel | `playClicked`, `pauseClicked`, `stopClicked`, `seekRequested`, `volumeChanged` |\n| **PlaylistView** | Tools Dock Tab 1 | Track list display | `trackDoubleClicked`, `filesDropped` |\n| **PresetBrowser** | Tools Dock Tab 2 | Preset selection interface | Preset selection (handled by controller) |\n| **RecordingControls** | Tools Dock Tab 3 | Recording start/stop/settings | `startRecordingRequested`, `stopRecordingRequested` |\n| **OverlayEditor** | Tools Dock Tab 4 | Text overlay configuration | `overlayChanged` |\n| **SunoBrowser** | Tools Dock Tab 5 | Suno library interface | See [Suno AI Integration](#8) |\n| **VisualizerPanel** | Central Widget | Embeds `VisualizerWindow` | `lockPresetToggled` |\n\nSources: [src/ui/MainWindow.cpp:94-114]()\n\n### PlayerControls\n\nThe `PlayerControls` widget displays playback state and provides transport controls. It receives state updates from `AudioEngine` and emits signals when buttons are clicked or sliders are moved.\n\n**State Management:**\n- Receives `AudioEngine*` pointer via `setAudioEngine()` ([src/ui/MainWindow.cpp:123]())\n- Subscribes to `AudioEngine` signals for state updates\n- Enables/disables controls based on playlist state\n\nSources: [src/ui/MainWindow.cpp:94-96](), [src/ui/controllers/AudioController.cpp:16-22]()\n\n### PlaylistView\n\nThe `PlaylistView` displays the current playlist with track metadata. It accepts file drops for adding new tracks and supports double-click to play.\n\n**Features:**\n- Receives `Playlist*` pointer via `setPlaylist()` ([src/ui/controllers/AudioController.cpp:21]())\n- Drag-and-drop support for audio files and folders\n- Current track highlighting\n- Metadata display (title, artist, duration)\n\nSources: [src/ui/MainWindow.cpp:101](), [src/ui/controllers/AudioController.cpp:54-64]()\n\n### OverlayEditor\n\nThe `OverlayEditor` allows configuration of text overlay elements. It directly references `OverlayEngine` to read and modify overlay configuration ([src/ui/MainWindow.cpp:109-111]()):\n\n```cpp\noverlayEditor_ = new OverlayEditor();\noverlayEditor_-\u003esetOverlayEngine(overlayEngine_);\n```\n\nChanges are persisted via `OverlayEngine::config().saveToAppConfig()` ([src/ui/MainWindow.cpp:271-273]()).\n\nSources: [src/ui/MainWindow.cpp:109-111](), [src/ui/MainWindow.cpp:271-273]()\n\n---\n\n## Signal Flow Architecture\n\nThe signal flow follows a unidirectional pattern: **Widget  Controller  Engine  State Update  Widget**.\n\n```mermaid\nflowchart TD\n    USER[\"User Action\u003cbr/\u003e(button click, key press)\"]\n    \n    subgraph \"Qt Event Loop\"\n        WIDGET[\"Widget\u003cbr/\u003e(emits signal)\"]\n        SLOT[\"Controller Slot\u003cbr/\u003e(lambda/method)\"]\n    end\n    \n    subgraph \"Engine Layer\"\n        ENGINE[\"Engine Method\u003cbr/\u003e(e.g., play(), seek())\"]\n        STATE[\"State Change\u003cbr/\u003e(internal)\"]\n        ENGINE_SIG[\"Engine Signal\u003cbr/\u003e(e.g., stateChanged)\"]\n    end\n    \n    subgraph \"UI Update\"\n        UPDATE_SLOT[\"Controller/MainWindow\u003cbr/\u003e(receives engine signal)\"]\n        WIDGET_UPDATE[\"Widget Update\u003cbr/\u003e(invokeMethod)\"]\n    end\n    \n    USER --\u003e WIDGET\n    WIDGET --\u003e|\"Qt Signal\"| SLOT\n    SLOT --\u003e|\"Direct Call\"| ENGINE\n    ENGINE --\u003e STATE\n    STATE --\u003e ENGINE_SIG\n    ENGINE_SIG --\u003e|\"Cross-thread Signal\"| UPDATE_SLOT\n    UPDATE_SLOT --\u003e|\"QMetaObject::invokeMethod\"| WIDGET_UPDATE\n```\n\n**Diagram: Signal Flow from User Action to UI Update**\n\n### Thread-Safe Signal Handling\n\nSince engines operate on separate threads (audio thread, recorder thread), `MainWindow` uses `QMetaObject::invokeMethod` to marshal updates back to the UI thread ([src/ui/MainWindow.cpp:255-261]()):\n\n```cpp\naudioEngine_-\u003etrackChanged.connect([this] {\n    QMetaObject::invokeMethod(this, [this] {\n        if (const auto* item = audioEngine_-\u003eplaylist().currentItem()) {\n            overlayEngine_-\u003eupdateMetadata(item-\u003emetadata);\n            updateWindowTitle();\n        }\n    });\n});\n```\n\nThis ensures all Qt widget operations occur on the main thread, preventing race conditions.\n\nSources: [src/ui/MainWindow.cpp:248-274]()\n\n### Update Loop\n\nThe `MainWindow` runs a 16ms (60 FPS) timer for continuous updates ([src/ui/MainWindow.cpp:276-286]()):\n\n```cpp\nvoid MainWindow::onUpdateLoop() {\n    overlayEngine_-\u003eupdate(0.016f);\n    const auto\u0026 spectrum = audioEngine_-\u003ecurrentSpectrum();\n    if (spectrum.beatDetected)\n        overlayEngine_-\u003eonBeat(spectrum.beatIntensity);\n}\n```\n\nThis loop:\n- Updates overlay animations\n- Processes beat detection for reactive text effects\n\nSources: [src/ui/MainWindow.cpp:276-286]()\n\n---\n\n## Dialogs\n\n### SettingsDialog\n\nThe `SettingsDialog` provides a tabbed interface for editing all application configuration. It is documented in detail in [Settings Dialog](#7.3).\n\n### File Dialogs\n\nThe application uses `QFileDialog` with `DontUseNativeDialog` option for consistency across platforms:\n\n**File Selection Dialogs:**\n\n| Operation | Method | Filters |\n|-----------|--------|---------|\n| **Open Audio Files** | `QFileDialog::ExistingFiles` | `*.mp3 *.flac *.ogg *.opus *.wav *.m4a *.aac` |\n| **Open Folder** | `QFileDialog::Directory` | N/A |\n| **Save Playlist** | `QFileDialog::getSaveFileName` | `*.m3u` |\n| **Load Playlist** | `QFileDialog::getOpenFileName` | `*.m3u *.m3u8` |\n\nAll dialogs start in `QDir::homePath()` ([src/ui/MainWindow.cpp:364-407]()).\n\nSources: [src/ui/MainWindow.cpp:364-407]()\n\n### Message Boxes\n\nThe application uses `QMessageBox` for:\n- **Recording confirmation**: When closing with active recording ([src/ui/MainWindow.cpp:427-437]())\n- **Recording errors**: When encoder initialization fails ([src/ui/MainWindow.cpp:334-337]())\n- **About dialog**: Version and credits ([src/ui/MainWindow.cpp:417-424]())\n\nSources: [src/ui/MainWindow.cpp:334-337](), [src/ui/MainWindow.cpp:417-437]()\n\n---\n\n## Event Handling\n\n### Keyboard Events\n\n`MainWindow` overrides `keyPressEvent()` to handle global keyboard shortcuts ([src/ui/MainWindow.cpp:443-451]()):\n\n```cpp\nvoid MainWindow::keyPressEvent(QKeyEvent* event) {\n    switch (event-\u003ekey()) {\n    case Qt::Key_Space:\n        audioEngine_-\u003etogglePlayPause();\n        break;\n    default:\n        QMainWindow::keyPressEvent(event);\n    }\n}\n```\n\nAdditional keyboard handling occurs in `VisualizerWindow` for preset navigation. See [VisualizerWindow](#4.1) for details.\n\nSources: [src/ui/MainWindow.cpp:443-451]()\n\n### Drag and Drop\n\nThe main window accepts file drops for adding to playlist ([src/ui/MainWindow.cpp:453-468]()):\n\n1. `dragEnterEvent()`: Accepts drop if MIME data contains URLs\n2. `dropEvent()`: Filters for local files and calls `addToPlaylist()`\n\nDropped directories are recursively scanned for audio files using `file::listFiles()` ([src/ui/MainWindow.cpp:300-311]()).\n\nSources: [src/ui/MainWindow.cpp:300-311](), [src/ui/MainWindow.cpp:453-468]()\n\n### Close Event\n\nThe `closeEvent()` override ([src/ui/MainWindow.cpp:426-441]()) implements:\n- **Recording check**: Prompts user to confirm stopping active recording\n- **Config persistence**: Calls `CONFIG.save()` to persist settings\n- **Graceful shutdown**: Allows event to proceed or cancels based on user choice\n\nSources: [src/ui/MainWindow.cpp:426-441]()\n\n---\n\n## Window Title Management\n\nThe window title dynamically reflects application state ([src/ui/MainWindow.cpp:288-298]()):\n\n| State | Title Format |\n|-------|--------------|\n| **Idle** | `ChadVis` |\n| **Playing** | `{Artist} - {Title} \\| ChadVis` |\n| **Recording** | ` {Artist} - {Title} \\| ChadVis` |\n\nThe title is updated on:\n- Track changes ([src/ui/MainWindow.cpp:255-262]())\n- Recording start/stop ([src/ui/MainWindow.cpp:339](), [src/ui/MainWindow.cpp:349]())\n\nSources: [src/ui/MainWindow.cpp:288-298]()\n\n---\n\n## Status Bar Messages\n\nThe status bar provides user feedback for operations:\n\n| Message Type | Example | Trigger |\n|--------------|---------|---------|\n| **Ready State** | `\"Ready. I use Arch btw.\"` | Application start |\n| **Recording Started** | `\"Recording started: /path/to/output.mp4\"` | `startRecording()` |\n| **Recording Stopped** | `\"Recording stopped\"` | `stopRecording()` |\n| **Files Added** | `\"Added 5 files to playlist\"` | Drag and drop |\n\nSources: [src/ui/MainWindow.cpp:70](), [src/ui/MainWindow.cpp:340-342](), [src/ui/MainWindow.cpp:350](), [src/ui/MainWindow.cpp:465-466]()\n\n---\n\n## Configuration Integration\n\nUI state is persisted via the `CONFIG` singleton:\n\n**Persisted Settings:**\n\n| Setting | Config Path | Usage |\n|---------|-------------|-------|\n| **Tools Dock Visibility** | `CONFIG.ui().showPresets`, `CONFIG.ui().showPlaylist` | Restored on startup |\n| **Preset Shuffle** | `CONFIG.visualizer().shufflePresets` | Menu checkable action state |\n| **Auto-Rotate Duration** | `CONFIG.visualizer().presetDuration` | Menu checkable action state |\n| **Window Geometry** | (Not currently persisted) | Defaults to 1400x900 |\n\nConfiguration is saved on application exit via `closeEvent()` ([src/ui/MainWindow.cpp:439]()).\n\nSources: [src/ui/MainWindow.cpp:125-126](), [src/ui/MainWindow.cpp:215-227](), [src/ui/MainWindow.cpp:439]()"])</script><script>self.__next_f.push([1,"2b:T4dda,"])</script><script>self.__next_f.push([1,"# MainWindow \u0026 Layout\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [src/ui/MainWindow.cpp](src/ui/MainWindow.cpp)\n- [src/ui/MainWindow.hpp](src/ui/MainWindow.hpp)\n\n\u003c/details\u003e\n\n\n\nThis document describes the **MainWindow** class, which serves as the top-level application window and UI orchestrator. It manages the Qt layout hierarchy, owns controller objects, holds non-owning references to engines, and coordinates user interactions through menus, docks, and dialogs.\n\nFor information about the controller pattern and signal routing, see [Controller Layer](#7.2). For settings management, see [Settings Dialog](#7.3).\n\n---\n\n## Purpose and Scope\n\nThe `MainWindow` class is responsible for:\n\n- Constructing and laying out the application's visual hierarchy\n- Owning controller objects that mediate between UI widgets and engines\n- Providing menu-based access to all application features\n- Handling window-level events (drag-and-drop, keyboard shortcuts, close confirmation)\n- Running a timer-based update loop for the overlay system\n- Managing modal dialogs (settings, about)\n\nIt does **not** contain business logicthat is delegated to controllers and engines. It does **not** own enginesthose are owned by the `Application` singleton.\n\n---\n\n## Overall Structure\n\n**MainWindow Layout Hierarchy**\n\n```mermaid\ngraph TB\n    MW[\"MainWindow\u003cbr/\u003e(QMainWindow)\"]\n    \n    subgraph Central[\"Central Widget Area\"]\n        VP[\"VisualizerPanel\u003cbr/\u003e(contains VisualizerWindow)\"]\n    end\n    \n    subgraph Bottom[\"Bottom Dock\u003cbr/\u003e(Fixed, No Features)\"]\n        PC[\"PlayerControls\u003cbr/\u003e(Play/Pause/Stop/Seek)\"]\n    end\n    \n    subgraph Right[\"Right Dock\u003cbr/\u003e(Toggleable via View menu)\"]\n        TABS[\"QTabWidget\"]\n        \n        TAB_PL[\"Playlist Tab\u003cbr/\u003e(PlaylistView)\"]\n        TAB_PR[\"Presets Tab\u003cbr/\u003e(PresetBrowser)\"]\n        TAB_RC[\"Recording Tab\u003cbr/\u003e(RecordingControls)\"]\n        TAB_OV[\"Overlay Tab\u003cbr/\u003e(OverlayEditor)\"]\n        TAB_SU[\"Suno Tab\u003cbr/\u003e(SunoBrowser)\"]\n    end\n    \n    MENU[\"Menu Bar\u003cbr/\u003e(File/Playback/View/\u003cbr/\u003eVisualizer/Recording/\u003cbr/\u003eTools/Help)\"]\n    STATUS[\"Status Bar\u003cbr/\u003e(Messages)\"]\n    \n    MW --\u003e MENU\n    MW --\u003e Central\n    MW --\u003e Bottom\n    MW --\u003e Right\n    MW --\u003e STATUS\n    \n    Bottom --\u003e PC\n    Right --\u003e TABS\n    TABS --\u003e TAB_PL\n    TABS --\u003e TAB_PR\n    TABS --\u003e TAB_RC\n    TABS --\u003e TAB_OV\n    TABS --\u003e TAB_SU\n```\n\nSources: [src/ui/MainWindow.cpp:89-126]()\n\n---\n\n## Ownership and Reference Model\n\nMainWindow follows a clear ownership pattern:\n\n| Component Type | Ownership | Access Pattern |\n|---------------|-----------|----------------|\n| **Engines** | Owned by `Application` | Non-owning raw pointers obtained via `APP-\u003eaudioEngine()`, etc. |\n| **Controllers** | Owned by `MainWindow` | `std::unique_ptr\u003c\u003e` members |\n| **UI Widgets** | Owned by `MainWindow` | Raw pointers (Qt parent-child manages lifetime) |\n| **Dock Widgets** | Owned by `MainWindow` | Raw pointers (Qt parent-child manages lifetime) |\n\n**Ownership Relationships**\n\n```mermaid\ngraph TB\n    APP[\"Application Singleton\u003cbr/\u003e(Owns Engines)\"]\n    \n    MW[\"MainWindow\u003cbr/\u003e(std::unique_ptr controllers)\"]\n    \n    subgraph Engines[\"Engines (Non-owning Pointers)\"]\n        AE[\"AudioEngine*\"]\n        OE[\"OverlayEngine*\"]\n        VR[\"VideoRecorder*\"]\n    end\n    \n    subgraph Controllers[\"Controllers (std::unique_ptr)\"]\n        AC[\"AudioController\"]\n        VC[\"VisualizerController\"]\n        RC[\"RecordingController\"]\n        SC[\"SunoController\"]\n    end\n    \n    subgraph Widgets[\"UI Widgets (Qt Parent-Child)\"]\n        VP_W[\"VisualizerPanel*\"]\n        PC_W[\"PlayerControls*\"]\n        PL_W[\"PlaylistView*\"]\n        PB_W[\"PresetBrowser*\"]\n        RC_W[\"RecordingControls*\"]\n        OV_W[\"OverlayEditor*\"]\n        SB_W[\"SunoBrowser*\"]\n    end\n    \n    APP -.-\u003e|\"get via APP-\u003e\"| AE\n    APP -.-\u003e|\"get via APP-\u003e\"| OE\n    APP -.-\u003e|\"get via APP-\u003e\"| VR\n    \n    MW --\u003e|\"owns (unique_ptr)\"| AC\n    MW --\u003e|\"owns (unique_ptr)\"| VC\n    MW --\u003e|\"owns (unique_ptr)\"| RC\n    MW --\u003e|\"owns (unique_ptr)\"| SC\n    \n    MW --\u003e|\"holds non-owning\"| AE\n    MW --\u003e|\"holds non-owning\"| OE\n    MW --\u003e|\"holds non-owning\"| VR\n    \n    MW --\u003e|\"Qt parent-child\"| VP_W\n    MW --\u003e|\"Qt parent-child\"| PC_W\n    MW --\u003e|\"Qt parent-child\"| PL_W\n    MW --\u003e|\"Qt parent-child\"| PB_W\n    MW --\u003e|\"Qt parent-child\"| RC_W\n    MW --\u003e|\"Qt parent-child\"| OV_W\n    MW --\u003e|\"Qt parent-child\"| SB_W\n    \n    AC -.-\u003e|\"references\"| AE\n    RC -.-\u003e|\"references\"| VR\n    SC -.-\u003e|\"references\"| AE\n    SC -.-\u003e|\"references\"| OE\n```\n\nSources: [src/ui/MainWindow.hpp:91-100](), [src/ui/MainWindow.cpp:42-60]()\n\n---\n\n## Layout Components\n\n### Central Widget: VisualizerPanel\n\nThe central widget is a `VisualizerPanel`, which wraps the `VisualizerWindow` (a `QWindow` with OpenGL context). This panel occupies the majority of the window space and displays the projectM visualizations.\n\n```cpp\nvisualizerPanel_ = new VisualizerPanel(this);\nvisualizerPanel_-\u003esetOverlayEngine(overlayEngine_);\nsetCentralWidget(visualizerPanel_);\n```\n\nSources: [src/ui/MainWindow.cpp:90-92]()\n\n### Player Dock (Bottom)\n\nThe player dock is **fixed** at the bottom of the window and contains `PlayerControls`. It has no dock widget features (cannot be closed, floated, or moved):\n\n```cpp\nauto* controlsDock = new QDockWidget(\"Player\", this);\ncontrolsDock-\u003esetWidget(playerControls_);\ncontrolsDock-\u003esetFeatures(QDockWidget::NoDockWidgetFeatures);\ncontrolsDock-\u003esetTitleBarWidget(new QWidget()); // Hide title bar\naddDockWidget(Qt::BottomDockWidgetArea, controlsDock);\n```\n\nThe `PlayerControls` widget provides play/pause/stop buttons, a seek slider, and volume control. It is configured by `AudioController::setupUI()`.\n\nSources: [src/ui/MainWindow.cpp:94-99](), [src/ui/MainWindow.cpp:123]()\n\n### Tools Dock (Right)\n\nThe tools dock is **toggleable** via the View menu and contains a `QTabWidget` with five tabs:\n\n| Tab Name | Widget Class | Controller | Purpose |\n|----------|-------------|------------|---------|\n| **Playlist** | `PlaylistView` | `AudioController` | Display and manage the current playlist |\n| **Presets** | `PresetBrowser` | `VisualizerController` | Browse and select projectM presets |\n| **Recording** | `RecordingControls` | `RecordingController` | Start/stop video recording |\n| **Overlay** | `OverlayEditor` | Direct connection to `OverlayEngine` | Configure text overlays |\n| **Suno** | `SunoBrowser` | `SunoController` | Browse and download Suno AI clips |\n\n```cpp\nauto* rightTabs = new QTabWidget();\nrightTabs-\u003eaddTab(playlistView_, \"Playlist\");\nrightTabs-\u003eaddTab(presetBrowser_, \"Presets\");\nrightTabs-\u003eaddTab(recordingControls_, \"Recording\");\nrightTabs-\u003eaddTab(overlayEditor_, \"Overlay\");\nrightTabs-\u003eaddTab(sunoBrowser, \"Suno\");\n\ntoolsDock_ = new QDockWidget(\"Tools\", this);\ntoolsDock_-\u003esetObjectName(\"ToolsDock\");\ntoolsDock_-\u003esetWidget(rightTabs);\naddDockWidget(Qt::RightDockWidgetArea, toolsDock_);\n```\n\nThe dock's initial visibility is determined by `CONFIG.ui().showPresets` and `CONFIG.ui().showPlaylist`. Users can toggle it via the View  Show Tools menu action.\n\nSources: [src/ui/MainWindow.cpp:103-125](), [src/ui/MainWindow.cpp:174-184]()\n\n---\n\n## Menu Bar Structure\n\nThe menu bar provides access to all major features through seven top-level menus:\n\n**Menu Structure and Keyboard Shortcuts**\n\n```mermaid\ngraph LR\n    MENU[\"Menu Bar\"]\n    \n    FILE[\"File Menu\"]\n    PLAYBACK[\"Playback Menu\"]\n    VIEW[\"View Menu\"]\n    VIZ[\"Visualizer Menu\"]\n    REC[\"Recording Menu\"]\n    TOOLS[\"Tools Menu\"]\n    HELP[\"Help Menu\"]\n    \n    MENU --\u003e FILE\n    MENU --\u003e PLAYBACK\n    MENU --\u003e VIEW\n    MENU --\u003e VIZ\n    MENU --\u003e REC\n    MENU --\u003e TOOLS\n    MENU --\u003e HELP\n    \n    FILE --\u003e F1[\"Open Files... (Ctrl+O)\"]\n    FILE --\u003e F2[\"Open Folder... (Ctrl+Shift+O)\"]\n    FILE --\u003e F3[\"Save Playlist...\"]\n    FILE --\u003e F4[\"Load Playlist...\"]\n    FILE --\u003e F5[\"Exit (Ctrl+Q)\"]\n    \n    PLAYBACK --\u003e P1[\"Play/Pause (Space)\"]\n    PLAYBACK --\u003e P2[\"Stop (S)\"]\n    PLAYBACK --\u003e P3[\"Next (N)\"]\n    PLAYBACK --\u003e P4[\"Previous (P)\"]\n    \n    VIEW --\u003e V1[\"Fullscreen (F11)\"]\n    VIEW --\u003e V2[\"Show Tools (toggle)\"]\n    \n    VIZ --\u003e VZ1[\"Next Preset (Right)\"]\n    VIZ --\u003e VZ2[\"Previous Preset (Left)\"]\n    VIZ --\u003e VZ3[\"Random Preset (R)\"]\n    VIZ --\u003e VZ4[\"Lock Preset (toggle)\"]\n    VIZ --\u003e VZ5[\"Shuffle Presets (toggle)\"]\n    VIZ --\u003e VZ6[\"Auto-Rotate Presets (toggle)\"]\n    \n    REC --\u003e R1[\"Start Recording (Ctrl+R)\"]\n    REC --\u003e R2[\"Stop Recording\"]\n    \n    TOOLS --\u003e T1[\"Settings... (Ctrl+,)\"]\n    \n    HELP --\u003e H1[\"About ChadVis\"]\n```\n\nSources: [src/ui/MainWindow.cpp:128-246]()\n\n### Menu Actions and Implementation\n\nMost menu actions are implemented as lambda functions that call methods on engines or controllers:\n\n```cpp\n// Example: Playback menu actions directly call AudioEngine\nplaybackMenu-\u003eaddAction(\n    \"\u0026Play/Pause\",\n    this,\n    [this] { audioEngine_-\u003etogglePlayPause(); },\n    QKeySequence(Qt::Key_Space));\n\n// Example: Visualizer menu actions call ProjectMBridge via VisualizerPanel\nvizMenu-\u003eaddAction(\n    \"\u0026Next Preset\",\n    this,\n    [this] { visualizerPanel_-\u003evisualizer()-\u003eprojectM().nextPreset(); },\n    QKeySequence(Qt::Key_Right));\n```\n\nToggle actions (Lock Preset, Shuffle Presets, Auto-Rotate Presets) synchronize with `CONFIG` and call `updateSettings()` on the visualizer.\n\nSources: [src/ui/MainWindow.cpp:144-227]()\n\n---\n\n## Setup Process\n\nThe MainWindow initialization follows a four-step sequence:\n\n**Initialization Sequence**\n\n```mermaid\nsequenceDiagram\n    participant Ctor as \"MainWindow Constructor\"\n    participant APP as \"Application Singleton\"\n    participant UI as \"setupUI()\"\n    participant Menu as \"setupMenuBar()\"\n    participant Conn as \"setupConnections()\"\n    participant Timer as \"setupUpdateTimer()\"\n    \n    Ctor-\u003e\u003eAPP: Get engine pointers\u003cbr/\u003e(audioEngine, overlayEngine, videoRecorder)\n    Ctor-\u003e\u003eCtor: Create controllers\u003cbr/\u003e(AudioController, RecordingController,\u003cbr/\u003eSunoController)\n    Ctor-\u003e\u003eUI: Call setupUI()\n    UI-\u003e\u003eUI: Create VisualizerPanel (central widget)\n    UI-\u003e\u003eUI: Create PlayerControls dock (bottom)\n    UI-\u003e\u003eUI: Create Tools dock (right) with tabs\n    UI-\u003e\u003eUI: Call audioController_-\u003esetupUI()\n    Ctor-\u003e\u003eMenu: Call setupMenuBar()\n    Menu-\u003e\u003eMenu: Create File/Playback/View/Visualizer/\u003cbr/\u003eRecording/Tools/Help menus\n    Ctor-\u003e\u003eCtor: Create VisualizerController\u003cbr/\u003e(after VisualizerPanel exists)\n    Ctor-\u003e\u003eConn: Call setupConnections()\n    Conn-\u003e\u003eConn: audioController_-\u003econnectSignals()\n    Conn-\u003e\u003eConn: visualizerController_-\u003esetupUI() \u0026 connectSignals()\n    Conn-\u003e\u003eConn: recordingController_-\u003esetupUI() \u0026 connectSignals()\n    Conn-\u003e\u003eConn: Connect engine signals to UI updates\n    Ctor-\u003e\u003eTimer: Call setupUpdateTimer()\n    Timer-\u003e\u003eTimer: Start 16ms QTimer for overlay updates\n```\n\nSources: [src/ui/MainWindow.cpp:36-71]()\n\n### Step 1: Obtain Engine References\n\n```cpp\n// Get engines from Application singleton\naudioEngine_ = APP-\u003eaudioEngine();\noverlayEngine_ = APP-\u003eoverlayEngine();\nvideoRecorder_ = APP-\u003evideoRecorder();\n```\n\nNull checks are performed to ensure Application is properly initialized.\n\nSources: [src/ui/MainWindow.cpp:42-51]()\n\n### Step 2: Create Controllers\n\nControllers are created with non-owning engine pointers and `this` as parent:\n\n```cpp\naudioController_ = std::make_unique\u003cAudioController\u003e(audioEngine_, this);\nrecordingController_ = std::make_unique\u003cRecordingController\u003e(videoRecorder_, this);\nsunoController_ = std::make_unique\u003csuno::SunoController\u003e(audioEngine_, overlayEngine_, this);\n```\n\nThe `VisualizerController` is created **after** `setupUI()` because it requires access to the `ProjectMBridge` instance inside `VisualizerPanel`.\n\nSources: [src/ui/MainWindow.cpp:55-65]()\n\n### Step 3: Setup UI and Menu Bar\n\n`setupUI()` creates all widgets and docks (described in [Layout Components](#layout-components)). `setupMenuBar()` populates the menu bar (described in [Menu Bar Structure](#menu-bar-structure)).\n\nSources: [src/ui/MainWindow.cpp:61-62]()\n\n### Step 4: Setup Connections\n\n`setupConnections()` delegates to controller `setupUI()` and `connectSignals()` methods, then establishes direct signal connections for:\n\n- **Track changes**: Update overlay metadata and window title\n- **Position changes**: Update overlay playback time\n- **Overlay config changes**: Save to `CONFIG`\n\n```cpp\naudioEngine_-\u003etrackChanged.connect([this] {\n    QMetaObject::invokeMethod(this, [this] {\n        if (const auto* item = audioEngine_-\u003eplaylist().currentItem()) {\n            overlayEngine_-\u003eupdateMetadata(item-\u003emetadata);\n            updateWindowTitle();\n        }\n    });\n});\n```\n\nSources: [src/ui/MainWindow.cpp:248-274]()\n\n### Step 5: Start Update Timer\n\nA `QTimer` is started with a 16ms interval (~60 FPS) to drive the overlay update loop:\n\n```cpp\nconnect(\u0026updateTimer_, \u0026QTimer::timeout, this, \u0026MainWindow::onUpdateLoop);\nupdateTimer_.start(16);\n```\n\nSources: [src/ui/MainWindow.cpp:276-279]()\n\n---\n\n## Event Handling\n\n### Drag-and-Drop\n\nMainWindow accepts file drops to add tracks to the playlist. The `dragEnterEvent()` accepts URLs, and `dropEvent()` extracts local file paths and calls `addToPlaylist()`:\n\n```cpp\nvoid MainWindow::dropEvent(QDropEvent* event) {\n    QStringList paths;\n    for (const auto\u0026 url : event-\u003emimeData()-\u003eurls())\n        if (url.isLocalFile())\n            paths.append(url.toLocalFile());\n    if (!paths.isEmpty()) {\n        for (const auto\u0026 p : paths)\n            addToPlaylist(fs::path(p.toStdString()));\n        statusBar()-\u003eshowMessage(\n            QString(\"Added %1 files to playlist\").arg(paths.size()));\n    }\n}\n```\n\nThe `addToPlaylist()` method handles both files and directories recursively.\n\nSources: [src/ui/MainWindow.cpp:453-468](), [src/ui/MainWindow.cpp:300-311]()\n\n### Keyboard Shortcuts\n\nIn addition to menu-bound shortcuts, `keyPressEvent()` provides direct handling for Space (play/pause):\n\n```cpp\nvoid MainWindow::keyPressEvent(QKeyEvent* event) {\n    switch (event-\u003ekey()) {\n    case Qt::Key_Space:\n        audioEngine_-\u003etogglePlayPause();\n        break;\n    default:\n        QMainWindow::keyPressEvent(event);\n    }\n}\n```\n\nSources: [src/ui/MainWindow.cpp:443-451]()\n\n### Close Event\n\nOn window close, MainWindow checks if recording is active and prompts the user to confirm. If confirmed (or not recording), it saves the configuration before closing:\n\n```cpp\nvoid MainWindow::closeEvent(QCloseEvent* event) {\n    if (videoRecorder_-\u003eisRecording()) {\n        auto reply = QMessageBox::question(\n            this, \"Recording Active\",\n            \"Recording in progress. Stop and exit?\",\n            QMessageBox::Yes | QMessageBox::No);\n        if (reply == QMessageBox::No) {\n            event-\u003eignore();\n            return;\n        }\n        stopRecording();\n    }\n    CONFIG.save(CONFIG.configPath());\n    event-\u003eaccept();\n}\n```\n\nSources: [src/ui/MainWindow.cpp:426-441]()\n\n---\n\n## Update Loop\n\nThe `onUpdateLoop()` slot is called every 16ms by the `updateTimer_`. It performs two tasks:\n\n1. **Update overlay animations**: Calls `overlayEngine_-\u003eupdate(0.016f)` with the delta time\n2. **Feed beat information**: If a beat is detected in the current audio spectrum, calls `overlayEngine_-\u003eonBeat()`\n\n```cpp\nvoid MainWindow::onUpdateLoop() {\n    overlayEngine_-\u003eupdate(0.016f);\n    const auto\u0026 spectrum = audioEngine_-\u003ecurrentSpectrum();\n    if (spectrum.beatDetected)\n        overlayEngine_-\u003eonBeat(spectrum.beatIntensity);\n}\n```\n\nThis loop ensures smooth text animations and beat-reactive effects in overlays.\n\nSources: [src/ui/MainWindow.cpp:281-286]()\n\n---\n\n## Dialog Management\n\n### Settings Dialog\n\nThe `SettingsDialog` is shown modally via the Tools  Settings menu action. On acceptance, it triggers `updateSettings()` on the visualizer to apply changes:\n\n```cpp\nvoid MainWindow::onShowSettings() {\n    SettingsDialog dialog(this);\n    if (dialog.exec() == QDialog::Accepted) {\n        if (visualizerPanel_ \u0026\u0026 visualizerPanel_-\u003evisualizer())\n            visualizerPanel_-\u003evisualizer()-\u003eupdateSettings();\n    }\n}\n```\n\nSee [Settings Dialog](#7.3) for details on the settings UI.\n\nSources: [src/ui/MainWindow.cpp:409-415]()\n\n### About Dialog\n\nThe About dialog displays version and build information:\n\n```cpp\nQMessageBox::about(\n    this,\n    \"About ChadVis\",\n    \"\u003ch2\u003eChadVis Audio Player\u003c/h2\u003e\u003cp\u003eVersion 1.1.0\u003c/p\u003e\"\n    \"\u003cp\u003eBuilt with Qt6, projectM v4, and Arch Linux pride.\u003c/p\u003e\u003chr\u003e\"\n    \"\u003cp\u003e\u003cb\u003e\\\"I use Arch btw\\\"\u003c/b\u003e\u003c/p\u003e\");\n```\n\nSources: [src/ui/MainWindow.cpp:417-424]()\n\n### Suno Cookie Dialog\n\nThe `SunoCookieDialog` is managed by `SunoController` and shown when authentication is required. See [SunoController \u0026 UI](#8.2) for details.\n\n---\n\n## Window Title Updates\n\nThe window title reflects the current playback state:\n\n| State | Title Format |\n|-------|--------------|\n| Idle | `\"ChadVis\"` |\n| Playing | `\"Artist - Title \\| ChadVis\"` |\n| Recording | `\" Artist - Title \\| ChadVis\"` |\n\nThe `updateWindowTitle()` method is called on track changes and recording state changes:\n\n```cpp\nvoid MainWindow::updateWindowTitle() {\n    QString title = \"ChadVis\";\n    if (const auto* item = audioEngine_-\u003eplaylist().currentItem()) {\n        title = QString::fromStdString(item-\u003emetadata.displayArtist()) + \" - \" +\n                QString::fromStdString(item-\u003emetadata.displayTitle()) + \" | \" + title;\n    }\n    if (videoRecorder_-\u003eisRecording())\n        title = \" \" + title;\n    setWindowTitle(title);\n}\n```\n\nSources: [src/ui/MainWindow.cpp:288-298]()\n\n---\n\n## Recording Control\n\nMainWindow provides `startRecording()` and `stopRecording()` methods that coordinate between `VideoRecorder` and `VisualizerWindow`:\n\n**Recording Start Sequence**\n\n```mermaid\nsequenceDiagram\n    participant UI as \"UI/Menu Action\"\n    participant MW as \"MainWindow\"\n    participant VP as \"VisualizerPanel\"\n    participant VW as \"VisualizerWindow\"\n    participant VR as \"VideoRecorder\"\n    \n    UI-\u003e\u003eMW: onStartRecording()\n    MW-\u003e\u003eMW: Generate output path\u003cbr/\u003e(if not provided)\n    MW-\u003e\u003eMW: Get EncoderSettings from CONFIG\n    MW-\u003e\u003eVW: setRecordingSize(width, height)\n    MW-\u003e\u003eVW: startRecording()\n    VW-\u003e\u003eVW: Enable frame capture via PBOs\n    MW-\u003e\u003eVR: start(settings)\n    alt Success\n        VR--\u003e\u003eMW: Result\u003cvoid\u003e (success)\n        MW-\u003e\u003eMW: updateWindowTitle() (add )\n        MW-\u003e\u003eMW: statusBar()-\u003eshowMessage(\"Recording started\")\n    else Failure\n        VR--\u003e\u003eMW: Result\u003cvoid\u003e (error)\n        MW-\u003e\u003eVW: stopRecording() (cleanup)\n        MW-\u003e\u003eMW: Show QMessageBox::critical()\n    end\n```\n\nSources: [src/ui/MainWindow.cpp:313-343](), [src/ui/MainWindow.cpp:345-352](), [src/ui/MainWindow.cpp:357-362]()\n\nThe output path is auto-generated with a timestamp if not provided:\n\n```cpp\nauto now = std::chrono::system_clock::now();\nauto time = std::chrono::system_clock::to_time_t(now);\nstd::tm tm = *std::localtime(\u0026time);\nchar buf[64];\nstd::strftime(buf, sizeof(buf), \"chadvis-projectm-qt_%Y%m%d_%H%M%S\", \u0026tm);\npath = CONFIG.recording().outputDirectory / \n       (std::string(buf) + EncoderSettings::fromConfig().containerExtension());\n```\n\nSources: [src/ui/MainWindow.cpp:316-324]()\n\n---\n\n## Summary\n\nThe `MainWindow` class serves as the UI orchestration layer, managing layout, controllers, and user interactions. It follows a clear separation of concerns:\n\n- **Layout**: Central visualizer, bottom player dock, right tools dock with tabs\n- **Ownership**: Controllers are owned (unique_ptr), engines are referenced (raw pointers from Application)\n- **Setup**: Four-phase initialization (get engines  create controllers  setup UI/menus  connect signals)\n- **Menus**: Seven top-level menus with keyboard shortcuts for all features\n- **Events**: Drag-and-drop for playlist additions, close confirmation during recording\n- **Update Loop**: 16ms timer for overlay animations and beat detection\n- **Dialogs**: Modal settings dialog, about dialog, Suno authentication dialog\n\nAll business logic is delegated to controllers and engines, keeping MainWindow focused on UI structure and coordination."])</script><script>self.__next_f.push([1,"2c:T434f,"])</script><script>self.__next_f.push([1,"# Controller Layer\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md)\n- [src/ui/controllers/AudioController.cpp](src/ui/controllers/AudioController.cpp)\n- [src/ui/controllers/RecordingController.cpp](src/ui/controllers/RecordingController.cpp)\n- [src/ui/controllers/VisualizerController.cpp](src/ui/controllers/VisualizerController.cpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThe Controller Layer implements a mediator pattern that decouples UI widgets from core engines. Controllers are responsible for signal routing, connecting user interactions to engine operations, and synchronizing state between the UI and backend systems. They hold non-owning pointers to engines (owned by `Application`) and configure UI widgets via standardized setup methods.\n\nFor information about the UI widgets themselves, see [MainWindow \u0026 Layout](#7.1). For configuration of user preferences, see [Settings Dialog](#7.3). For the Suno-specific controller, see [SunoController \u0026 UI](#8.2).\n\n**Sources:** [docs/ARCHITECTURE.md:26-32](), [src/ui/controllers/AudioController.cpp](), [src/ui/controllers/RecordingController.cpp](), [src/ui/controllers/VisualizerController.cpp]()\n\n---\n\n## Controller Pattern Architecture\n\nAll controllers follow a consistent architectural pattern designed to prevent tight coupling between UI components and engine subsystems. This pattern ensures that UI widgets never directly access engines, and engines remain unaware of the UI layer.\n\n```mermaid\ngraph TB\n    subgraph \"UI Widget Layer\"\n        PC[\"PlayerControls\u003cbr/\u003e(QWidget)\"]\n        PV[\"PlaylistView\u003cbr/\u003e(QWidget)\"]\n        RC_UI[\"RecordingControls\u003cbr/\u003e(QWidget)\"]\n        PB[\"PresetBrowser\u003cbr/\u003e(QWidget)\"]\n    end\n    \n    subgraph \"Controller Mediation Layer\"\n        AC[\"AudioController\u003cbr/\u003esetupUI()\u003cbr/\u003econnectSignals()\"]\n        REC_CTRL[\"RecordingController\u003cbr/\u003esetupUI()\u003cbr/\u003econnectSignals()\"]\n        VC[\"VisualizerController\u003cbr/\u003esetupUI()\u003cbr/\u003econnectSignals()\"]\n    end\n    \n    subgraph \"Engine Layer\"\n        AE[\"AudioEngine\u003cbr/\u003e(owned by Application)\"]\n        VR[\"VideoRecorder\u003cbr/\u003e(owned by Application)\"]\n        PMB[\"ProjectMBridge\u003cbr/\u003e(owned by VisualizerWindow)\"]\n    end\n    \n    PC --\u003e|\"signals\"| AC\n    PV --\u003e|\"signals\"| AC\n    AC -.-\u003e|\"non-owning ptr\"| AE\n    \n    RC_UI --\u003e|\"signals\"| REC_CTRL\n    REC_CTRL -.-\u003e|\"non-owning ptr\"| VR\n    \n    PB --\u003e|\"signals\"| VC\n    VC -.-\u003e|\"non-owning ptr\"| PMB\n    \n    AE -.-\u003e|\"signals\"| AC\n    VR -.-\u003e|\"signals\"| REC_CTRL\n    PMB -.-\u003e|\"signals\"| VC\n```\n\n**Diagram: Controller Mediation Pattern**\n\nThe pattern consists of three key components:\n\n| Component | Responsibility | Ownership |\n|-----------|---------------|-----------|\n| **UI Widgets** | Display state, emit user interaction signals | Owned by `MainWindow` docks/panels |\n| **Controllers** | Route signals, invoke engine methods, synchronize state | Owned by `MainWindow`, created during initialization |\n| **Engines** | Perform actual work (audio, recording, visualization) | Owned by `Application` singleton |\n\n**Sources:** [docs/ARCHITECTURE.md:26-32](), [src/ui/controllers/AudioController.cpp:12-22](), [src/ui/controllers/RecordingController.cpp:15-23]()\n\n---\n\n## Controller Interface\n\nEach controller implements two primary methods that define its lifecycle:\n\n### `setupUI()`\n\nConfigures UI widgets by passing them non-owning pointers to the engines they need to observe. This method is called during `MainWindow` initialization after all engines have been created.\n\n**Example from AudioController:**\n```cpp\nvoid AudioController::setupUI(PlayerControls* controls, PlaylistView* view) {\n    controls_ = controls;\n    view_ = view;\n    controls_-\u003esetAudioEngine(engine_);\n    view_-\u003esetPlaylist(\u0026engine_-\u003eplaylist());\n}\n```\n\n**Sources:** [src/ui/controllers/AudioController.cpp:16-22]()\n\n### `connectSignals()`\n\nEstablishes all signal-slot connections between UI widgets and engines. This method is called after `setupUI()` to ensure all components are properly initialized before signal routing begins.\n\n**Example from RecordingController:**\n```cpp\nvoid RecordingController::connectSignals() {\n    connect(controls_, \u0026RecordingControls::startRecordingRequested,\n            [this](const QString\u0026 path) { window_-\u003eonStartRecording(path); });\n    // ... additional connections\n}\n```\n\n**Sources:** [src/ui/controllers/RecordingController.cpp:25-83]()\n\n---\n\n## AudioController\n\n`AudioController` mediates between playback UI components (`PlayerControls`, `PlaylistView`) and the `AudioEngine`. It also feeds PCM data to the visualizer and manages playlist state synchronization.\n\n```mermaid\ngraph LR\n    subgraph \"UI Widgets\"\n        PC[\"PlayerControls\"]\n        PV[\"PlaylistView\"]\n    end\n    \n    subgraph \"AudioController\"\n        SETUP[\"setupUI(controls, view)\"]\n        CONNECT[\"connectSignals()\"]\n    end\n    \n    subgraph \"Engine \u0026 Data Flow\"\n        AE[\"AudioEngine\"]\n        PL[\"Playlist\"]\n        VW[\"VisualizerWindow\"]\n    end\n    \n    PC --\u003e|\"playClicked\"| CONNECT\n    PC --\u003e|\"pauseClicked\"| CONNECT\n    PC --\u003e|\"stopClicked\"| CONNECT\n    PC --\u003e|\"nextClicked\"| CONNECT\n    PC --\u003e|\"previousClicked\"| CONNECT\n    PC --\u003e|\"seekRequested\"| CONNECT\n    PC --\u003e|\"volumeChanged\"| CONNECT\n    PC --\u003e|\"shuffleToggled\"| CONNECT\n    PC --\u003e|\"repeatToggled\"| CONNECT\n    \n    PV --\u003e|\"trackDoubleClicked\"| CONNECT\n    PV --\u003e|\"filesDropped\"| CONNECT\n    \n    CONNECT --\u003e|\"play/pause/stop/seek\"| AE\n    CONNECT --\u003e|\"next/previous/jumpTo\"| PL\n    CONNECT --\u003e|\"feedAudio\"| VW\n    \n    AE --\u003e|\"pcmReceived signal\"| CONNECT\n    AE --\u003e|\"trackChanged signal\"| CONNECT\n    PL --\u003e|\"changed signal\"| CONNECT\n```\n\n**Diagram: AudioController Signal Routing**\n\n### Key Responsibilities\n\n| Signal Source | Target Action | Code Reference |\n|--------------|---------------|----------------|\n| `PlayerControls::playClicked` | `AudioEngine::play()` | [src/ui/controllers/AudioController.cpp:26-28]() |\n| `PlayerControls::pauseClicked` | `AudioEngine::pause()` | [src/ui/controllers/AudioController.cpp:29-31]() |\n| `PlayerControls::stopClicked` | `AudioEngine::stop()` | [src/ui/controllers/AudioController.cpp:32-34]() |\n| `PlayerControls::nextClicked` | `Playlist::next()` | [src/ui/controllers/AudioController.cpp:35-37]() |\n| `PlayerControls::previousClicked` | `Playlist::previous()` | [src/ui/controllers/AudioController.cpp:38-40]() |\n| `PlayerControls::seekRequested` | `AudioEngine::seek()` | [src/ui/controllers/AudioController.cpp:41-43]() |\n| `PlayerControls::volumeChanged` | `AudioEngine::setVolume()` | [src/ui/controllers/AudioController.cpp:44-46]() |\n| `PlayerControls::shuffleToggled` | `Playlist::setShuffle()` | [src/ui/controllers/AudioController.cpp:47-49]() |\n| `PlayerControls::repeatToggled` | `Playlist::setRepeatMode()` | [src/ui/controllers/AudioController.cpp:50-52]() |\n| `PlaylistView::trackDoubleClicked` | `Playlist::jumpTo()` | [src/ui/controllers/AudioController.cpp:55-57]() |\n| `PlaylistView::filesDropped` | `MainWindow::addToPlaylist()` | [src/ui/controllers/AudioController.cpp:58-64]() |\n| `AudioEngine::pcmReceived` | `VisualizerWindow::feedAudio()` | [src/ui/controllers/AudioController.cpp:82-90]() |\n| `Playlist::changed` | `PlayerControls::setControlsEnabled()` | [src/ui/controllers/AudioController.cpp:73-77]() |\n\n### PCM Data Forwarding\n\nThe controller forwards PCM audio data from the engine to the visualizer window:\n\n```cpp\nengine_-\u003epcmReceived.connect([this](const std::vector\u003cf32\u003e\u0026 pcm,\n                                    u32 frames,\n                                    u32 channels,\n                                    u32 sampleRate) {\n    if (!pcm.empty() \u0026\u0026 frames \u003e 0) {\n        window_-\u003evisualizerPanel()-\u003evisualizer()-\u003efeedAudio(\n                pcm.data(), frames, channels, sampleRate);\n    }\n});\n```\n\nThis connection is critical for real-time visualization, as it ensures audio samples flow directly from the decoder to projectM with minimal latency.\n\n**Sources:** [src/ui/controllers/AudioController.cpp]()\n\n---\n\n## RecordingController\n\n`RecordingController` manages the video recording pipeline, connecting frame capture from the `VisualizerWindow` and audio samples from the `AudioEngine` to the `VideoRecorder`. It also implements auto-recording features and automatic stop conditions.\n\n```mermaid\ngraph TB\n    subgraph \"UI \u0026 Triggers\"\n        RC_UI[\"RecordingControls\"]\n        MW[\"MainWindow\"]\n    end\n    \n    subgraph \"RecordingController\"\n        SETUP_REC[\"setupUI(controls)\"]\n        CONNECT_REC[\"connectSignals()\"]\n    end\n    \n    subgraph \"Data Sources\"\n        VW[\"VisualizerWindow\u003cbr/\u003eframeCaptured signal\"]\n        AE_PCM[\"AudioEngine\u003cbr/\u003epcmReceived signal\"]\n        AE_STATE[\"AudioEngine\u003cbr/\u003estateChanged signal\"]\n        AE_TRACK[\"AudioEngine\u003cbr/\u003etrackChanged signal\"]\n    end\n    \n    subgraph \"Recording Pipeline\"\n        VR[\"VideoRecorder\u003cbr/\u003esubmitVideoFrame()\u003cbr/\u003esubmitAudioSamples()\"]\n    end\n    \n    RC_UI --\u003e|\"startRecordingRequested\"| CONNECT_REC\n    RC_UI --\u003e|\"stopRecordingRequested\"| CONNECT_REC\n    \n    VW --\u003e|\"frameCaptured(data,w,h,ts)\"| CONNECT_REC\n    AE_PCM --\u003e|\"pcmReceived(pcm,frames,ch,sr)\"| CONNECT_REC\n    AE_STATE --\u003e|\"stateChanged(Stopped)\"| CONNECT_REC\n    AE_TRACK --\u003e|\"trackChanged\"| CONNECT_REC\n    \n    CONNECT_REC --\u003e|\"if isRecording()\"| VR\n    CONNECT_REC --\u003e|\"onStartRecording()\"| MW\n    CONNECT_REC --\u003e|\"onStopRecording()\"| MW\n```\n\n**Diagram: RecordingController Data Flow**\n\n### Key Responsibilities\n\n| Signal Source | Condition | Action | Code Reference |\n|--------------|-----------|--------|----------------|\n| `RecordingControls::startRecordingRequested` | Always | `MainWindow::onStartRecording()` | [src/ui/controllers/RecordingController.cpp:26-28]() |\n| `RecordingControls::stopRecordingRequested` | Always | `MainWindow::onStopRecording()` | [src/ui/controllers/RecordingController.cpp:30-32]() |\n| `VisualizerWindow::frameCaptured` | If recording | `VideoRecorder::submitVideoFrame()` | [src/ui/controllers/RecordingController.cpp:36-45]() |\n| `AudioEngine::pcmReceived` | If recording | `VideoRecorder::submitAudioSamples()` | [src/ui/controllers/RecordingController.cpp:48-57]() |\n| `AudioEngine::trackChanged` | If recording | Auto-stop, then auto-start if enabled | [src/ui/controllers/RecordingController.cpp:60-74]() |\n| `AudioEngine::stateChanged(Stopped)` | If recording | Auto-stop recording | [src/ui/controllers/RecordingController.cpp:77-82]() |\n\n### Frame and Audio Submission Gating\n\nThe controller uses conditional checks to gate data submission based on recording state:\n\n```cpp\nconnect(visualizer, \u0026VisualizerWindow::frameCaptured, this,\n        [this](std::vector\u003cu8\u003e data, u32 w, u32 h, i64 ts) {\n            if (recorder_-\u003eisRecording()) {\n                recorder_-\u003esubmitVideoFrame(std::move(data), w, h, ts);\n            }\n        }, Qt::DirectConnection);\n```\n\nThis prevents unnecessary frame copies and memory allocations when not recording. The `Qt::DirectConnection` ensures zero-latency submission from the OpenGL thread.\n\n### Auto-Record on Track Change\n\nWhen `CONFIG.recording().autoRecord` is enabled, the controller automatically starts recording new tracks after a 500ms delay:\n\n```cpp\nif (CONFIG.recording().autoRecord) {\n    LOG_INFO(\"Auto-record enabled, starting recording for new track.\");\n    QTimer::singleShot(500, this, [this] {\n        if (window_-\u003eaudioEngine()-\u003eisPlaying()) {\n            window_-\u003eonStartRecording(\"\");\n        }\n    });\n}\n```\n\nThe delay allows the track to stabilize before recording begins.\n\n**Sources:** [src/ui/controllers/RecordingController.cpp]()\n\n---\n\n## VisualizerController\n\n`VisualizerController` manages the preset selection and visualization settings, connecting the `PresetBrowser` UI to the `ProjectMBridge` and handling preset lock state.\n\n```mermaid\ngraph LR\n    subgraph \"UI Widgets\"\n        VP[\"VisualizerPanel\"]\n        PB_UI[\"PresetBrowser\"]\n    end\n    \n    subgraph \"VisualizerController\"\n        SETUP_VIZ[\"setupUI(panel, browser)\"]\n        CONNECT_VIZ[\"connectSignals()\"]\n    end\n    \n    subgraph \"Visualization System\"\n        PMB[\"ProjectMBridge\"]\n        PM_MGR[\"PresetManager\"]\n    end\n    \n    VP --\u003e|\"lockPresetToggled\"| CONNECT_VIZ\n    CONNECT_VIZ --\u003e|\"lockPreset(bool)\"| PMB\n    \n    PB_UI --\u003e|\"reads from\"| PM_MGR\n    \n    PMB --\u003e|\"presetChanged signal\"| CONNECT_VIZ\n    PMB --\u003e|\"presetLoading signal\"| CONNECT_VIZ\n    \n    SETUP_VIZ -.-\u003e|\"setPresetManager()\"| PB_UI\n```\n\n**Diagram: VisualizerController Connections**\n\n### Key Responsibilities\n\n| Signal Source | Action | Code Reference |\n|--------------|--------|----------------|\n| `VisualizerPanel::lockPresetToggled` | `ProjectMBridge::lockPreset()` | [src/ui/controllers/VisualizerController.cpp:27-29]() |\n| `ProjectMBridge::presetChanged` | Log preset change | [src/ui/controllers/VisualizerController.cpp:32-34]() |\n\n### Setup Phase\n\nThe controller connects the preset browser to the preset manager during initialization:\n\n```cpp\nvoid VisualizerController::setupUI(VisualizerPanel* panel,\n                                   PresetBrowser* browser) {\n    panel_ = panel;\n    browser_ = browser;\n    browser_-\u003esetPresetManager(\u0026bridge_-\u003epresets());\n}\n```\n\nThis allows the browser to directly query preset lists without going through the controller for read-only operations.\n\n**Sources:** [src/ui/controllers/VisualizerController.cpp]()\n\n---\n\n## SunoController\n\n`SunoController` is documented in detail in [SunoController \u0026 UI](#8.2). It follows the same architectural pattern but includes additional responsibilities for API communication, database persistence, and download management. The controller owns a `SunoClient` and `SunoDatabase`, manages authentication state, and integrates downloaded tracks into the `AudioEngine` playlist.\n\n**Sources:** [docs/ARCHITECTURE.md:31]()\n\n---\n\n## Controller Lifecycle\n\nControllers are instantiated and initialized by `MainWindow` during its constructor. The initialization follows a strict sequence to ensure all dependencies are available:\n\n### Initialization Sequence\n\n```mermaid\nsequenceDiagram\n    participant MW as MainWindow\n    participant AC as AudioController\n    participant RC as RecordingController\n    participant VC as VisualizerController\n    participant APP as Application\n    participant WIDGETS as UI Widgets\n    \n    MW-\u003e\u003eAPP: Get engine references\n    Note over APP: Engines already created\u003cbr/\u003eby Application::init()\n    \n    MW-\u003e\u003eAC: new AudioController(engine, this)\n    MW-\u003e\u003eRC: new RecordingController(recorder, this)\n    MW-\u003e\u003eVC: new VisualizerController(bridge, this)\n    \n    MW-\u003e\u003eWIDGETS: Create UI widgets\n    Note over WIDGETS: PlayerControls, PlaylistView,\u003cbr/\u003eRecordingControls, PresetBrowser\n    \n    MW-\u003e\u003eAC: setupUI(controls, view)\n    MW-\u003e\u003eRC: setupUI(recordControls)\n    MW-\u003e\u003eVC: setupUI(panel, browser)\n    \n    Note over MW: All components initialized,\u003cbr/\u003eready for signal routing\n    \n    MW-\u003e\u003eAC: connectSignals()\n    MW-\u003e\u003eRC: connectSignals()\n    MW-\u003e\u003eVC: connectSignals()\n    \n    Note over MW: Application ready for user interaction\n```\n\n**Diagram: Controller Initialization Sequence**\n\n### Ownership Model\n\n| Component | Owner | Lifetime |\n|-----------|-------|----------|\n| `AudioController` | `MainWindow` | Entire application lifetime |\n| `RecordingController` | `MainWindow` | Entire application lifetime |\n| `VisualizerController` | `MainWindow` | Entire application lifetime |\n| `SunoController` | `MainWindow` | Entire application lifetime |\n| Engines (AudioEngine, VideoRecorder, etc.) | `Application` | Entire application lifetime |\n| UI Widgets | `MainWindow` (via docks/panels) | Entire application lifetime |\n\nControllers use non-owning raw pointers (`AudioEngine*`, `VideoRecorder*`, etc.) to reference engines because:\n1. Engines are guaranteed to outlive controllers (both owned by long-lived parents)\n2. Controllers never transfer ownership\n3. The pointer relationships are stable and immutable after initialization\n\n**Sources:** [docs/ARCHITECTURE.md:9-32](), [src/ui/controllers/AudioController.cpp:12-14](), [src/ui/controllers/RecordingController.cpp:15-18](), [src/ui/controllers/VisualizerController.cpp:12-14]()\n\n---\n\n## Thread Safety Considerations\n\nControllers operate primarily on the Qt main thread, but they bridge data from multiple thread contexts:\n\n| Data Source | Thread Context | Connection Type | Purpose |\n|-------------|---------------|-----------------|---------|\n| UI widget signals | Main thread | `Qt::AutoConnection` (direct) | Standard UI event handling |\n| `AudioEngine::pcmReceived` | Audio thread | Custom signal-slot | PCM data forwarding |\n| `VisualizerWindow::frameCaptured` | OpenGL thread | `Qt::DirectConnection` | Zero-latency frame submission |\n| `VideoRecorder` operations | Recorder thread | Thread-safe queue | Asynchronous encoding |\n\nThe use of `Qt::DirectConnection` for frame capture is intentionalit ensures frames are submitted immediately without queueing, minimizing latency. Thread safety is maintained because the `VideoRecorder::submitVideoFrame()` method uses internal locking.\n\n**Sources:** [src/ui/controllers/RecordingController.cpp:36-45](), [src/ui/controllers/AudioController.cpp:82-90]()"])</script><script>self.__next_f.push([1,"2d:T3873,"])</script><script>self.__next_f.push([1,"# Settings Dialog\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [scripts/run_debug.sh](scripts/run_debug.sh)\n- [src/ui/SettingsDialog.cpp](src/ui/SettingsDialog.cpp)\n- [src/ui/SettingsDialog.hpp](src/ui/SettingsDialog.hpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThe `SettingsDialog` provides a centralized modal interface for editing all application configuration options. It presents settings in a tabbed layout organized by functional area (General, Audio, Visualizer, Recording, Suno) and synchronizes changes with the `Config` singleton for persistence to `config.toml`. For information about the configuration system architecture and TOML persistence, see [Application \u0026 Config](#2.1). For information about how the dialog is launched from the main UI, see [MainWindow \u0026 Layout](#7.1).\n\nSources: [src/ui/SettingsDialog.hpp:1-69](), [src/ui/SettingsDialog.cpp:1-19]()\n\n---\n\n## Dialog Architecture\n\nThe `SettingsDialog` class extends `QDialog` and uses a `QTabWidget` to organize settings into five functional categories. Each tab contains form layouts with appropriate Qt widget types (spin boxes, combo boxes, checkboxes, line edits) for editing configuration values.\n\n### Structural Overview\n\n```mermaid\ngraph TB\n    subgraph \"SettingsDialog (QDialog)\"\n        TAB_WIDGET[\"QTabWidget*\u003cbr/\u003etabWidget_\"]\n        BUTTONS[\"Dialog Buttons\u003cbr/\u003eOK / Cancel / Apply\"]\n        \n        subgraph \"General Tab\"\n            G_DEBUG[\"QCheckBox*\u003cbr/\u003edebugCheck_\"]\n            G_THEME[\"QComboBox*\u003cbr/\u003ethemeCombo_\"]\n        end\n        \n        subgraph \"Audio Tab\"\n            A_DEVICE[\"QComboBox*\u003cbr/\u003eaudioDeviceCombo_\"]\n            A_BUFFER[\"QSpinBox*\u003cbr/\u003ebufferSizeSpin_\"]\n        end\n        \n        subgraph \"Visualizer Tab\"\n            V_PRESET[\"QLineEdit*\u003cbr/\u003epresetPathEdit_\"]\n            V_WIDTH[\"QSpinBox*\u003cbr/\u003evizWidthSpin_\"]\n            V_HEIGHT[\"QSpinBox*\u003cbr/\u003evizHeightSpin_\"]\n            V_FPS[\"QSpinBox*\u003cbr/\u003evizFpsSpin_\"]\n            V_BEAT[\"QDoubleSpinBox*\u003cbr/\u003ebeatSensitivitySpin_\"]\n            V_DURATION[\"QSpinBox*\u003cbr/\u003epresetDurationSpin_\"]\n            V_AUTO[\"QCheckBox*\u003cbr/\u003eautoRotateCheck_\"]\n            V_SHUFFLE[\"QCheckBox*\u003cbr/\u003eshufflePresetsCheck_\"]\n            V_LOW[\"QCheckBox*\u003cbr/\u003elowResourceCheck_\"]\n        end\n        \n        subgraph \"Recording Tab\"\n            R_DIR[\"QLineEdit*\u003cbr/\u003eoutputDirEdit_\"]\n            R_AUTO[\"QCheckBox*\u003cbr/\u003eautoRecordCheck_\"]\n            R_CONTAINER[\"QComboBox*\u003cbr/\u003econtainerCombo_\"]\n            R_CODEC[\"QComboBox*\u003cbr/\u003evideoCodecCombo_\"]\n            R_CRF[\"QSpinBox*\u003cbr/\u003ecrfSpin_\"]\n            R_PRESET[\"QComboBox*\u003cbr/\u003eencoderPresetCombo_\"]\n        end\n        \n        subgraph \"Suno Tab\"\n            S_TOKEN[\"QLineEdit*\u003cbr/\u003esunoTokenEdit_\"]\n            S_COOKIE[\"QLineEdit*\u003cbr/\u003esunoCookieEdit_\"]\n            S_PATH[\"QLineEdit*\u003cbr/\u003esunoDownloadPathEdit_\"]\n            S_AUTO[\"QCheckBox*\u003cbr/\u003esunoAutoDownloadCheck_\"]\n            S_LYRICS[\"QCheckBox*\u003cbr/\u003esunoSaveLyricsCheck_\"]\n        end\n    end\n    \n    TAB_WIDGET --\u003e G_DEBUG\n    TAB_WIDGET --\u003e A_DEVICE\n    TAB_WIDGET --\u003e V_PRESET\n    TAB_WIDGET --\u003e R_DIR\n    TAB_WIDGET --\u003e S_TOKEN\n```\n\nSources: [src/ui/SettingsDialog.hpp:32-66](), [src/ui/SettingsDialog.cpp:21-219]()\n\n---\n\n## Settings Organization by Tab\n\n### General Tab\n\n| Setting | Widget Type | CONFIG Path | Range/Options | Notes |\n|---------|-------------|-------------|---------------|-------|\n| Debug | `QCheckBox` | `CONFIG.debug()` | boolean | Enables debug logging |\n| Theme | `QComboBox` | `CONFIG.ui().theme` | \"dark\", \"gruvbox\", \"nord\" | UI color scheme |\n\nSources: [src/ui/SettingsDialog.cpp:26-37](), [src/ui/SettingsDialog.cpp:222-223](), [src/ui/SettingsDialog.cpp:262-263]()\n\n### Audio Tab\n\n| Setting | Widget Type | CONFIG Path | Range/Options | Notes |\n|---------|-------------|-------------|---------------|-------|\n| Device | `QComboBox` | `CONFIG.audio().device` | \"default\" | Audio output device |\n| Buffer Size | `QSpinBox` | `CONFIG.audio().bufferSize` | 256-8192, step 256 | Audio buffer size in samples |\n\nSources: [src/ui/SettingsDialog.cpp:39-52](), [src/ui/SettingsDialog.cpp:225-227](), [src/ui/SettingsDialog.cpp:265-266]()\n\n### Visualizer Tab\n\n| Setting | Widget Type | CONFIG Path | Range/Options | Notes |\n|---------|-------------|-------------|---------------|-------|\n| Preset Path | `QLineEdit` + Browse | `CONFIG.visualizer().presetPath` | filesystem path | Directory containing `.milk` files |\n| Resolution Width | `QSpinBox` | `CONFIG.visualizer().width` | 640-7680 | Visualization render width |\n| Resolution Height | `QSpinBox` | `CONFIG.visualizer().height` | 480-4320 | Visualization render height |\n| FPS | `QSpinBox` | `CONFIG.visualizer().fps` | 24-144 | Target frame rate |\n| Beat Sensitivity | `QDoubleSpinBox` | `CONFIG.visualizer().beatSensitivity` | 0.1-5.0, step 0.1 | Audio beat detection threshold |\n| Preset Duration | `QSpinBox` | `CONFIG.visualizer().presetDuration` | 5-300 seconds | Time before auto-rotation |\n| Auto-rotate | `QCheckBox` | `CONFIG.visualizer().presetDuration \u003e 0` | boolean | Enable automatic preset switching |\n| Shuffle Presets | `QCheckBox` | `CONFIG.visualizer().shufflePresets` | boolean | Randomize preset order |\n| Low Resource Mode | `QCheckBox` | `CONFIG.visualizer().lowResourceMode` | boolean | Render at half resolution |\n\nSources: [src/ui/SettingsDialog.cpp:54-106](), [src/ui/SettingsDialog.cpp:229-240](), [src/ui/SettingsDialog.cpp:268-276]()\n\n### Recording Tab\n\n| Setting | Widget Type | CONFIG Path | Range/Options | Notes |\n|---------|-------------|-------------|---------------|-------|\n| Output Directory | `QLineEdit` + Browse | `CONFIG.recording().outputDirectory` | filesystem path | Video output location |\n| Auto-record | `QCheckBox` | `CONFIG.recording().autoRecord` | boolean | \"Automagical mode\" - record all tracks |\n| Container | `QComboBox` | `CONFIG.recording().container` | \"mp4\", \"mkv\", \"webm\", \"mov\" | Video container format |\n| Video Codec | `QComboBox` | `CONFIG.recording().video.codec` | \"libx264\", \"libx265\", \"libvpx-vp9\" | FFmpeg video encoder |\n| CRF (Quality) | `QSpinBox` | `CONFIG.recording().video.crf` | 0-51 | 0=lossless, 18=high, 23=default, 51=worst |\n| Encoder Preset | `QComboBox` | `CONFIG.recording().video.preset` | \"ultrafast\" to \"veryslow\" | Encoding speed/quality tradeoff |\n\nSources: [src/ui/SettingsDialog.cpp:108-157](), [src/ui/SettingsDialog.cpp:242-251](), [src/ui/SettingsDialog.cpp:278-285]()\n\n### Suno Tab\n\n| Setting | Widget Type | CONFIG Path | Range/Options | Notes |\n|---------|-------------|-------------|---------------|-------|\n| API Token | `QLineEdit` (password) | `CONFIG.suno().token` | string | Suno authentication token |\n| Cookie | `QLineEdit` (password) | `CONFIG.suno().cookie` | string | Suno session cookie |\n| Download Path | `QLineEdit` + Browse | `CONFIG.suno().downloadPath` | filesystem path | Local storage for Suno clips |\n| Auto-download | `QCheckBox` | `CONFIG.suno().autoDownload` | boolean | Download synced tracks automatically |\n| Save Lyrics | `QCheckBox` | `CONFIG.suno().saveLyrics` | boolean | Persist lyrics to database |\n\nSources: [src/ui/SettingsDialog.cpp:159-194](), [src/ui/SettingsDialog.cpp:253-258](), [src/ui/SettingsDialog.cpp:287-291]()\n\n---\n\n## Configuration Synchronization Flow\n\nThe dialog implements a bidirectional synchronization pattern with the `Config` singleton. Settings are loaded when the dialog opens and saved when the user confirms changes.\n\n### Load/Save Data Flow\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SettingsDialog\n    participant CONFIG[\"Config Singleton\"]\n    participant TOML[\"config.toml File\"]\n    \n    User-\u003e\u003eSettingsDialog: Open dialog\n    SettingsDialog-\u003e\u003eSettingsDialog: constructor()\n    SettingsDialog-\u003e\u003eSettingsDialog: setupUI()\n    Note over SettingsDialog: Create all widgets\n    SettingsDialog-\u003e\u003eSettingsDialog: loadSettings()\n    SettingsDialog-\u003e\u003eCONFIG: Read values via CONFIG macro\n    CONFIG--\u003e\u003eSettingsDialog: Current configuration\n    SettingsDialog-\u003e\u003eSettingsDialog: Populate widgets\n    \n    User-\u003e\u003eSettingsDialog: Edit settings\n    \n    alt User clicks OK\n        User-\u003e\u003eSettingsDialog: OK button\n        SettingsDialog-\u003e\u003eSettingsDialog: accept()\n        SettingsDialog-\u003e\u003eSettingsDialog: saveSettings()\n        SettingsDialog-\u003e\u003eCONFIG: Write values\n        CONFIG-\u003e\u003eTOML: CONFIG.save(CONFIG.configPath())\n        SettingsDialog--\u003e\u003eUser: Dialog closes\n    else User clicks Apply\n        User-\u003e\u003eSettingsDialog: Apply button\n        SettingsDialog-\u003e\u003eSettingsDialog: saveSettings()\n        SettingsDialog-\u003e\u003eCONFIG: Write values\n        CONFIG-\u003e\u003eTOML: CONFIG.save(CONFIG.configPath())\n        Note over SettingsDialog: Dialog remains open\n    else User clicks Cancel\n        User-\u003e\u003eSettingsDialog: Cancel button\n        SettingsDialog-\u003e\u003eSettingsDialog: reject()\n        Note over SettingsDialog: No save operation\n        SettingsDialog--\u003e\u003eUser: Dialog closes\n    end\n```\n\nSources: [src/ui/SettingsDialog.cpp:14-19](), [src/ui/SettingsDialog.cpp:221-259](), [src/ui/SettingsDialog.cpp:261-294](), [src/ui/SettingsDialog.cpp:296-303]()\n\n---\n\n## Implementation Details\n\n### Dialog Initialization\n\nThe `SettingsDialog` constructor establishes the window properties and delegates to two initialization methods:\n\n1. **`setupUI()`** [src/ui/SettingsDialog.cpp:21-219]() - Constructs the widget hierarchy, creates all form controls, and establishes signal connections for file browser buttons\n2. **`loadSettings()`** [src/ui/SettingsDialog.cpp:221-259]() - Reads values from the `Config` singleton and populates all widget states\n\n```cpp\nSettingsDialog::SettingsDialog(QWidget* parent) : QDialog(parent) {\n    setWindowTitle(\"Settings\");\n    setMinimumSize(500, 400);\n    setupUI();\n    loadSettings();\n}\n```\n\nSources: [src/ui/SettingsDialog.cpp:14-19]()\n\n### Widget Configuration and Layout\n\nEach tab uses a `QFormLayout` to organize label-widget pairs. Path selection widgets include a browse button that opens a `QFileDialog`:\n\n```cpp\nauto* presetPathLayout = new QHBoxLayout();\npresetPathEdit_ = new QLineEdit();\npresetPathLayout-\u003eaddWidget(presetPathEdit_);\nauto* browsePresetBtn = new QPushButton(\"...\");\nbrowsePresetBtn-\u003esetFixedWidth(30);\nconnect(browsePresetBtn, \u0026QPushButton::clicked, this, [this] {\n    QString dir = QFileDialog::getExistingDirectory(\n            this, \"Select Preset Directory\", presetPathEdit_-\u003etext());\n    if (!dir.isEmpty()) {\n        presetPathEdit_-\u003esetText(dir);\n    }\n});\n```\n\nThis pattern repeats for output directory [src/ui/SettingsDialog.cpp:112-125]() and Suno download path [src/ui/SettingsDialog.cpp:171-186]().\n\nSources: [src/ui/SettingsDialog.cpp:58-71]()\n\n### Configuration Loading\n\nThe `loadSettings()` method reads from the `Config` singleton via the `CONFIG` macro and sets widget states. Values are converted from C++ types (std::string, std::filesystem::path) to Qt types (QString):\n\n```cpp\nvoid SettingsDialog::loadSettings() {\n    debugCheck_-\u003esetChecked(CONFIG.debug());\n    themeCombo_-\u003esetCurrentText(QString::fromStdString(CONFIG.ui().theme));\n    \n    audioDeviceCombo_-\u003esetCurrentText(\n            QString::fromStdString(CONFIG.audio().device));\n    bufferSizeSpin_-\u003esetValue(CONFIG.audio().bufferSize);\n    \n    presetPathEdit_-\u003esetText(\n            QString::fromStdString(CONFIG.visualizer().presetPath.string()));\n    // ... continues for all settings\n}\n```\n\nSpecial handling exists for the auto-rotate checkbox: it derives its state from whether `presetDuration` is greater than zero [src/ui/SettingsDialog.cpp:238]().\n\nSources: [src/ui/SettingsDialog.cpp:221-259]()\n\n### Configuration Saving\n\nThe `saveSettings()` method performs the inverse operation, reading widget states and writing to the `Config` singleton. After updating all values in memory, it triggers persistence to disk via `CONFIG.save(CONFIG.configPath())`:\n\n```cpp\nvoid SettingsDialog::saveSettings() {\n    CONFIG.setDebug(debugCheck_-\u003eisChecked());\n    CONFIG.ui().theme = themeCombo_-\u003ecurrentText().toStdString();\n    \n    CONFIG.audio().device = audioDeviceCombo_-\u003ecurrentText().toStdString();\n    CONFIG.audio().bufferSize = bufferSizeSpin_-\u003evalue();\n    \n    CONFIG.visualizer().presetPath = presetPathEdit_-\u003etext().toStdString();\n    // ... continues for all settings\n    \n    CONFIG.save(CONFIG.configPath());  // Persist to config.toml\n}\n```\n\nThe auto-rotate logic is inverted during save: if the checkbox is unchecked, `presetDuration` is set to 0 to disable auto-rotation [src/ui/SettingsDialog.cpp:273-274]().\n\nSources: [src/ui/SettingsDialog.cpp:261-294]()\n\n### Dialog Button Behavior\n\nThe dialog provides three actions with distinct behaviors:\n\n| Button | Method | Behavior |\n|--------|--------|----------|\n| OK | `accept()` override | Calls `saveSettings()`, then `QDialog::accept()` to close with accepted state |\n| Cancel | `reject()` override | Calls `QDialog::reject()` to close without saving |\n| Apply | Connected to `saveSettings()` | Calls `saveSettings()` but leaves dialog open |\n\n```cpp\nvoid SettingsDialog::accept() {\n    saveSettings();\n    QDialog::accept();\n}\n\nvoid SettingsDialog::reject() {\n    QDialog::reject();  // No save operation\n}\n```\n\nThe Apply button is connected directly to `saveSettings()` [src/ui/SettingsDialog.cpp:211-216](), allowing users to persist changes without closing the dialog.\n\nSources: [src/ui/SettingsDialog.cpp:296-303](), [src/ui/SettingsDialog.cpp:211-216]()\n\n---\n\n## Integration with Configuration System\n\nThe `SettingsDialog` accesses the `Config` singleton exclusively through the `CONFIG` macro, which provides thread-safe access to the global configuration instance. The dialog does not own or cache configuration datait reads directly from `CONFIG` during `loadSettings()` and writes directly during `saveSettings()`.\n\n### Configuration Persistence\n\nWhen `CONFIG.save(CONFIG.configPath())` is invoked [src/ui/SettingsDialog.cpp:293](), the `Config` singleton serializes all settings to the TOML file located at `~/.config/chadvis-projectm-qt/config.toml` (or `$XDG_CONFIG_HOME/chadvis-projectm-qt/config.toml`). The configuration system uses dirty tracking to optimize writes, only persisting sections that have changed. For detailed information about the TOML persistence mechanism and configuration architecture, see [Application \u0026 Config](#2.1).\n\nSources: [src/ui/SettingsDialog.cpp:1-2](), [src/ui/SettingsDialog.cpp:293]()"])</script><script>self.__next_f.push([1,"2e:T3e05,"])</script><script>self.__next_f.push([1,"# Suno AI Integration\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [docs/suno_api_reference.md](docs/suno_api_reference.md)\n- [src/suno/SunoClient.cpp](src/suno/SunoClient.cpp)\n- [src/suno/SunoClient.hpp](src/suno/SunoClient.hpp)\n- [src/ui/SunoCookieDialog.cpp](src/ui/SunoCookieDialog.cpp)\n- [src/ui/controllers/SunoController.cpp](src/ui/controllers/SunoController.cpp)\n- [src/ui/controllers/SunoController.hpp](src/ui/controllers/SunoController.hpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose \u0026 Scope\n\nThe Suno AI Integration module provides functionality to access and manage AI-generated music from the [Suno AI platform](https://suno.com). This system allows users to browse their Suno library, download generated tracks, and display synchronized lyrics as overlays during visualization. The integration includes API communication, local database caching, authentication management, and seamless connection to the application's audio playback and overlay systems.\n\nFor details on API communication and authentication mechanisms, see [SunoClient \u0026 API](#8.1). For controller orchestration and user interface components, see [SunoController \u0026 UI](#8.2). For audio playback integration, see [Audio System](#3). For lyrics display, see [Overlay System](#6).\n\n## Architecture Overview\n\nThe Suno integration is organized into four architectural layers: Network Layer (API communication), Controller Layer (business logic), Data Layer (local persistence), and UI Layer (user interaction). The system maintains clear separation between these concerns while integrating with the application's core engines.\n\n```mermaid\ngraph TB\n    subgraph \"UI Layer\"\n        SunoBrowser[\"SunoBrowser\u003cbr/\u003e(Widget)\"]\n        SunoCookieDialog[\"SunoCookieDialog\u003cbr/\u003e(Auth Dialog)\"]\n    end\n    \n    subgraph \"Controller Layer\"\n        SunoController[\"SunoController\u003cbr/\u003e(Business Logic)\"]\n    end\n    \n    subgraph \"Network Layer\"\n        SunoClient[\"SunoClient\u003cbr/\u003e(API Client)\"]\n        QNetworkAccessManager[\"QNetworkAccessManager\u003cbr/\u003e(HTTP)\"]\n    end\n    \n    subgraph \"Data Layer\"\n        SunoDatabase[\"SunoDatabase\u003cbr/\u003e(SQLite)\"]\n        DownloadDir[\"suno_downloads/\u003cbr/\u003e(Audio Files)\"]\n    end\n    \n    subgraph \"External APIs\"\n        ClerkAPI[\"Clerk Auth API\u003cbr/\u003eauth.suno.com/v1\"]\n        SunoAPI[\"Suno Studio API\u003cbr/\u003estudio-api.prod.suno.com\"]\n    end\n    \n    subgraph \"Integration Points\"\n        AudioEngine[\"AudioEngine\u003cbr/\u003e(Playlist)\"]\n        OverlayEngine[\"OverlayEngine\u003cbr/\u003e(Lyrics)\"]\n        Config[\"Config\u003cbr/\u003e(SunoConfig)\"]\n    end\n    \n    SunoBrowser --\u003e|\"user actions\"| SunoController\n    SunoController --\u003e|\"shows on auth fail\"| SunoCookieDialog\n    SunoCookieDialog --\u003e|\"cookie input\"| SunoController\n    \n    SunoController --\u003e|\"owns\"| SunoClient\n    SunoController --\u003e|\"owns\"| SunoDatabase\n    SunoController --\u003e|\"uses\"| QNetworkAccessManager\n    \n    SunoClient --\u003e|\"JWT refresh\"| ClerkAPI\n    SunoClient --\u003e|\"fetch library/lyrics\"| SunoAPI\n    SunoClient --\u003e|\"HTTP requests\"| QNetworkAccessManager\n    \n    SunoController --\u003e|\"saveClips\"| SunoDatabase\n    SunoController --\u003e|\"saveAlignedLyrics\"| SunoDatabase\n    SunoController --\u003e|\"download to\"| DownloadDir\n    \n    SunoController --\u003e|\"add tracks\"| AudioEngine\n    SunoController --\u003e|\"pass lyrics\"| OverlayEngine\n    SunoController --\u003e|\"read/write\"| Config\n    \n    SunoClient -.-\u003e|\"libraryFetched\"| SunoController\n    SunoClient -.-\u003e|\"alignedLyricsFetched\"| SunoController\n    SunoController -.-\u003e|\"libraryUpdated\"| SunoBrowser\n```\n\n**Sources:** [src/ui/controllers/SunoController.hpp:1-74](), [src/suno/SunoClient.hpp:1-72](), [Diagram 4 from high-level architecture]()\n\n## Core Components\n\n### SunoClient\n\nThe `SunoClient` class implements the network interface to Suno AI APIs. It handles cookie-based authentication, JWT token refresh via the Clerk authentication service, and data fetching operations. The client uses Qt's `QNetworkAccessManager` for HTTP requests and emits signals for asynchronous result delivery.\n\n**Key Methods:**\n- `setToken()` / `setCookie()`: Configure authentication credentials ([src/suno/SunoClient.cpp:15-34]())\n- `refreshAuthToken()`: Two-step process to obtain JWT from Clerk API ([src/suno/SunoClient.cpp:40-125]())\n- `fetchLibrary()`: Retrieve clips from user's library ([src/suno/SunoClient.cpp:145-171]())\n- `fetchAlignedLyrics()`: Get word-level synchronized lyrics ([src/suno/SunoClient.cpp:173-200]())\n\n**Signals:**\n- `libraryFetched`: Emits `std::vector\u003cSunoClip\u003e` when library data arrives\n- `alignedLyricsFetched`: Emits clip ID and JSON string for lyrics\n- `errorOccurred`: Emits error message on failures\n\n**Sources:** [src/suno/SunoClient.hpp:1-72](), [src/suno/SunoClient.cpp:1-273]()\n\n### SunoController\n\nThe `SunoController` orchestrates all Suno-related business logic, acting as the integration point between the network layer, persistence layer, and application engines. It manages library synchronization, download operations, lyrics processing, and provides a clean API for UI components.\n\n**Key Responsibilities:**\n- Authentication flow management ([src/ui/controllers/SunoController.cpp:76-87]())\n- Library sync and database persistence ([src/ui/controllers/SunoController.cpp:89-101]())\n- Asynchronous lyrics fetching with queue management ([src/ui/controllers/SunoController.cpp:103-111]())\n- Audio file downloading to local directory ([src/ui/controllers/SunoController.cpp:167-198]())\n- Integration with `AudioEngine` playlist and `OverlayEngine` lyrics ([src/ui/controllers/SunoController.cpp:202-210]())\n\n**Signals:**\n- `libraryUpdated`: Emits clips vector when library data changes\n- `statusMessage`: Emits status/error messages for UI display\n\n**Sources:** [src/ui/controllers/SunoController.hpp:1-74](), [src/ui/controllers/SunoController.cpp:1-213]()\n\n### SunoDatabase\n\nThe `SunoDatabase` class provides SQLite-based local persistence for Suno clips and aligned lyrics. This enables offline browsing and caching of previously fetched data. The database schema includes:\n\n| Table | Purpose |\n|-------|---------|\n| `clips` | Stores `SunoClip` metadata (id, title, audio_url, image_url, status, metadata) |\n| `aligned_lyrics` | Stores word-level synchronized lyrics JSON |\n\n**Sources:** [src/ui/controllers/SunoController.cpp:40-41](), [src/ui/controllers/SunoController.cpp:91](), [Diagram 4 from high-level architecture]()\n\n### SunoCookieDialog\n\nThe `SunoCookieDialog` provides a user interface for authentication configuration. Since Suno AI does not offer a public API with standard OAuth flows, authentication requires extracting session cookies from a logged-in browser session. The dialog guides users through two methods:\n\n1. **Network Tab Method (Reliable):** Extract cookies from browser DevTools Network tab\n2. **Console Snippet Method (Quick):** Run JavaScript snippet to read `document.cookie`\n\nThe dialog includes a pre-written JavaScript snippet with copy functionality and a text area for pasting the extracted cookie string.\n\n**Sources:** [src/ui/SunoCookieDialog.cpp:1-99]()\n\n## Authentication Flow\n\nSuno AI authentication uses a cookie-based approach with JWT token refresh via Clerk's authentication service. The flow involves two distinct steps: obtaining a session ID and exchanging it for a JWT bearer token.\n\n```mermaid\nsequenceDiagram\n    participant U as \"User\"\n    participant D as \"SunoCookieDialog\"\n    participant SC as \"SunoController\"\n    participant Client as \"SunoClient\"\n    participant Clerk as \"Clerk API\u003cbr/\u003eauth.suno.com/v1\"\n    participant Suno as \"Suno API\u003cbr/\u003estudio-api.prod.suno.com\"\n    \n    U-\u003e\u003eD: \"Open dialog\"\n    U-\u003e\u003eD: \"Paste cookie string\"\n    D-\u003e\u003eSC: \"setCookie(cookie)\"\n    SC-\u003e\u003eClient: \"setCookie(cookie)\"\n    \n    Note over Client: \"Extract JWT from __session if present\"\n    \n    SC-\u003e\u003eClient: \"fetchLibrary()\"\n    \n    alt \"No JWT token yet\"\n        Client-\u003e\u003eClerk: \"GET /client?_is_native=true\u003cbr/\u003eCookie: {cookie}\"\n        Clerk--\u003e\u003eClient: \"{last_active_session_id: sid}\"\n        Note over Client: \"Store clerkSid_\"\n        \n        Client-\u003e\u003eClerk: \"POST /client/sessions/{sid}/tokens\u003cbr/\u003eCookie: {cookie}\"\n        Clerk--\u003e\u003eClient: \"{jwt: eyJ...}\"\n        Note over Client: \"Store token_\"\n    end\n    \n    Client-\u003e\u003eSuno: \"GET /feed/v2?page=1\u003cbr/\u003eAuthorization: Bearer {token}\"\n    Suno--\u003e\u003eClient: \"{clips: [...]}\"\n    Client-\u003e\u003eSC: \"libraryFetched signal\"\n```\n\n**Authentication Steps:**\n\n1. **Cookie Extraction:** User provides session cookie via `SunoCookieDialog` ([src/ui/SunoCookieDialog.cpp:87-92]())\n2. **JWT Extraction:** `SunoClient::setCookie()` attempts to extract JWT from `__session` cookie value ([src/suno/SunoClient.cpp:22-34]())\n3. **Session ID Retrieval:** If no JWT found, request Clerk API `/client` endpoint to get `last_active_session_id` ([src/suno/SunoClient.cpp:48-92]())\n4. **Token Refresh:** POST to `/client/sessions/{sid}/tokens` to obtain JWT bearer token ([src/suno/SunoClient.cpp:94-125]())\n5. **API Access:** Use JWT in `Authorization` header for all Suno API requests ([src/suno/SunoClient.cpp:127-143]())\n\n**Token Lifecycle:**\n\nThe system automatically attempts token refresh when `token_` is empty but `cookie_` is present. On 401 errors, the token is cleared to trigger refresh on the next request ([src/suno/SunoClient.cpp:261-270]()).\n\n**Sources:** [src/suno/SunoClient.cpp:40-125](), [src/suno/SunoClient.cpp:145-171](), [src/ui/SunoCookieDialog.cpp:10-97]()\n\n## Library Sync \u0026 Data Flow\n\nThe library synchronization process fetches clips from the Suno API, persists them locally, and queues aligned lyrics fetching for clips that don't have cached lyrics data. The system uses a rate-limited queue to avoid overwhelming the API.\n\n```mermaid\nflowchart TD\n    Start[\"User: Refresh Library\"] --\u003e CheckAuth{\"isAuthenticated()\"}\n    CheckAuth --\u003e|\"false\"| ShowDialog[\"showCookieDialog()\"]\n    ShowDialog --\u003e FetchLib\n    CheckAuth --\u003e|\"true\"| FetchLib[\"client_-\u003efetchLibrary()\"]\n    \n    FetchLib --\u003e API[\"Suno API\u003cbr/\u003e/feed/v2?page=1\"]\n    API --\u003e OnLibrary[\"onLibraryFetched(clips)\"]\n    \n    OnLibrary --\u003e SaveDB[\"db_.saveClips(clips)\"]\n    SaveDB --\u003e EmitSignal[\"libraryUpdated signal\"]\n    \n    OnLibrary --\u003e QueueLyrics[\"Queue lyrics for clips\u003cbr/\u003ewithout cached data\"]\n    QueueLyrics --\u003e ProcessQueue[\"processLyricsQueue()\"]\n    \n    ProcessQueue --\u003e CheckLimit{\"activeLyricsRequests\u003cbr/\u003e\u003c 5?\"}\n    CheckLimit --\u003e|\"false\"| Wait[\"Wait\"]\n    CheckLimit --\u003e|\"true\"| FetchNext[\"fetchAlignedLyrics(clipId)\"]\n    \n    FetchNext --\u003e LyricsAPI[\"Suno API\u003cbr/\u003e/gen/{id}/aligned_lyrics/v2/\"]\n    LyricsAPI --\u003e OnLyrics[\"onAlignedLyricsFetched(id, json)\"]\n    \n    OnLyrics --\u003e SaveLyricsDB[\"db_.saveAlignedLyrics(id, json)\"]\n    OnLyrics --\u003e ParseJSON[\"Parse JSON to AlignedLyrics\"]\n    ParseJSON --\u003e SetOverlay[\"overlayEngine_-\u003esetAlignedLyrics()\"]\n    OnLyrics --\u003e DecrementCount[\"activeLyricsRequests--\"]\n    DecrementCount --\u003e ProcessQueue\n```\n\n**Data Structures:**\n\n| Type | Definition | Fields |\n|------|------------|--------|\n| `SunoClip` | Represents a generated music track | `id`, `title`, `audio_url`, `image_url`, `status`, `metadata` (prompt, tags, lyrics, type) |\n| `AlignedLyrics` | Word-level synchronized lyrics | `songId`, `words` (vector of `AlignedWord`) |\n| `AlignedWord` | Individual word with timing | `word`, `start_s`, `end_s`, `score` |\n\n**Lyrics Queue Management:**\n\nThe controller maintains a `std::deque\u003cstd::string\u003e lyricsQueue_` and tracks `activeLyricsRequests_` to limit concurrent requests to 5 ([src/ui/controllers/SunoController.cpp:103-111]()). This prevents rate limiting while ensuring efficient batch processing.\n\n**Sources:** [src/ui/controllers/SunoController.cpp:60-66](), [src/ui/controllers/SunoController.cpp:89-120](), [src/suno/SunoClient.cpp:202-246]()\n\n## Download \u0026 Playback Integration\n\nWhen a user selects a clip for playback, the system downloads the audio file to a local directory, adds it to the `AudioEngine` playlist, and prepares aligned lyrics for overlay display.\n\n```mermaid\nsequenceDiagram\n    participant UI as \"SunoBrowser\"\n    participant SC as \"SunoController\"\n    participant NM as \"QNetworkAccessManager\"\n    participant FS as \"File System\u003cbr/\u003esuno_downloads/\"\n    participant AE as \"AudioEngine\"\n    participant DB as \"SunoDatabase\"\n    participant OE as \"OverlayEngine\"\n    \n    UI-\u003e\u003eSC: \"downloadAndPlay(clip)\"\n    SC-\u003e\u003eSC: \"downloadAudio(clip)\"\n    SC-\u003e\u003eNM: \"GET {clip.audio_url}\"\n    NM--\u003e\u003eSC: \"audio data\"\n    SC-\u003e\u003eFS: \"Write {title}.mp3\"\n    \n    SC-\u003e\u003eSC: \"processDownloadedFile(clip, path)\"\n    SC-\u003e\u003eAE: \"playlist().addFile(path)\"\n    \n    SC-\u003e\u003eDB: \"getAlignedLyrics(clip.id)\"\n    alt \"Lyrics cached\"\n        DB--\u003e\u003eSC: \"Ok(json)\"\n        SC-\u003e\u003eSC: \"Parse AlignedLyrics\"\n        SC-\u003e\u003eOE: \"setAlignedLyrics(lyrics)\"\n    else \"No lyrics\"\n        DB--\u003e\u003eSC: \"Err()\"\n    end\n```\n\n**Download Process:**\n\n1. **URL Request:** `downloadAudio()` creates a `QNetworkRequest` for `clip.audio_url` ([src/ui/controllers/SunoController.cpp:167-173]())\n2. **File Write:** On completion, writes response data to `{downloadDir}/{title}.mp3` ([src/ui/controllers/SunoController.cpp:183-196]())\n3. **Playlist Addition:** Calls `audioEngine_-\u003eplaylist().addFile(path)` ([src/ui/controllers/SunoController.cpp:202]())\n4. **Lyrics Lookup:** Queries database for cached aligned lyrics ([src/ui/controllers/SunoController.cpp:205-209]())\n5. **Overlay Setup:** If lyrics exist, parses JSON and passes to `OverlayEngine` ([src/ui/controllers/SunoController.cpp:147]())\n\n**Download Directory:**\n\nThe download location is configured via `SunoConfig::downloadPath` with a default of `{dataDir}/suno_downloads/` ([src/ui/controllers/SunoController.cpp:51-55]()).\n\n**Sources:** [src/ui/controllers/SunoController.cpp:159-210]()\n\n## Configuration\n\nThe Suno integration reads configuration from the `SunoConfig` structure within the global `CONFIG` singleton. Settings are persisted to `config.toml` and loaded on application startup.\n\n**Configuration Fields:**\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `token` | `std::string` | JWT bearer token (auto-refreshed) |\n| `cookie` | `std::string` | Session cookie from browser |\n| `downloadPath` | `fs::path` | Directory for downloaded audio files |\n\n**Initialization Flow:**\n\n```cpp\n// From SunoController constructor\nif (!CONFIG.suno().token.empty()) {\n    client_-\u003esetToken(CONFIG.suno().token);\n}\nif (!CONFIG.suno().cookie.empty()) {\n    client_-\u003esetCookie(CONFIG.suno().cookie);\n}\n```\n\n**Persistence:**\n\nWhen the user provides a cookie via `SunoCookieDialog`, the controller updates both the client and config:\n\n```cpp\nclient_-\u003esetCookie(cookie);\nCONFIG.suno().cookie = cookie;\nCONFIG.save(CONFIG.configPath());\n```\n\nFor detailed configuration system architecture, see [Application \u0026 Config](#2.1).\n\n**Sources:** [src/ui/controllers/SunoController.cpp:43-55](), [src/ui/controllers/SunoController.cpp:79-84]()\n\n## Integration Summary\n\nThe Suno AI Integration provides a complete feature module that extends the visualizer with AI-generated music capabilities. Key integration points:\n\n| Component | Integration Point | Purpose |\n|-----------|------------------|---------|\n| `AudioEngine` | `playlist().addFile()` | Add downloaded tracks to playback queue |\n| `OverlayEngine` | `setAlignedLyrics()` | Display synchronized lyrics during visualization |\n| `Config` | `CONFIG.suno()` | Persist authentication and settings |\n| `MainWindow` | `SunoController` lifecycle | Controller owned by main window |\n\nThe system maintains architectural independence through the controller pattern, with `SunoController` acting as the sole integration interface. UI components interact only with the controller, never directly with engines or clients.\n\n**Sources:** [src/ui/controllers/SunoController.hpp:18-32](), [src/ui/controllers/SunoController.cpp:18-26](), [Diagram 4 from high-level architecture]()"])</script><script>self.__next_f.push([1,"2f:T3b9b,"])</script><script>self.__next_f.push([1,"# SunoClient \u0026 API\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [docs/suno_api_reference.md](docs/suno_api_reference.md)\n- [src/suno/SunoClient.cpp](src/suno/SunoClient.cpp)\n- [src/suno/SunoClient.hpp](src/suno/SunoClient.hpp)\n- [src/ui/SunoCookieDialog.cpp](src/ui/SunoCookieDialog.cpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document covers the `SunoClient` class, which implements low-level HTTP communication with the Suno AI Studio API. It handles cookie-based authentication, JWT token refresh via the Clerk authentication service, library fetching, and lyrics retrieval. The client uses Qt's `QNetworkAccessManager` for asynchronous HTTP requests and emits signals for response handling.\n\nFor higher-level orchestration, database persistence, download management, and UI integration, see [SunoController \u0026 UI](#8.2).\n\n---\n\n## Class Overview\n\nThe `SunoClient` class provides a thin wrapper around Suno's unofficial REST API, encapsulating authentication workflows and data fetching operations. It operates asynchronously using Qt's signal/slot mechanism, allowing controllers to respond to API events without blocking.\n\n### Key Responsibilities\n\n| Responsibility | Implementation |\n|---|---|\n| **Authentication Management** | Stores session cookie and JWT token, refreshes tokens via Clerk API |\n| **HTTP Communication** | Uses `QNetworkAccessManager` for GET/POST requests |\n| **Data Fetching** | Retrieves library clips, aligned lyrics, and project data |\n| **Error Handling** | Detects 401 errors, clears invalid tokens, emits error signals |\n| **Signal Emission** | Notifies subscribers of fetch completions and errors |\n\n**Sources:** [src/suno/SunoClient.hpp:1-72](), [src/suno/SunoClient.cpp:1-273]()\n\n---\n\n## Architecture and Dependencies\n\n### Class Structure Diagram\n\n```mermaid\ngraph TB\n    subgraph \"SunoClient Class\"\n        SC[SunoClient\u003cbr/\u003eQObject]\n        \n        subgraph \"Private Members\"\n            MGR[\"manager_\u003cbr/\u003e(QNetworkAccessManager*)\"]\n            TOKEN[\"token_\u003cbr/\u003e(std::string)\"]\n            COOKIE[\"cookie_\u003cbr/\u003e(std::string)\"]\n            SID[\"clerkSid_\u003cbr/\u003e(std::string)\"]\n            VER[\"clerkVersion_\u003cbr/\u003e(std::string)\"]\n        end\n        \n        subgraph \"Public API\"\n            SET_TOKEN[\"setToken()\"]\n            SET_COOKIE[\"setCookie()\"]\n            IS_AUTH[\"isAuthenticated()\"]\n            REFRESH[\"refreshAuthToken()\"]\n            FETCH_LIB[\"fetchLibrary()\"]\n            FETCH_LYR[\"fetchAlignedLyrics()\"]\n        end\n        \n        subgraph \"Signals\"\n            SIG_LIB[\"libraryFetched\u003cbr/\u003eSignal\u003cvector\u003cSunoClip\u003e\u0026\u003e\"]\n            SIG_LYR[\"alignedLyricsFetched\u003cbr/\u003eSignal\u003cstring, string\u003e\"]\n            SIG_ERR[\"errorOccurred\u003cbr/\u003eSignal\u003cstring\u003e\"]\n        end\n    end\n    \n    subgraph \"Qt Framework\"\n        QNAM[QNetworkAccessManager]\n        QREPLY[QNetworkReply]\n    end\n    \n    subgraph \"External APIs\"\n        CLERK_API[\"auth.suno.com/v1\u003cbr/\u003e(Clerk Auth)\"]\n        SUNO_API[\"studio-api.prod.suno.com/api\u003cbr/\u003e(Suno Studio)\"]\n    end\n    \n    SC --\u003e MGR\n    MGR --\u003e QNAM\n    QNAM --\u003e QREPLY\n    \n    SET_TOKEN -.-\u003e|updates| TOKEN\n    SET_COOKIE -.-\u003e|updates| COOKIE\n    REFRESH --\u003e|POST| CLERK_API\n    FETCH_LIB --\u003e|GET| SUNO_API\n    FETCH_LYR --\u003e|GET| SUNO_API\n    \n    CLERK_API -.-\u003e|JWT token| TOKEN\n    SUNO_API -.-\u003e|clip data| SIG_LIB\n    SUNO_API -.-\u003e|lyrics JSON| SIG_LYR\n```\n\n**Sources:** [src/suno/SunoClient.hpp:18-69](), [src/suno/SunoClient.cpp:9-11]()\n\n---\n\n## Authentication System\n\n### Two-Tier Authentication Flow\n\nSuno's authentication uses a **cookie-based session** that provides access to the Clerk authentication API, which in turn issues JWT tokens for the Studio API. This two-step process is required because the Suno Studio API expects Bearer tokens, but users can only obtain session cookies from the web interface.\n\n#### Authentication Flow Diagram\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SunoClient\n    participant ClerkAPI as \"Clerk API\u003cbr/\u003e(auth.suno.com)\"\n    participant SunoAPI as \"Suno Studio API\"\n    \n    User-\u003e\u003eSunoClient: setCookie(cookie)\n    Note over SunoClient: Extracts __session JWT if present\u003cbr/\u003e[SunoClient.cpp:22-34]\n    \n    SunoClient-\u003e\u003eSunoClient: isAuthenticated() check\n    \n    alt No Token, Has Cookie\n        SunoClient-\u003e\u003eClerkAPI: GET /client?_is_native=true\u003cbr/\u003e(with Cookie header)\n        ClerkAPI--\u003e\u003eSunoClient: {last_active_session_id: \"...\"}\n        Note over SunoClient: Store clerkSid_\u003cbr/\u003e[SunoClient.cpp:68-72]\n        \n        SunoClient-\u003e\u003eClerkAPI: POST /client/sessions/{sid}/tokens\u003cbr/\u003e(with Cookie header)\n        ClerkAPI--\u003e\u003eSunoClient: {jwt: \"eyJ...\"}\n        Note over SunoClient: Store token_\u003cbr/\u003e[SunoClient.cpp:113]\n    end\n    \n    SunoClient-\u003e\u003eSunoAPI: GET /api/feed/v2?page=1\u003cbr/\u003e(Authorization: Bearer {token})\n    \n    alt Success\n        SunoAPI--\u003e\u003eSunoClient: {clips: [...]}\n        SunoClient-\u003e\u003eUser: libraryFetched.emitSignal(clips)\n    else 401 Unauthorized\n        SunoAPI--\u003e\u003eSunoClient: 401 Unauthorized\n        Note over SunoClient: Clear token_\u003cbr/\u003e[SunoClient.cpp:266]\n        SunoClient-\u003e\u003eUser: errorOccurred.emitSignal(\"Token expired\")\n    end\n```\n\n**Sources:** [src/suno/SunoClient.cpp:40-125](), [src/suno/SunoClient.cpp:261-270]()\n\n### Cookie Management\n\nThe `setCookie()` method accepts a raw cookie string (typically containing `__client=...` and/or `__session=...`) and attempts to extract a JWT token if the `__session` value starts with `eyJ` (indicating a JWT):\n\n```\nCookie format: \"__client=eyJ...; __session=eyJ...; _ga=...\"\nIf __session starts with \"eyJ\", extract as token_\n```\n\n**Implementation:** [src/suno/SunoClient.cpp:19-34]()\n\n### Clerk API Token Refresh\n\nThe `refreshAuthToken()` method implements a two-step process:\n\n1. **Step 1:** Fetch the Clerk Session ID (`clerkSid_`) by calling `/client?_is_native=true\u0026_clerk_js_version={version}` with the cookie\n2. **Step 2:** Use the session ID to POST to `/client/sessions/{sid}/tokens` and retrieve the JWT token\n\nBoth steps require the original session cookie in the `Cookie` header and a browser-like `User-Agent` to avoid detection.\n\n**Implementation:** [src/suno/SunoClient.cpp:40-125]()\n\n---\n\n## API Methods\n\n### Library Fetching\n\n#### `fetchLibrary(int page)`\n\nRetrieves the user's music library from the Suno Studio API feed endpoint. The method:\n\n1. Checks authentication status via `isAuthenticated()`\n2. Refreshes the token if needed (when `token_` is empty but `cookie_` exists)\n3. Constructs a GET request to `/feed/v2?page={page}`\n4. Emits `libraryFetched` signal with a `vector\u003cSunoClip\u003e` on success\n\n##### Library Response Parsing\n\nThe API can return clips in three different JSON structures:\n\n| Structure | Example | Extraction Logic |\n|---|---|---|\n| **Direct Array** | `[{...}, {...}]` | Use array directly |\n| **Object with \"clips\"** | `{\"clips\": [{...}]}` | Extract `doc.object()[\"clips\"]` |\n| **Object with \"project_clips\"** | `{\"project_clips\": [{\"clip\": {...}}]}` | Extract nested `item.toObject()[\"clip\"]` |\n\nEach clip is parsed into a `SunoClip` struct with fields: `id`, `title`, `audio_url`, `image_url`, `status`, and nested `metadata` (prompt, tags, lyrics, type).\n\n**Implementation:** [src/suno/SunoClient.cpp:145-171](), [src/suno/SunoClient.cpp:202-246]()\n\n#### API Call Pattern Diagram\n\n```mermaid\nflowchart TD\n    START[\"fetchLibrary(page)\"]\n    CHECK_AUTH{\"isAuthenticated()\"}\n    CHECK_TOKEN{\"token_.empty()?\"}\n    REFRESH[\"refreshAuthToken(callback)\"]\n    PROCEED[\"Lambda: proceed()\"]\n    CREATE_REQ[\"createRequest(/feed/v2?page=N)\"]\n    GET[\"manager_-\u003eget(request)\"]\n    CONNECT[\"connect(reply, finished, onLibraryReply)\"]\n    PARSE[\"Parse JSON response\"]\n    EXTRACT[\"Extract clips from array/object\"]\n    SIGNAL[\"libraryFetched.emitSignal(clips)\"]\n    ERROR[\"errorOccurred.emitSignal(msg)\"]\n    \n    START --\u003e CHECK_AUTH\n    CHECK_AUTH --\u003e|false| ERROR\n    CHECK_AUTH --\u003e|true| CHECK_TOKEN\n    CHECK_TOKEN --\u003e|true \u0026 has cookie| REFRESH\n    CHECK_TOKEN --\u003e|false| PROCEED\n    REFRESH --\u003e|success| PROCEED\n    REFRESH --\u003e|failure| ERROR\n    PROCEED --\u003e CREATE_REQ\n    CREATE_REQ --\u003e GET\n    GET --\u003e CONNECT\n    CONNECT --\u003e PARSE\n    PARSE --\u003e EXTRACT\n    EXTRACT --\u003e SIGNAL\n```\n\n**Sources:** [src/suno/SunoClient.cpp:145-171](), [src/suno/SunoClient.cpp:202-246]()\n\n### Aligned Lyrics Fetching\n\n#### `fetchAlignedLyrics(const std::string\u0026 clipId)`\n\nRetrieves time-aligned lyrics for a specific clip. The endpoint `/gen/{clipId}/aligned_lyrics/v2/` returns JSON with word-level timestamps for karaoke-style synchronization.\n\nThe method follows the same token refresh pattern as `fetchLibrary()` and emits `alignedLyricsFetched(clipId, jsonString)` on success. The raw JSON string is passed to subscribers for parsing.\n\n**Implementation:** [src/suno/SunoClient.cpp:173-200]()\n\n---\n\n## Request Construction\n\nThe `createRequest()` helper method generates `QNetworkRequest` objects with proper authentication headers:\n\n```\nHeaders:\n- Authorization: Bearer {token_}  (if token exists)\n- Cookie: {cookie_}                (if cookie exists)\n- User-Agent: Mozilla/5.0 ...      (always)\n```\n\nThis ensures all API calls include the necessary credentials. The `User-Agent` header is criticalSuno's API may reject requests without a browser-like signature.\n\n**Implementation:** [src/suno/SunoClient.cpp:127-143]()\n\n---\n\n## Signal-Based Communication\n\n### Signal Definitions\n\nThe client uses custom `Signal\u003cT\u003e` templates (see util/Signal.hpp) for type-safe, asynchronous event notification:\n\n| Signal | Signature | Emitted When |\n|---|---|---|\n| `libraryFetched` | `Signal\u003cconst vector\u003cSunoClip\u003e\u0026\u003e` | Library data successfully parsed |\n| `alignedLyricsFetched` | `Signal\u003cstring, string\u003e` | Lyrics JSON fetched (clipId, json) |\n| `errorOccurred` | `Signal\u003cstring\u003e` | Network error or authentication failure |\n| `projectsFetched` | `Signal\u003cconst vector\u003cSunoProject\u003e\u0026\u003e` | *(Skeleton implementation)* |\n\n### Signal Emission Flow\n\n```mermaid\ngraph LR\n    subgraph \"API Response Path\"\n        REPLY[QNetworkReply\u003cbr/\u003efinished signal]\n        SLOT[onLibraryReply slot]\n        PARSE[Parse JSON\u003cbr/\u003eto SunoClip vector]\n        EMIT[\"libraryFetched.emitSignal(clips)\"]\n    end\n    \n    subgraph \"Subscriber (e.g. SunoController)\"\n        CONNECT[\"libraryFetched.connect(lambda)\"]\n        HANDLER[Update database\u003cbr/\u003eUpdate UI]\n    end\n    \n    REPLY --\u003e SLOT\n    SLOT --\u003e PARSE\n    PARSE --\u003e EMIT\n    EMIT -.-\u003e|async delivery| HANDLER\n    CONNECT -.-\u003e|registration| EMIT\n```\n\n**Sources:** [src/suno/SunoClient.hpp:48-51](), [src/suno/SunoClient.cpp:245]()\n\n---\n\n## Error Handling\n\n### Network Error Processing\n\nThe `handleNetworkError()` method processes `QNetworkReply` errors:\n\n1. **401 Unauthorized Detection:** Checks HTTP status code and clears `token_` to force refresh on next call\n2. **Error Message Extraction:** Converts `QNetworkReply::errorString()` to std::string\n3. **Signal Emission:** Emits `errorOccurred` signal with descriptive message\n4. **Logging:** Writes error to application log via `LOG_ERROR` macro\n\n#### Error Handling Logic\n\n```\nif (statusCode == 401) {\n    message = \"Unauthorized: Token expired or invalid\"\n    token_.clear()  // Force refresh on next API call\n}\nemit errorOccurred(message)\nLOG_ERROR(\"SunoClient API Error: {}\", message)\n```\n\n**Implementation:** [src/suno/SunoClient.cpp:261-270]()\n\n### Callback-Based Error Propagation\n\nThe `refreshAuthToken()` method uses an optional callback parameter to report success/failure:\n\n```cpp\nrefreshAuthToken([](bool success) {\n    if (!success) {\n        // Handle authentication failure\n    }\n});\n```\n\nThis allows chained operations (e.g., refresh token  fetch library) to abort gracefully on authentication failure.\n\n**Implementation:** [src/suno/SunoClient.cpp:40-45](), [src/suno/SunoClient.cpp:161-167]()\n\n---\n\n## API Endpoints Reference\n\n### Clerk Authentication API\n\n| Endpoint | Method | Purpose | Response |\n|---|---|---|---|\n| `/client?_is_native=true\u0026_clerk_js_version={ver}` | GET | Retrieve session ID | `{response: {last_active_session_id: \"...\"}}` |\n| `/client/sessions/{sid}/tokens` | POST | Exchange session for JWT | `{jwt: \"eyJ...\"}` |\n\n**Base URL:** `https://auth.suno.com/v1`\n\n### Suno Studio API\n\n| Endpoint | Method | Purpose | Response |\n|---|---|---|---|\n| `/feed/v2?page={n}` | GET | Fetch library clips | Array of SunoClip objects or `{clips: [...]}` |\n| `/gen/{clipId}/aligned_lyrics/v2/` | GET | Fetch time-aligned lyrics | JSON with word timestamps |\n\n**Base URL:** `https://studio-api.prod.suno.com/api`\n\n**Sources:** [src/suno/SunoClient.hpp:67-68](), [docs/suno_api_reference.md:1-29]()\n\n---\n\n## Integration with Qt Network Layer\n\n### QNetworkAccessManager Lifecycle\n\nThe `SunoClient` owns a single `QNetworkAccessManager` instance created in the constructor:\n\n```cpp\nSunoClient::SunoClient(QObject* parent)\n    : QObject(parent), manager_(new QNetworkAccessManager(this)) {}\n```\n\nPassing `this` as the parent ensures automatic cleanup when the `SunoClient` is destroyed. All network requests are issued through this manager instance.\n\n### Asynchronous Reply Handling\n\nNetwork replies are handled asynchronously using Qt's signal/slot mechanism:\n\n1. Call `manager_-\u003eget()` or `manager_-\u003epost()` to initiate request\n2. Connect reply's `finished` signal to a lambda or slot\n3. Mark reply for deletion with `reply-\u003edeleteLater()` to prevent memory leaks\n4. Process response data or errors in the connected handler\n\n**Example Pattern:**\n```cpp\nQNetworkReply* reply = manager_-\u003eget(request);\nconnect(reply, \u0026QNetworkReply::finished, this, [this, reply]() {\n    reply-\u003edeleteLater();\n    // Process response\n});\n```\n\n**Sources:** [src/suno/SunoClient.cpp:9-11](), [src/suno/SunoClient.cpp:153-158]()\n\n---\n\n## Cookie Input UI\n\nThe `SunoCookieDialog` provides a user-friendly interface for obtaining session cookies from users. It displays two methods:\n\n### Method 1: Network Tab (Reliable)\nInstructions guide users to capture the full `Cookie` header from browser DevTools Network tab by filtering for `__clerk_api_version` requests.\n\n### Method 2: Console Snippet (Quick)\nProvides a JavaScript snippet that can be pasted into the browser console to extract `document.cookie`. This method may fail if cookies are marked `HttpOnly`.\n\nThe dialog includes a \"Copy Snippet\" button and a text area for pasting the captured cookie string.\n\n**Implementation:** [src/ui/SunoCookieDialog.cpp:1-99]()\n\n---\n\n## Summary\n\nThe `SunoClient` class provides a clean abstraction over Suno's unofficial API, handling the complex two-tier authentication flow and providing type-safe signal-based communication for API responses. Key design principles include:\n\n- **Asynchronous by Default:** All network operations use Qt's non-blocking signal/slot mechanism\n- **Automatic Token Refresh:** Seamlessly obtains new JWT tokens when needed\n- **Error Recovery:** Clears invalid tokens on 401 errors to trigger automatic refresh\n- **Type Safety:** Uses `Signal\u003cT\u003e` templates and structured `SunoClip`/`SunoProject` types\n- **Separation of Concerns:** Focuses solely on HTTP communication; persistence and orchestration handled by `SunoController`\n\n**Sources:** [src/suno/SunoClient.hpp:1-72](), [src/suno/SunoClient.cpp:1-273]()"])</script><script>self.__next_f.push([1,"30:T45df,"])</script><script>self.__next_f.push([1,"# SunoController \u0026 UI\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [src/ui/SunoBrowser.cpp](src/ui/SunoBrowser.cpp)\n- [src/ui/SunoBrowser.hpp](src/ui/SunoBrowser.hpp)\n- [src/ui/controllers/SunoController.cpp](src/ui/controllers/SunoController.cpp)\n- [src/ui/controllers/SunoController.hpp](src/ui/controllers/SunoController.hpp)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document covers the **SunoController** business logic layer and **SunoBrowser** UI widget, which together provide the user-facing interface for Suno AI music integration. The controller orchestrates library syncing, clip downloading, lyrics fetching, and integration with the main application's audio and overlay systems.\n\nFor low-level API communication details, see [SunoClient \u0026 API](#8.1). For general Suno integration architecture, see [Suno AI Integration](#8).\n\n---\n\n## Overview\n\nThe Suno integration UI follows the application's controller pattern:\n\n- **SunoController** acts as the orchestration layer, coordinating between `SunoClient`, `SunoDatabase`, `AudioEngine`, and `OverlayEngine`\n- **SunoBrowser** provides the Qt widget interface for browsing and selecting clips\n- **SunoCookieDialog** handles authentication when needed\n\nThe controller manages the complete lifecycle: authentication  library fetch  database persistence  lyrics download  audio download  playlist integration.\n\n**Sources:** [src/ui/controllers/SunoController.hpp:1-74](), [src/ui/SunoBrowser.hpp:1-46]()\n\n---\n\n## SunoController Architecture\n\n### Class Structure and Dependencies\n\n```mermaid\ngraph TB\n    subgraph \"SunoController [QObject]\"\n        CTRL[SunoController]\n        CLIENT[unique_ptr\u0026lt;SunoClient\u0026gt;]\n        DB[SunoDatabase db_]\n        NM[QNetworkAccessManager*]\n        QUEUE[deque\u0026lt;string\u0026gt; lyricsQueue_]\n    end\n    \n    subgraph \"Non-Owning References\"\n        AE[AudioEngine*\u003cbr/\u003eaudioEngine_]\n        OE[OverlayEngine*\u003cbr/\u003eoverlayEngine_]\n        MW[MainWindow*\u003cbr/\u003ewindow_]\n    end\n    \n    subgraph \"UI Components\"\n        BROWSER[SunoBrowser]\n        COOKIE[SunoCookieDialog]\n    end\n    \n    subgraph \"Signals\"\n        LIB_SIG[\"Signal\u0026lt;vector\u0026lt;SunoClip\u0026gt;\u0026amp;\u0026gt;\u003cbr/\u003elibraryUpdated\"]\n        STATUS_SIG[\"Signal\u0026lt;string\u0026amp;\u0026gt;\u003cbr/\u003estatusMessage\"]\n    end\n    \n    subgraph \"File System\"\n        DOWNLOAD_DIR[\"downloadDir_\u003cbr/\u003eCONFIG.suno().downloadPath\"]\n    end\n    \n    CTRL --\u003e CLIENT\n    CTRL --\u003e DB\n    CTRL --\u003e NM\n    CTRL --\u003e QUEUE\n    \n    CTRL -.-\u003e|\"non-owning\"| AE\n    CTRL -.-\u003e|\"non-owning\"| OE\n    CTRL -.-\u003e|\"non-owning\"| MW\n    \n    CTRL --\u003e|\"emits\"| LIB_SIG\n    CTRL --\u003e|\"emits\"| STATUS_SIG\n    \n    BROWSER --\u003e|\"calls methods\"| CTRL\n    BROWSER --\u003e|\"listens to\"| LIB_SIG\n    BROWSER --\u003e|\"listens to\"| STATUS_SIG\n    \n    CTRL --\u003e|\"shows on auth\"| COOKIE\n    \n    CTRL --\u003e|\"downloads to\"| DOWNLOAD_DIR\n    CTRL --\u003e|\"adds tracks\"| AE\n    CTRL --\u003e|\"passes lyrics\"| OE\n    \n    CLIENT -.-\u003e|\"signals\"| CTRL\n```\n\n**Sources:** [src/ui/controllers/SunoController.hpp:26-73](), [src/ui/controllers/SunoController.cpp:18-56]()\n\n### Constructor Initialization\n\nThe `SunoController` constructor performs extensive initialization:\n\n| Component | Initialization |\n|-----------|----------------|\n| **SunoClient** | Created as `unique_ptr`, signals connected to controller slots |\n| **SunoDatabase** | Initialized with path `dataDir()/suno_library.db` |\n| **QNetworkAccessManager** | Created for HTTP downloads (separate from SunoClient's manager) |\n| **Download Directory** | Read from `CONFIG.suno().downloadPath`, defaults to `dataDir()/suno_downloads` |\n| **Authentication** | Token and cookie loaded from `CONFIG.suno()` and passed to client |\n\n**Signal Connections:**\n- `client_-\u003elibraryFetched`  `onLibraryFetched()`\n- `client_-\u003ealignedLyricsFetched`  `onAlignedLyricsFetched()`\n- `client_-\u003eerrorOccurred`  `onError()`\n\n**Sources:** [src/ui/controllers/SunoController.cpp:18-56]()\n\n---\n\n## Authentication and Library Sync\n\n### Authentication Flow\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Browser as \"SunoBrowser\"\n    participant Ctrl as \"SunoController\"\n    participant Dialog as \"SunoCookieDialog\"\n    participant Client as \"SunoClient\"\n    participant Config as \"CONFIG\"\n    \n    User-\u003e\u003eBrowser: Click \"Authenticate / Sync\"\n    Browser-\u003e\u003eCtrl: syncDatabase(forceAuth=true)\n    Ctrl-\u003e\u003eDialog: new SunoCookieDialog()\n    Dialog-\u003e\u003eUser: Show cookie input\n    User-\u003e\u003eDialog: Enter cookie\n    Dialog-\u003e\u003eCtrl: getCookie()\n    Ctrl-\u003e\u003eClient: setCookie(cookie)\n    Ctrl-\u003e\u003eConfig: CONFIG.suno().cookie = cookie\n    Ctrl-\u003e\u003eConfig: CONFIG.save()\n    Ctrl-\u003e\u003eClient: fetchLibrary()\n    Client--\u003e\u003eCtrl: libraryFetched signal\n    Ctrl-\u003e\u003eCtrl: onLibraryFetched()\n```\n\nThe authentication flow is triggered in two scenarios:\n1. **User-initiated:** Clicking \"Authenticate / Sync\" button calls `syncDatabase(forceAuth=true)`\n2. **Auto-triggered:** Calling `refreshLibrary()` when `!client_-\u003eisAuthenticated()` shows the dialog\n\n**Sources:** [src/ui/controllers/SunoController.cpp:60-87]()\n\n### Library Sync Workflow\n\n```mermaid\nflowchart TD\n    START[\"refreshLibrary()\"] --\u003e CHECK{\"client_-\u003eisAuthenticated()\"}\n    CHECK --\u003e|\"false\"| SHOW[\"showCookieDialog()\"]\n    CHECK --\u003e|\"true\"| FETCH[\"client_-\u003efetchLibrary()\"]\n    \n    SHOW --\u003e DIALOG[\"SunoCookieDialog.exec()\"]\n    DIALOG --\u003e ACCEPTED{\"Accepted?\"}\n    ACCEPTED --\u003e|\"yes\"| SAVE[\"setCookie()\u003cbr/\u003eSave to CONFIG\"]\n    ACCEPTED --\u003e|\"no\"| END\n    SAVE --\u003e FETCH\n    \n    FETCH --\u003e SIGNAL[\"client emits\u003cbr/\u003elibraryFetched\"]\n    SIGNAL --\u003e HANDLER[\"onLibraryFetched(clips)\"]\n    \n    HANDLER --\u003e DB_SAVE[\"db_.saveClips(clips)\"]\n    DB_SAVE --\u003e EMIT[\"libraryUpdated.emitSignal(clips)\"]\n    EMIT --\u003e QUEUE_LYRICS[\"Queue lyrics for clips\u003cbr/\u003ewithout aligned_lyrics\"]\n    QUEUE_LYRICS --\u003e PROCESS[\"processLyricsQueue()\"]\n    \n    PROCESS --\u003e END[\"END\"]\n```\n\n**Key Methods:**\n\n- **`refreshLibrary()`** [src/ui/controllers/SunoController.cpp:60-66]() - Entry point, checks authentication\n- **`syncDatabase(bool forceAuth)`** [src/ui/controllers/SunoController.cpp:68-74]() - Wrapper that optionally forces auth dialog\n- **`showCookieDialog()`** [src/ui/controllers/SunoController.cpp:76-87]() - Displays modal dialog, saves cookie to config\n- **`onLibraryFetched()`** [src/ui/controllers/SunoController.cpp:89-101]() - Saves clips to database, queues lyrics\n\n**Sources:** [src/ui/controllers/SunoController.cpp:60-101]()\n\n---\n\n## Lyrics Fetching with Queue Management\n\n### Concurrency Control\n\nThe controller implements a queue-based system to fetch aligned lyrics with a **concurrency limit of 5 requests**:\n\n```mermaid\nstateDiagram-v2\n    [*] --\u003e Idle\n    \n    Idle --\u003e CheckQueue: processLyricsQueue()\n    \n    CheckQueue --\u003e CheckConcurrency: lyricsQueue_ not empty\n    CheckQueue --\u003e Idle: queue empty\n    \n    CheckConcurrency --\u003e FetchLyrics: activeLyricsRequests_ \u003c 5\n    CheckConcurrency --\u003e Idle: limit reached\n    \n    FetchLyrics --\u003e InFlight: activeLyricsRequests_++\u003cbr/\u003eclient_-\u003efetchAlignedLyrics(id)\n    \n    InFlight --\u003e OnSuccess: alignedLyricsFetched signal\n    InFlight --\u003e OnError: errorOccurred signal\n    \n    OnSuccess --\u003e SaveDB: db_.saveAlignedLyrics()\n    OnError --\u003e LogError: LOG_ERROR()\n    \n    SaveDB --\u003e UpdateOverlay: Parse JSON\u003cbr/\u003eoverlayEngine_-\u003esetAlignedLyrics()\n    \n    UpdateOverlay --\u003e Decrement: activeLyricsRequests_--\n    LogError --\u003e Decrement\n    \n    Decrement --\u003e CheckQueue: processLyricsQueue()\n```\n\n**Implementation Details:**\n\n| Component | Purpose |\n|-----------|---------|\n| `lyricsQueue_` | `std::deque\u003cstd::string\u003e` of clip IDs needing lyrics |\n| `activeLyricsRequests_` | Counter for in-flight requests (max 5) |\n| `processLyricsQueue()` | Starts new requests while under limit |\n| `onAlignedLyricsFetched()` | Handles success, decrements counter, processes queue |\n| `onError()` | Handles failure, decrements counter, processes queue |\n\n**Sources:** [src/ui/controllers/SunoController.cpp:103-149]()\n\n### Lyrics Processing\n\nWhen lyrics arrive, the controller:\n\n1. **Decrements the active request counter** and processes more from queue\n2. **Saves raw JSON to database** via `db_.saveAlignedLyrics(clipId, json)`\n3. **Parses the JSON** to extract aligned words with timestamps\n4. **Passes to OverlayEngine** via `overlayEngine_-\u003esetAlignedLyrics(lyrics)`\n\nThe JSON parsing handles two formats:\n- **Array format:** Direct array of word objects\n- **Object format:** `{\"words\": [...]}` or `{\"aligned_words\": [...]}`\n\nEach word object is parsed into an `AlignedWord` struct:\n\n```cpp\nw.word = obj[\"word\"].toString()\nw.start_s = obj[\"start_s\"].toDouble(obj[\"start\"].toDouble())\nw.end_s = obj[\"end_s\"].toDouble(obj[\"end\"].toDouble())\nw.score = obj[\"p_align\"].toDouble(obj[\"score\"].toDouble())\n```\n\n**Sources:** [src/ui/controllers/SunoController.cpp:113-149]()\n\n---\n\n## Download and Playlist Integration\n\n### Download Flow\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Browser as \"SunoBrowser\"\n    participant Ctrl as \"SunoController\"\n    participant NM as \"QNetworkAccessManager\"\n    participant FS as \"File System\"\n    participant AE as \"AudioEngine\"\n    participant DB as \"SunoDatabase\"\n    participant OE as \"OverlayEngine\"\n    \n    User-\u003e\u003eBrowser: Double-click clip\n    Browser-\u003e\u003eCtrl: downloadAndPlay(clip)\n    Ctrl-\u003e\u003eCtrl: downloadAudio(clip)\n    Ctrl-\u003e\u003eNM: get(clip.audio_url)\n    \n    NM--\u003e\u003eCtrl: finished signal\n    Ctrl-\u003e\u003eFS: Write to downloadDir_/title.mp3\n    Ctrl-\u003e\u003eCtrl: processDownloadedFile(clip, path)\n    Ctrl-\u003e\u003eAE: playlist().addFile(path)\n    Ctrl-\u003e\u003eDB: getAlignedLyrics(clip.id)\n    \n    alt Lyrics available\n        DB--\u003e\u003eCtrl: lyricsJson\n        Ctrl-\u003e\u003eOE: setAlignedLyrics(lyrics)\n    end\n```\n\n**File Path Generation:**\n\nThe controller constructs the download path as:\n```cpp\nQString fileName = QString::fromStdString(clip.title).replace(\" \", \"_\") + \".mp3\";\nfs::path filePath = downloadDir_ / fileName.toStdString();\n```\n\nThis replaces spaces with underscores and appends `.mp3` extension.\n\n**Sources:** [src/ui/controllers/SunoController.cpp:159-210]()\n\n### Post-Download Integration\n\nAfter successful download, `processDownloadedFile()` [src/ui/controllers/SunoController.cpp:200-210]():\n\n1. **Adds file to playlist** via `audioEngine_-\u003eplaylist().addFile(path)`\n2. **Checks for cached lyrics** via `db_.getAlignedLyrics(clip.id)`\n3. **Loads lyrics if available** (TODO comment suggests overlay integration)\n\nThis creates a seamless experience where downloaded tracks are immediately playable with synchronized lyrics.\n\n**Sources:** [src/ui/controllers/SunoController.cpp:200-210]()\n\n---\n\n## SunoBrowser Widget\n\n### UI Layout Structure\n\n```mermaid\ngraph TB\n    subgraph \"SunoBrowser [QWidget]\"\n        LAYOUT[QVBoxLayout]\n        \n        subgraph \"Top Bar [QHBoxLayout]\"\n            SEARCH[QLineEdit searchEdit_\u003cbr/\u003e'Search Suno...']\n            REFRESH[QPushButton refreshBtn_\u003cbr/\u003e'Refresh']\n            SYNC[QPushButton syncBtn_\u003cbr/\u003e'Authenticate / Sync']\n        end\n        \n        LIST[QListWidget clipList_\u003cbr/\u003eDisplays SunoClip titles]\n        STATUS[QLabel statusLabel_\u003cbr/\u003e'Arch Linux (btw)']\n    end\n    \n    LAYOUT --\u003e SEARCH\n    LAYOUT --\u003e REFRESH\n    LAYOUT --\u003e SYNC\n    LAYOUT --\u003e LIST\n    LAYOUT --\u003e STATUS\n```\n\n**Widget Inventory:**\n\n| Widget | Type | Purpose |\n|--------|------|---------|\n| `searchEdit_` | `QLineEdit` | Search box (placeholder only, not implemented) |\n| `refreshBtn_` | `QPushButton` | Triggers `controller_-\u003erefreshLibrary()` |\n| `syncBtn_` | `QPushButton` | Triggers `controller_-\u003esyncDatabase(true)` |\n| `clipList_` | `QListWidget` | Displays clip titles, stores clip ID in `Qt::UserRole` |\n| `statusLabel_` | `QLabel` | Shows status messages (default: \"Arch Linux (btw)\") |\n\n**Sources:** [src/ui/SunoBrowser.cpp:26-57]()\n\n### Signal Connections\n\n#### Button Connections\n\n```cpp\nconnect(refreshBtn_, \u0026QPushButton::clicked, this, \u0026SunoBrowser::onRefreshClicked);\nconnect(syncBtn_, \u0026QPushButton::clicked, this, \u0026SunoBrowser::onSyncClicked);\nconnect(clipList_, \u0026QListWidget::itemDoubleClicked, this, \u0026SunoBrowser::onItemDoubleClicked);\n```\n\n**Sources:** [src/ui/SunoBrowser.cpp:48-56]()\n\n#### Controller Signal Connections\n\nThe browser connects to controller signals using lambda wrappers with `QMetaObject::invokeMethod()` for thread safety:\n\n```cpp\ncontroller_-\u003elibraryUpdated.connect([this](const auto\u0026 clips) {\n    QMetaObject::invokeMethod(this, [this, clips] { updateList(clips); });\n});\n\ncontroller_-\u003estatusMessage.connect([this](const auto\u0026 msg) {\n    QMetaObject::invokeMethod(this, [this, msg] {\n        statusLabel_-\u003esetText(QString::fromStdString(msg));\n    });\n});\n```\n\nThe `QMetaObject::invokeMethod()` wrapper ensures UI updates happen on the main thread, even if signals are emitted from worker threads.\n\n**Sources:** [src/ui/SunoBrowser.cpp:13-21]()\n\n### User Interactions\n\n```mermaid\nflowchart LR\n    REFRESH[\"Click 'Refresh'\"] --\u003e SET_STATUS[\"statusLabel_ = 'Fetching...'\"]\n    SET_STATUS --\u003e CALL_REFRESH[\"controller_-\u003erefreshLibrary()\"]\n    \n    SYNC[\"Click 'Authenticate / Sync'\"] --\u003e SET_AUTH[\"statusLabel_ = 'Opening Auth Dialog...'\"]\n    SET_AUTH --\u003e CALL_SYNC[\"controller_-\u003esyncDatabase(true)\"]\n    \n    DOUBLE[\"Double-click clip\"] --\u003e FIND_ID[\"Get clip.id from Qt::UserRole\"]\n    FIND_ID --\u003e SEARCH[\"Search currentClips_ vector\"]\n    SEARCH --\u003e DOWNLOAD[\"controller_-\u003edownloadAndPlay(clip)\"]\n```\n\n**Slot Implementations:**\n\n- **`onRefreshClicked()`** [src/ui/SunoBrowser.cpp:59-62]() - Updates status, calls `refreshLibrary()`\n- **`onSyncClicked()`** [src/ui/SunoBrowser.cpp:64-67]() - Updates status, calls `syncDatabase(true)`\n- **`onItemDoubleClicked()`** [src/ui/SunoBrowser.cpp:80-88]() - Matches item to clip by ID, triggers download\n\n**Sources:** [src/ui/SunoBrowser.cpp:59-88]()\n\n### List Population\n\nThe `updateList()` slot is called when the controller emits `libraryUpdated`:\n\n```cpp\nvoid SunoBrowser::updateList(const std::vector\u003cSunoClip\u003e\u0026 clips) {\n    currentClips_ = clips;\n    clipList_-\u003eclear();\n    for (const auto\u0026 clip : clips) {\n        auto* item = new QListWidgetItem(QString::fromStdString(clip.title));\n        item-\u003esetData(Qt::UserRole, QString::fromStdString(clip.id));\n        clipList_-\u003eaddItem(item);\n    }\n    statusLabel_-\u003esetText(QString(\"Found %1 clips\").arg(clips.size()));\n}\n```\n\n**Key Details:**\n- Stores the full clip vector in `currentClips_` for lookup during double-click\n- Each `QListWidgetItem` displays the title but stores the clip ID in `Qt::UserRole`\n- Status label shows the clip count\n\n**Sources:** [src/ui/SunoBrowser.cpp:69-78]()\n\n---\n\n## Integration with Main Application\n\n### Controller Initialization\n\nThe `SunoController` is instantiated by `MainWindow` and passed to `SunoBrowser`:\n\n```cpp\n// In MainWindow or similar context:\nauto* sunoController = new SunoController(audioEngine_, overlayEngine_, this);\nauto* sunoBrowser = new SunoBrowser(sunoController);\n```\n\nThe controller receives non-owning pointers to:\n- **AudioEngine** - For adding downloaded tracks to playlist\n- **OverlayEngine** - For passing aligned lyrics\n- **MainWindow** - For showing dialogs (though currently uses `new` directly)\n\n**Sources:** [src/ui/controllers/SunoController.cpp:18-26]()\n\n### Data Flow Summary\n\n```mermaid\nflowchart TD\n    USER[\"User Action\"] --\u003e BROWSER[\"SunoBrowser\u003cbr/\u003eUI Events\"]\n    BROWSER --\u003e CTRL[\"SunoController\u003cbr/\u003eOrchestration\"]\n    \n    CTRL --\u003e CLIENT[\"SunoClient\u003cbr/\u003eAPI Communication\"]\n    CLIENT --\u003e API[\"Suno/Clerk APIs\"]\n    \n    CTRL --\u003e DB[\"SunoDatabase\u003cbr/\u003eSQLite Storage\"]\n    \n    CTRL --\u003e NM[\"QNetworkAccessManager\u003cbr/\u003eAudio Downloads\"]\n    NM --\u003e FS[\"File System\u003cbr/\u003esuno_downloads/\"]\n    \n    FS --\u003e AE[\"AudioEngine\u003cbr/\u003ePlaylist Integration\"]\n    DB --\u003e OE[\"OverlayEngine\u003cbr/\u003eLyrics Display\"]\n    \n    CTRL --\u003e BROWSER_UPDATE[\"Signal: libraryUpdated\u003cbr/\u003eSignal: statusMessage\"]\n    BROWSER_UPDATE --\u003e BROWSER\n```\n\n**Sources:** [src/ui/controllers/SunoController.cpp:1-212](), [src/ui/SunoBrowser.cpp:1-91]()\n\n---\n\n## Error Handling\n\n### Error Flow\n\nErrors from `SunoClient` are routed through the controller's `onError()` slot:\n\n```cpp\nvoid SunoController::onError(const std::string\u0026 message) {\n    activeLyricsRequests_ = std::max(0, activeLyricsRequests_ - 1);\n    processLyricsQueue();\n    \n    LOG_ERROR(\"SunoController: {}\", message);\n    statusMessage.emitSignal(message);\n}\n```\n\n**Error Handling Steps:**\n1. Decrement the active lyrics request counter (if applicable)\n2. Process more from the lyrics queue\n3. Log the error via `LOG_ERROR`\n4. Emit `statusMessage` signal to update UI\n\nThe browser receives this via its connected signal and displays the error in `statusLabel_`.\n\n**Sources:** [src/ui/controllers/SunoController.cpp:151-157]()\n\n### Download Failure Handling\n\nDownload failures are logged but do not show in the UI status label:\n\n```cpp\nif (reply-\u003eerror() != QNetworkReply::NoError) {\n    LOG_ERROR(\"SunoController: Download failed: {}\", \n              reply-\u003eerrorString().toStdString());\n    return;\n}\n```\n\nFile write failures are also logged:\n\n```cpp\nif (!file.open(QIODevice::WriteOnly)) {\n    LOG_ERROR(\"SunoController: Failed to open file for writing: {}\", \n              filePath.string());\n}\n```\n\n**Sources:** [src/ui/controllers/SunoController.cpp:177-196]()\n\n---\n\n## Configuration Dependencies\n\nThe controller reads from `CONFIG.suno()`:\n\n| Config Field | Default | Usage |\n|--------------|---------|-------|\n| `token` | empty | JWT token for API authentication |\n| `cookie` | empty | Session cookie (written by dialog) |\n| `downloadPath` | `dataDir()/suno_downloads` | Where to save audio files |\n\nThe `showCookieDialog()` method writes the cookie back to config and saves:\n\n```cpp\nCONFIG.suno().cookie = cookie;\nCONFIG.save(CONFIG.configPath());\n```\n\n**Sources:** [src/ui/controllers/SunoController.cpp:44-56](), [src/ui/controllers/SunoController.cpp:82-83]()"])</script><script>self.__next_f.push([1,"5:[\"$\",\"$L15\",null,{\"repoName\":\"Nsomnia/chadvis-projectm-qt\",\"hasConfig\":false,\"canSteer\":true,\"children\":[\"$\",\"$L16\",null,{\"wiki\":{\"metadata\":{\"repo_name\":\"Nsomnia/chadvis-projectm-qt\",\"commit_hash\":\"8320db27\",\"generated_at\":\"2026-01-07T23:29:36.048832\",\"config\":null,\"config_source\":\"none\"},\"pages\":[{\"page_plan\":{\"id\":\"1\",\"title\":\"Overview\"},\"content\":\"$17\"},{\"page_plan\":{\"id\":\"1.1\",\"title\":\"Architecture \u0026 Design Patterns\"},\"content\":\"$18\"},{\"page_plan\":{\"id\":\"1.2\",\"title\":\"Building \u0026 Running\"},\"content\":\"$19\"},{\"page_plan\":{\"id\":\"2\",\"title\":\"Core Systems\"},\"content\":\"$1a\"},{\"page_plan\":{\"id\":\"2.1\",\"title\":\"Application \u0026 Config\"},\"content\":\"$1b\"},{\"page_plan\":{\"id\":\"2.2\",\"title\":\"Build System \u0026 Dependencies\"},\"content\":\"$1c\"},{\"page_plan\":{\"id\":\"3\",\"title\":\"Audio System\"},\"content\":\"$1d\"},{\"page_plan\":{\"id\":\"3.1\",\"title\":\"AudioEngine\"},\"content\":\"$1e\"},{\"page_plan\":{\"id\":\"3.2\",\"title\":\"Playlist Management\"},\"content\":\"$1f\"},{\"page_plan\":{\"id\":\"4\",\"title\":\"Visualization System\"},\"content\":\"$20\"},{\"page_plan\":{\"id\":\"4.1\",\"title\":\"VisualizerWindow\"},\"content\":\"$21\"},{\"page_plan\":{\"id\":\"4.2\",\"title\":\"ProjectM Integration\"},\"content\":\"$22\"},{\"page_plan\":{\"id\":\"4.3\",\"title\":\"Preset Management\"},\"content\":\"$23\"},{\"page_plan\":{\"id\":\"5\",\"title\":\"Recording System\"},\"content\":\"$24\"},{\"page_plan\":{\"id\":\"5.1\",\"title\":\"VideoRecorder\"},\"content\":\"$25\"},{\"page_plan\":{\"id\":\"5.2\",\"title\":\"Frame Capture \u0026 PBOs\"},\"content\":\"$26\"},{\"page_plan\":{\"id\":\"6\",\"title\":\"Overlay System\"},\"content\":\"$27\"},{\"page_plan\":{\"id\":\"6.1\",\"title\":\"OverlayEngine \u0026 Elements\"},\"content\":\"$28\"},{\"page_plan\":{\"id\":\"6.2\",\"title\":\"OverlayRenderer\"},\"content\":\"$29\"},{\"page_plan\":{\"id\":\"7\",\"title\":\"User Interface\"},\"content\":\"$2a\"},{\"page_plan\":{\"id\":\"7.1\",\"title\":\"MainWindow \u0026 Layout\"},\"content\":\"$2b\"},{\"page_plan\":{\"id\":\"7.2\",\"title\":\"Controller Layer\"},\"content\":\"$2c\"},{\"page_plan\":{\"id\":\"7.3\",\"title\":\"Settings Dialog\"},\"content\":\"$2d\"},{\"page_plan\":{\"id\":\"8\",\"title\":\"Suno AI Integration\"},\"content\":\"$2e\"},{\"page_plan\":{\"id\":\"8.1\",\"title\":\"SunoClient \u0026 API\"},\"content\":\"$2f\"},{\"page_plan\":{\"id\":\"8.2\",\"title\":\"SunoController \u0026 UI\"},\"content\":\"$30\"}]},\"children\":\"$L31\"}]}]\n"])</script><script>self.__next_f.push([1,"31:[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]\n"])</script><script>self.__next_f.push([1,"32:I[36505,[],\"IconMark\"]\n"])</script><script>self.__next_f.push([1,"6:[[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"TechArticle\\\",\\\"headline\\\":\\\"Overview\\\",\\\"description\\\":\\\"This page provides a comprehensive introduction to chadvis-projectm-qt, covering its purpose, architecture, technology stack, and core systems. For detailed information on specific subsystems, refer t\\\",\\\"image\\\":\\\"https://deepwiki.com/Nsomnia/chadvis-projectm-qt/og-image.png\\\",\\\"datePublished\\\":\\\"2026-01-07T23:29:36.048832\\\",\\\"dateModified\\\":\\\"2026-01-07T23:29:36.048832\\\",\\\"author\\\":{\\\"@type\\\":\\\"Organization\\\",\\\"name\\\":\\\"DeepWiki\\\",\\\"url\\\":\\\"https://deepwiki.com\\\"},\\\"publisher\\\":{\\\"@type\\\":\\\"Organization\\\",\\\"name\\\":\\\"DeepWiki\\\",\\\"logo\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"url\\\":\\\"https://deepwiki.com/icon.png\\\"}},\\\"mainEntityOfPage\\\":{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://deepwiki.com/Nsomnia/chadvis-projectm-qt\\\"}}\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]\n"])</script><script>self.__next_f.push([1,"e:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Nsomnia/chadvis-projectm-qt | DeepWiki\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"This page provides a comprehensive introduction to chadvis-projectm-qt, covering its purpose, architecture, technology stack, and core systems. For detailed information on specific subsystems, refer t\"}],[\"$\",\"meta\",\"2\",{\"name\":\"keywords\",\"content\":\"Nsomnia/chadvis-projectm-qt,Nsomnia,chadvis-projectm-qt,documentation,wiki,codebase,AI documentation,Devin,Overview\"}],[\"$\",\"link\",\"3\",{\"rel\":\"canonical\",\"href\":\"https://deepwiki.com/Nsomnia/chadvis-projectm-qt\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:title\",\"content\":\"Nsomnia/chadvis-projectm-qt | DeepWiki\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:description\",\"content\":\"This page provides a comprehensive introduction to chadvis-projectm-qt, covering its purpose, architecture, technology stack, and core systems. For detailed information on specific subsystems, refer t\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:url\",\"content\":\"https://deepwiki.com/Nsomnia/chadvis-projectm-qt\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:site_name\",\"content\":\"DeepWiki\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:image\",\"content\":\"https://deepwiki.com/Nsomnia/chadvis-projectm-qt/og-image.png?page=1\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"10\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"11\",{\"name\":\"twitter:site\",\"content\":\"@cognition\"}],[\"$\",\"meta\",\"12\",{\"name\":\"twitter:creator\",\"content\":\"@cognition\"}],[\"$\",\"meta\",\"13\",{\"name\":\"twitter:title\",\"content\":\"Nsomnia/chadvis-projectm-qt | DeepWiki\"}],[\"$\",\"meta\",\"14\",{\"name\":\"twitter:description\",\"content\":\"This page provides a comprehensive introduction to chadvis-projectm-qt, covering its purpose, architecture, technology stack, and core systems. For detailed information on specific subsystems, refer t\"}],[\"$\",\"meta\",\"15\",{\"name\":\"twitter:image\",\"content\":\"https://deepwiki.com/Nsomnia/chadvis-projectm-qt/og-image.png?page=1\"}],[\"$\",\"link\",\"16\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"48x48\"}],[\"$\",\"link\",\"17\",{\"rel\":\"icon\",\"href\":\"/icon.png?1ee4c6a68a73a205\",\"type\":\"image/png\",\"sizes\":\"48x48\"}],[\"$\",\"link\",\"18\",{\"rel\":\"apple-touch-icon\",\"href\":\"/apple-icon.png?a4f658907db0ab87\",\"type\":\"image/png\",\"sizes\":\"180x180\"}],[\"$\",\"$L32\",\"19\",{}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script>self.__next_f.push([1,"13:\"$e:metadata\"\n"])</script></body></html>